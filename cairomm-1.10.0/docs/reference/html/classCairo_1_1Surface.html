<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
        <title>cairomm: Cairo::Surface Class Reference</title>
        <link href="cairomm.css" rel="stylesheet" type="text/css">
    </head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceCairo.html">Cairo</a> </li>
      <li class="navelem"><a class="el" href="classCairo_1_1Surface.html">Surface</a> </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> </div>
  <div class="headertitle">
<h1>Cairo::Surface Class Reference</h1> </div>
</div>
<div class="contents">
<!-- doxytag: class="Cairo::Surface" -->
<p>A cairo surface represents an image, either as the destination of a drawing operation or as source when drawing onto another surface. <a href="#_details">More...</a></p>
<div class="dynheader">
Inheritance diagram for Cairo::Surface:</div>
<div class="dyncontent">
<div class="center"><img src="classCairo_1_1Surface__inherit__graph.png" border="0" usemap="#Cairo_1_1Surface_inherit__map" alt="Inheritance graph"/></div>
<map name="Cairo_1_1Surface_inherit__map" id="Cairo_1_1Surface_inherit__map">
<area shape="rect" id="node3" href="classCairo_1_1GlitzSurface.html" title="A GlitzSurface provides a way to render to the X Window System using Glitz." alt="" coords="188,5,319,35"/><area shape="rect" id="node5" href="classCairo_1_1ImageSurface.html" title="Image surfaces provide the ability to render to memory buffers either allocated by cairo or by the ca..." alt="" coords="183,58,324,89"/><area shape="rect" id="node7" href="classCairo_1_1PdfSurface.html" title="A PdfSurface provides a way to render PDF documents from cairo." alt="" coords="192,111,315,142"/><area shape="rect" id="node9" href="classCairo_1_1PsSurface.html" title="A PsSurface provides a way to render PostScript documents from cairo." alt="" coords="193,165,313,195"/><area shape="rect" id="node11" href="classCairo_1_1QuartzSurface.html" title="A QuartzSurface provides a way to render within Apple Mac OS X." alt="" coords="181,218,325,249"/><area shape="rect" id="node13" href="classCairo_1_1SvgSurface.html" title="A SvgSurface provides a way to render Scalable Vector Graphics (SVG) images from cairo." alt="" coords="189,271,317,302"/><area shape="rect" id="node15" href="classCairo_1_1Win32PrintingSurface.html" title="A multi&#45;page vector surface type for printing on Microsoft Windows." alt="" coords="161,325,345,355"/><area shape="rect" id="node17" href="classCairo_1_1Win32Surface.html" title="A Win32Surface provides a way to render within Microsoft Windows." alt="" coords="183,378,324,409"/><area shape="rect" id="node19" href="classCairo_1_1XlibSurface.html" title="An XlibSurface provides a way to render to the X Window System using XLib." alt="" coords="191,431,316,462"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classCairo_1_1Surface-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">sigc::slot</a><br class="typebreak"/>
&lt; ErrorStatus, const unsigned <br class="typebreak"/>
char*, unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#a02fb9416d466b762bc5845b0ae204f49">SlotWriteFunc</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">For example: <code> ErrorStatus my_write_func(unsigned char* data, unsigned int length); </code> <a href="#a02fb9416d466b762bc5845b0ae204f49"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">sigc::slot</a><br class="typebreak"/>
&lt; ErrorStatus, unsigned char <br class="typebreak"/>
*, unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#af66be8453e3fc558ea1282a911bf60e2">SlotReadFunc</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type of function which is called when a backend needs to read data from an input stream. <a href="#af66be8453e3fc558ea1282a911bf60e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">sigc::slot</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#a150d8ae84fa994f8e2032caa525c166a">SlotDestroy</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">For instance, void on_destroy();. <a href="#a150d8ae84fa994f8e2032caa525c166a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef cairo_surface_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#ad176eb7343b5902df3c19f9f56e59fb4">cobject</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The underlying C cairo surface type. <a href="#ad176eb7343b5902df3c19f9f56e59fb4"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#a47b90669a5a85d187cc0d28dc99915c8">Surface</a> (cairo_surface_t*<a class="el" href="classCairo_1_1Surface.html#ad176eb7343b5902df3c19f9f56e59fb4">cobject</a>, bool has_reference=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a C++ wrapper for the C instance. <a href="#a47b90669a5a85d187cc0d28dc99915c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#a64ca52e9e8e9a64358ff85e6ef0d93c1">~Surface</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const unsigned char*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#a998e72aa2c251f96f450a168e16c87b6">get_mime_data</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00254.html">std::string</a>&amp; mime_type, unsigned long&amp; length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return mime data previously attached to surface using the specified mime type. <a href="#a998e72aa2c251f96f450a168e16c87b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#a7c572103fe56f7c6d0b83f2986338f82">set_mime_data</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00254.html">std::string</a>&amp; mime_type, unsigned char* data, unsigned long length, const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotDestroy</a>&amp; slot_destroy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach an image in the format mime_type to surface. <a href="#a7c572103fe56f7c6d0b83f2986338f82"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#a5074b0c28c547802824d6d6cd2b0b8b5">unset_mime_data</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00254.html">std::string</a>&amp; mime_type)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the data from a surface. <a href="#a5074b0c28c547802824d6d6cd2b0b8b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#a7e3dd712e398719315bbd89efe9af0b2">get_font_options</a> (<a class="el" href="classCairo_1_1FontOptions.html">FontOptions</a>&amp; options) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the default font rendering options for the surface. <a href="#a7e3dd712e398719315bbd89efe9af0b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#a8d8afee4ddb4935b85698f27099646a0">finish</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function finishes the surface and drops all references to external resources. <a href="#a8d8afee4ddb4935b85698f27099646a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#a8f95678918fb40bae15f8aad2adb6ef2">flush</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Do any pending drawing for the surface and also restore any temporary modifications cairo has made to the surface's state. <a href="#a8f95678918fb40bae15f8aad2adb6ef2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#a77b1f860cc55f4ad168e100108e0b7bb">mark_dirty</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells cairo to consider the data buffer dirty. <a href="#a77b1f860cc55f4ad168e100108e0b7bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#a1dbf3a036b7dc7c09fc86996ea1ee61f">mark_dirty</a> (int x, int y, int width, int height)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks a rectangular area of the given surface dirty. <a href="#a1dbf3a036b7dc7c09fc86996ea1ee61f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#a957e290a548d3cba65aa9e3fd0c86180">set_device_offset</a> (double x_offset, double y_offset)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an offset that is added to the device coordinates determined by the CTM when drawing to surface. <a href="#a957e290a548d3cba65aa9e3fd0c86180"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#a5861783d0f5f3b396f52791a93e668fe">get_device_offset</a> (double&amp; x_offset, double&amp; y_offset) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a previous device offset set by <a class="el" href="classCairo_1_1Surface.html#a957e290a548d3cba65aa9e3fd0c86180" title="Sets an offset that is added to the device coordinates determined by the CTM when drawing to surface...">set_device_offset()</a>. <a href="#a5861783d0f5f3b396f52791a93e668fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#ac8caca30702fe2bd69ae89929ee784e8">set_fallback_resolution</a> (double x_pixels_per_inch, double y_pixels_per_inch)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the fallback resolution of the image in dots per inch. <a href="#ac8caca30702fe2bd69ae89929ee784e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#aa3a8d5a2b5c91d11f7758d0a67f6093a">get_fallback_resolution</a> (double&amp; x_pixels_per_inch, double&amp; y_pixels_per_inch) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the previous fallback resolution set by <a class="el" href="classCairo_1_1Surface.html#ac8caca30702fe2bd69ae89929ee784e8" title="Sets the fallback resolution of the image in dots per inch.">set_fallback_resolution()</a>, or default fallback resolution if never set. <a href="#aa3a8d5a2b5c91d11f7758d0a67f6093a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceCairo.html#af11d962e38a38a2d92fc1473fbe92549">SurfaceType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#a7ee0760ea1895f5e6c8f6673f83cc072">get_type</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceCairo.html#a1f0f5d82599dfeabbeb2396dbfd767d0">Content</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#a5fe39669b1d4239f3e4f73a8bf5105a5">get_content</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the content type of surface which indicates whether the surface contains color and/or alpha information. <a href="#a5fe39669b1d4239f3e4f73a8bf5105a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#aae22bcaa9becbf3ca703a380f70c2c0a">copy_page</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Emits the current page for backends that support multiple pages, but doesn't clear it, so that the contents of the current page will be retained for the next page. <a href="#aae22bcaa9becbf3ca703a380f70c2c0a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#ad318acd86c1875854ef4e1e2867052c3">show_page</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Emits and clears the current page for backends that support multiple pages. <a href="#ad318acd86c1875854ef4e1e2867052c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#ae4e133bf758c85195db6d3ccfbe1d54a">has_show_text_glyphs</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the surface supports sophisticated <a class="el" href="classCairo_1_1Context.html#a45723fd605cc2343ab46cf603d330002">Context::show_text_glyphs()</a> operations. <a href="#ae4e133bf758c85195db6d3ccfbe1d54a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#a153405d271814ab4d47b90a1c36d2370">write_to_png</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00254.html">std::string</a>&amp; filename)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the contents of surface to a new file filename as a PNG image. <a href="#a153405d271814ab4d47b90a1c36d2370"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#ab3eca5bc13abe27f470fdf08134269bb">write_to_png_stream</a> (const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotWriteFunc</a>&amp; write_func)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the <a class="el" href="classCairo_1_1Surface.html" title="A cairo surface represents an image, either as the destination of a drawing operation or as source wh...">Surface</a> to the write function. <a href="#ab3eca5bc13abe27f470fdf08134269bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#a83763b7906a666b095ce376271455457">write_to_png</a> (cairo_write_func_t write_func, void* closure)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCairo_1_1RefPtr.html">RefPtr</a>&lt; <a class="el" href="classCairo_1_1Device.html">Device</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#a3d1f19c2210e0e7a4aa3d3053b90107f">get_device</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the device for a surface. <a href="#a3d1f19c2210e0e7a4aa3d3053b90107f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCairo_1_1Surface.html#ad176eb7343b5902df3c19f9f56e59fb4">cobject</a>*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#a17d8f600aedba416bb640ac841494bde">cobj</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides acces to the underlying C cairo surface. <a href="#a17d8f600aedba416bb640ac841494bde"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classCairo_1_1Surface.html#ad176eb7343b5902df3c19f9f56e59fb4">cobject</a>*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#af45e0ec675af4bb7259df99d202ac83c">cobj</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides acces to the underlying C cairo surface. <a href="#af45e0ec675af4bb7259df99d202ac83c"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classCairo_1_1RefPtr.html">RefPtr</a>&lt; <a class="el" href="classCairo_1_1Surface.html">Surface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#ac471fbf586ba579565c6d876f9164717">create</a> (const <a class="el" href="classCairo_1_1RefPtr.html">RefPtr</a>&lt; <a class="el" href="classCairo_1_1Surface.html">Surface</a> &gt; other, <a class="el" href="namespaceCairo.html#a1f0f5d82599dfeabbeb2396dbfd767d0">Content</a> content, int width, int height)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new surface that is as compatible as possible with an existing surface. <a href="#ac471fbf586ba579565c6d876f9164717"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classCairo_1_1RefPtr.html">RefPtr</a>&lt; <a class="el" href="classCairo_1_1Surface.html">Surface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#a7d9616c09e08857cef6f771545e55274">create</a> (const <a class="el" href="classCairo_1_1RefPtr.html">RefPtr</a>&lt; <a class="el" href="classCairo_1_1Surface.html">Surface</a> &gt;&amp; target, double x, double y, double width, double height)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new surface that is a rectangle within the target surface. <a href="#a7d9616c09e08857cef6f771545e55274"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCairo_1_1Surface.html#ad176eb7343b5902df3c19f9f56e59fb4">cobject</a>*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCairo_1_1Surface.html#a8c9aea28f0d1f6c2dcb507a2c7bb027c">m_cobject</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The underlying C cairo surface type that is wrapped by this <a class="el" href="classCairo_1_1Surface.html" title="A cairo surface represents an image, either as the destination of a drawing operation or as source wh...">Surface</a>. <a href="#a8c9aea28f0d1f6c2dcb507a2c7bb027c"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>A cairo surface represents an image, either as the destination of a drawing operation or as source when drawing onto another surface. </p>
<p>There are different subtypes of cairo surface for different drawing backends. This class is a base class for all subtypes and should not be used directly</p>
<p>Surfaces are reference-counted objects that should be used via <a class="el" href="classCairo_1_1RefPtr.html" title="RefPtr&lt;&gt; is a reference-counting shared smartpointer.">Cairo::RefPtr</a>. </p>
</div><hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="ad176eb7343b5902df3c19f9f56e59fb4"></a><!-- doxytag: member="Cairo::Surface::cobject" ref="ad176eb7343b5902df3c19f9f56e59fb4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef cairo_surface_t <a class="el" href="classCairo_1_1Surface.html#ad176eb7343b5902df3c19f9f56e59fb4">Cairo::Surface::cobject</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The underlying C cairo surface type. </p>

</div>
</div>
<a class="anchor" id="a150d8ae84fa994f8e2032caa525c166a"></a><!-- doxytag: member="Cairo::Surface::SlotDestroy" ref="a150d8ae84fa994f8e2032caa525c166a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">sigc::slot</a>&lt;void&gt; <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">Cairo::Surface::SlotDestroy</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>For instance, void on_destroy();. </p>

</div>
</div>
<a class="anchor" id="af66be8453e3fc558ea1282a911bf60e2"></a><!-- doxytag: member="Cairo::Surface::SlotReadFunc" ref="af66be8453e3fc558ea1282a911bf60e2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">sigc::slot</a>&lt;ErrorStatus, unsigned char* , unsigned int &gt; <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">Cairo::Surface::SlotReadFunc</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the type of function which is called when a backend needs to read data from an input stream. </p>
<p>It is passed the buffer to read the data into and the length of the data in bytes. The read function should return CAIRO_STATUS_SUCCESS if all the data was successfully read, CAIRO_STATUS_READ_ERROR otherwise.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the buffer into which to read the data </td></tr>
    <tr><td class="paramname">length</td><td>the amount of data to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the status code of the read operation </dd></dl>

</div>
</div>
<a class="anchor" id="a02fb9416d466b762bc5845b0ae204f49"></a><!-- doxytag: member="Cairo::Surface::SlotWriteFunc" ref="a02fb9416d466b762bc5845b0ae204f49" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">sigc::slot</a>&lt;ErrorStatus, const unsigned char* , unsigned int &gt; <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">Cairo::Surface::SlotWriteFunc</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>For example: <code> ErrorStatus my_write_func(unsigned char* data, unsigned int length); </code> </p>
<p>This is the type of function which is called when a backend needs to write data to an output stream. It is passed the data to write and the length of the data in bytes. The write function should return CAIRO_STATUS_SUCCESS if all the data was successfully written, CAIRO_STATUS_WRITE_ERROR otherwise.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the buffer containing the data to write </td></tr>
    <tr><td class="paramname">length</td><td>the amount of data to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the status code of the write operation </dd></dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a47b90669a5a85d187cc0d28dc99915c8"></a><!-- doxytag: member="Cairo::Surface::Surface" ref="a47b90669a5a85d187cc0d28dc99915c8" args="(cairo_surface_t *cobject, bool has_reference=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Cairo::Surface::Surface </td>
          <td>(</td>
          <td class="paramtype">cairo_surface_t *&#160;</td>
          <td class="paramname"><em>cobject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>has_reference</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a C++ wrapper for the C instance. </p>
<p>This C++ instance should then be given to a <a class="el" href="classCairo_1_1RefPtr.html" title="RefPtr&lt;&gt; is a reference-counting shared smartpointer.">RefPtr</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cobject</td><td>The C instance. </td></tr>
    <tr><td class="paramname">has_reference</td><td>Whether we already have a reference. Otherwise, the constructor will take an extra reference. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a64ca52e9e8e9a64358ff85e6ef0d93c1"></a><!-- doxytag: member="Cairo::Surface::~Surface" ref="a64ca52e9e8e9a64358ff85e6ef0d93c1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Cairo::Surface::~Surface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a17d8f600aedba416bb640ac841494bde"></a><!-- doxytag: member="Cairo::Surface::cobj" ref="a17d8f600aedba416bb640ac841494bde" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCairo_1_1Surface.html#ad176eb7343b5902df3c19f9f56e59fb4">cobject</a>* Cairo::Surface::cobj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides acces to the underlying C cairo surface. </p>

</div>
</div>
<a class="anchor" id="af45e0ec675af4bb7259df99d202ac83c"></a><!-- doxytag: member="Cairo::Surface::cobj" ref="af45e0ec675af4bb7259df99d202ac83c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classCairo_1_1Surface.html#ad176eb7343b5902df3c19f9f56e59fb4">cobject</a>* Cairo::Surface::cobj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides acces to the underlying C cairo surface. </p>

</div>
</div>
<a class="anchor" id="aae22bcaa9becbf3ca703a380f70c2c0a"></a><!-- doxytag: member="Cairo::Surface::copy_page" ref="aae22bcaa9becbf3ca703a380f70c2c0a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Surface::copy_page </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Emits the current page for backends that support multiple pages, but doesn't clear it, so that the contents of the current page will be retained for the next page. </p>
<p>Use <a class="el" href="classCairo_1_1Surface.html#ad318acd86c1875854ef4e1e2867052c3" title="Emits and clears the current page for backends that support multiple pages.">show_page()</a> if you want to get an empty page after the emission.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>1.6 </dd></dl>

</div>
</div>
<a class="anchor" id="ac471fbf586ba579565c6d876f9164717"></a><!-- doxytag: member="Cairo::Surface::create" ref="ac471fbf586ba579565c6d876f9164717" args="(const RefPtr&lt; Surface &gt; other, Content content, int width, int height)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classCairo_1_1RefPtr.html">RefPtr</a>&lt;<a class="el" href="classCairo_1_1Surface.html">Surface</a>&gt; Cairo::Surface::create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCairo_1_1RefPtr.html">RefPtr</a>&lt; <a class="el" href="classCairo_1_1Surface.html">Surface</a> &gt;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceCairo.html#a1f0f5d82599dfeabbeb2396dbfd767d0">Content</a>&#160;</td>
          <td class="paramname"><em>content</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new surface that is as compatible as possible with an existing surface. </p>
<p>The new surface will use the same backend as other unless that is not possible for some reason.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>an existing surface used to select the backend of the new surface </td></tr>
    <tr><td class="paramname">content</td><td>the content for the new surface </td></tr>
    <tr><td class="paramname">width</td><td>width of the new surface, (in device-space units) </td></tr>
    <tr><td class="paramname">height</td><td>height of the new surface (in device-space units) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a <a class="el" href="classCairo_1_1RefPtr.html" title="RefPtr&lt;&gt; is a reference-counting shared smartpointer.">RefPtr</a> to the newly allocated surface. </dd></dl>

</div>
</div>
<a class="anchor" id="a7d9616c09e08857cef6f771545e55274"></a><!-- doxytag: member="Cairo::Surface::create" ref="a7d9616c09e08857cef6f771545e55274" args="(const RefPtr&lt; Surface &gt; &amp;target, double x, double y, double width, double height)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classCairo_1_1RefPtr.html">RefPtr</a>&lt;<a class="el" href="classCairo_1_1Surface.html">Surface</a>&gt; Cairo::Surface::create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCairo_1_1RefPtr.html">RefPtr</a>&lt; <a class="el" href="classCairo_1_1Surface.html">Surface</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new surface that is a rectangle within the target surface. </p>
<p>All operations drawn to this surface are then clipped and translated onto the target surface. Nothing drawn via this sub-surface outside of its bounds is drawn onto the target surface, making this a useful method for passing constrained child surfaces to library routines that draw directly onto the parent surface, i.e. with no further backend allocations, double buffering or copies.</p>
<p>The semantics of subsurfaces have not been finalized yet unless the rectangle is in full device units, is contained within the extents of the target surface, and the target or subsurface's device transforms are not changed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>an existing surface for which the sub-surface will point to </td></tr>
    <tr><td class="paramname">x</td><td>the x-origin of the sub-surface from the top-left of the target surface (in device-space units) </td></tr>
    <tr><td class="paramname">y</td><td>the y-origin of the sub-surface from the top-left of the target surface (in device-space units) </td></tr>
    <tr><td class="paramname">width</td><td>width of the sub-surface (in device-space units) </td></tr>
    <tr><td class="paramname">height</td><td>height of the sub-surface (in device-space units)</td></tr>
  </table>
  </dd>
</dl>
<dl class="since"><dt><b>Since:</b></dt><dd>1.10 </dd></dl>

</div>
</div>
<a class="anchor" id="a8d8afee4ddb4935b85698f27099646a0"></a><!-- doxytag: member="Cairo::Surface::finish" ref="a8d8afee4ddb4935b85698f27099646a0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Surface::finish </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function finishes the surface and drops all references to external resources. </p>
<p>For example, for the Xlib backend it means that cairo will no longer access the drawable, which can be freed. After calling <a class="el" href="classCairo_1_1Surface.html#a8d8afee4ddb4935b85698f27099646a0" title="This function finishes the surface and drops all references to external resources.">finish()</a> the only valid operations on a surface are getting and setting user data and referencing and destroying it. Further drawing to the surface will not affect the surface but will instead trigger a CAIRO_STATUS_SURFACE_FINISHED error.</p>
<p>When the <a class="el" href="classCairo_1_1Surface.html" title="A cairo surface represents an image, either as the destination of a drawing operation or as source wh...">Surface</a> is destroyed, cairo will call <a class="el" href="classCairo_1_1Surface.html#a8d8afee4ddb4935b85698f27099646a0" title="This function finishes the surface and drops all references to external resources.">finish()</a> if it hasn't been called already, before freeing the resources associated with the <a class="el" href="classCairo_1_1Surface.html" title="A cairo surface represents an image, either as the destination of a drawing operation or as source wh...">Surface</a>. </p>

</div>
</div>
<a class="anchor" id="a8f95678918fb40bae15f8aad2adb6ef2"></a><!-- doxytag: member="Cairo::Surface::flush" ref="a8f95678918fb40bae15f8aad2adb6ef2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Surface::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Do any pending drawing for the surface and also restore any temporary modifications cairo has made to the surface's state. </p>
<p>This function must be called before switching from drawing on the surface with cairo to drawing on it directly with native APIs. If the surface doesn't support direct access, then this function does nothing. </p>

</div>
</div>
<a class="anchor" id="a5fe39669b1d4239f3e4f73a8bf5105a5"></a><!-- doxytag: member="Cairo::Surface::get_content" ref="a5fe39669b1d4239f3e4f73a8bf5105a5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceCairo.html#a1f0f5d82599dfeabbeb2396dbfd767d0">Content</a> Cairo::Surface::get_content </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function returns the content type of surface which indicates whether the surface contains color and/or alpha information. </p>
<dl class="since"><dt><b>Since:</b></dt><dd>1.8 </dd></dl>

</div>
</div>
<a class="anchor" id="a3d1f19c2210e0e7a4aa3d3053b90107f"></a><!-- doxytag: member="Cairo::Surface::get_device" ref="a3d1f19c2210e0e7a4aa3d3053b90107f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCairo_1_1RefPtr.html">RefPtr</a>&lt;<a class="el" href="classCairo_1_1Device.html">Device</a>&gt; Cairo::Surface::get_device </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function returns the device for a surface. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The device for this surface, or an empty <a class="el" href="classCairo_1_1RefPtr.html" title="RefPtr&lt;&gt; is a reference-counting shared smartpointer.">RefPtr</a> if the surface has no associated device </dd></dl>

</div>
</div>
<a class="anchor" id="a5861783d0f5f3b396f52791a93e668fe"></a><!-- doxytag: member="Cairo::Surface::get_device_offset" ref="a5861783d0f5f3b396f52791a93e668fe" args="(double &amp;x_offset, double &amp;y_offset) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Surface::get_device_offset </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>x_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>y_offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a previous device offset set by <a class="el" href="classCairo_1_1Surface.html#a957e290a548d3cba65aa9e3fd0c86180" title="Sets an offset that is added to the device coordinates determined by the CTM when drawing to surface...">set_device_offset()</a>. </p>

</div>
</div>
<a class="anchor" id="aa3a8d5a2b5c91d11f7758d0a67f6093a"></a><!-- doxytag: member="Cairo::Surface::get_fallback_resolution" ref="aa3a8d5a2b5c91d11f7758d0a67f6093a" args="(double &amp;x_pixels_per_inch, double &amp;y_pixels_per_inch) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Surface::get_fallback_resolution </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>x_pixels_per_inch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>y_pixels_per_inch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function returns the previous fallback resolution set by <a class="el" href="classCairo_1_1Surface.html#ac8caca30702fe2bd69ae89929ee784e8" title="Sets the fallback resolution of the image in dots per inch.">set_fallback_resolution()</a>, or default fallback resolution if never set. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x_pixels_per_inch</td><td>horizontal pixels per inch </td></tr>
    <tr><td class="paramname">y_pixels_per_inch</td><td>vertical pixels per inch</td></tr>
  </table>
  </dd>
</dl>
<dl class="since"><dt><b>Since:</b></dt><dd>1.8 </dd></dl>

</div>
</div>
<a class="anchor" id="a7e3dd712e398719315bbd89efe9af0b2"></a><!-- doxytag: member="Cairo::Surface::get_font_options" ref="a7e3dd712e398719315bbd89efe9af0b2" args="(FontOptions &amp;options) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Surface::get_font_options </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCairo_1_1FontOptions.html">FontOptions</a>&amp;&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the default font rendering options for the surface. </p>
<p>This allows display surfaces to report the correct subpixel order for rendering on them, print surfaces to disable hinting of metrics and so forth. The result can then be used with cairo_scaled_font_create().</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>a <a class="el" href="classCairo_1_1FontOptions.html" title="How a font should be rendered.">FontOptions</a> object into which to store the retrieved options. All existing values are overwritten </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a998e72aa2c251f96f450a168e16c87b6"></a><!-- doxytag: member="Cairo::Surface::get_mime_data" ref="a998e72aa2c251f96f450a168e16c87b6" args="(const std::string &amp;mime_type, unsigned long &amp;length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char* Cairo::Surface::get_mime_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00254.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>mime_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long &amp;&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return mime data previously attached to surface using the specified mime type. </p>
<p>If no data has been attached with the given mime type then this returns 0.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mime_type</td><td>The MIME type of the image data. </td></tr>
    <tr><td class="paramname">length</td><td>This will be set to the length of the image data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The image data attached to the surface. </dd></dl>

</div>
</div>
<a class="anchor" id="a7ee0760ea1895f5e6c8f6673f83cc072"></a><!-- doxytag: member="Cairo::Surface::get_type" ref="a7ee0760ea1895f5e6c8f6673f83cc072" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceCairo.html#af11d962e38a38a2d92fc1473fbe92549">SurfaceType</a> Cairo::Surface::get_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae4e133bf758c85195db6d3ccfbe1d54a"></a><!-- doxytag: member="Cairo::Surface::has_show_text_glyphs" ref="ae4e133bf758c85195db6d3ccfbe1d54a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cairo::Surface::has_show_text_glyphs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether the surface supports sophisticated <a class="el" href="classCairo_1_1Context.html#a45723fd605cc2343ab46cf603d330002">Context::show_text_glyphs()</a> operations. </p>
<p>That is, whether it actually uses the provided text and cluster data to a <a class="el" href="classCairo_1_1Context.html#a45723fd605cc2343ab46cf603d330002">Context::show_text_glyphs()</a> call.</p>
<p>Note: Even if this function returns FALSE, a <a class="el" href="classCairo_1_1Context.html#a45723fd605cc2343ab46cf603d330002">Context::show_text_glyphs()</a> operation targeted at this surface will still succeed. It just will act like a <a class="el" href="classCairo_1_1Context.html#af51f2c2ff72e8af66abeea3d15d25553">Context::show_glyphs()</a> operation. Users can use this function to avoid computing UTF-8 text and cluster mapping if the target surface does not use it.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>1.8 </dd></dl>

</div>
</div>
<a class="anchor" id="a1dbf3a036b7dc7c09fc86996ea1ee61f"></a><!-- doxytag: member="Cairo::Surface::mark_dirty" ref="a1dbf3a036b7dc7c09fc86996ea1ee61f" args="(int x, int y, int width, int height)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Surface::mark_dirty </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Marks a rectangular area of the given surface dirty. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X coordinate of dirty rectangle </td></tr>
    <tr><td class="paramname">y</td><td>Y coordinate of dirty rectangle </td></tr>
    <tr><td class="paramname">width</td><td>width of dirty rectangle </td></tr>
    <tr><td class="paramname">height</td><td>height of dirty rectangle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a77b1f860cc55f4ad168e100108e0b7bb"></a><!-- doxytag: member="Cairo::Surface::mark_dirty" ref="a77b1f860cc55f4ad168e100108e0b7bb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Surface::mark_dirty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tells cairo to consider the data buffer dirty. </p>
<p>In particular, if you've created an <a class="el" href="classCairo_1_1ImageSurface.html" title="Image surfaces provide the ability to render to memory buffers either allocated by cairo or by the ca...">ImageSurface</a> with a data buffer that you've allocated yourself and you draw to that data buffer using means other than cairo, you must call <a class="el" href="classCairo_1_1Surface.html#a77b1f860cc55f4ad168e100108e0b7bb" title="Tells cairo to consider the data buffer dirty.">mark_dirty()</a> before doing any additional drawing to that surface with cairo.</p>
<p>Note that if you do draw to the <a class="el" href="classCairo_1_1Surface.html" title="A cairo surface represents an image, either as the destination of a drawing operation or as source wh...">Surface</a> outside of cairo, you must call <a class="el" href="classCairo_1_1Surface.html#a8f95678918fb40bae15f8aad2adb6ef2" title="Do any pending drawing for the surface and also restore any temporary modifications cairo has made to...">flush()</a> before doing the drawing. </p>

</div>
</div>
<a class="anchor" id="a957e290a548d3cba65aa9e3fd0c86180"></a><!-- doxytag: member="Cairo::Surface::set_device_offset" ref="a957e290a548d3cba65aa9e3fd0c86180" args="(double x_offset, double y_offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Surface::set_device_offset </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y_offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets an offset that is added to the device coordinates determined by the CTM when drawing to surface. </p>
<p>One use case for this function is when we want to create a <a class="el" href="classCairo_1_1Surface.html" title="A cairo surface represents an image, either as the destination of a drawing operation or as source wh...">Surface</a> that redirects drawing for a portion of an onscreen surface to an offscreen surface in a way that is completely invisible to the user of the cairo API. Setting a transformation via cairo_translate() isn't sufficient to do this, since functions like <a class="el" href="classCairo_1_1Context.html#a0c7acaaf16d4740cd7fee2298bf2b5c4" title="Transform a coordinate from device space to user space by multiplying the given point by the inverse ...">Cairo::Context::device_to_user()</a> will expose the hidden offset.</p>
<p>Note that the offset only affects drawing to the surface, not using the surface in a surface pattern.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x_offset</td><td>the offset in the X direction, in device units </td></tr>
    <tr><td class="paramname">y_offset</td><td>the offset in the Y direction, in device units </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac8caca30702fe2bd69ae89929ee784e8"></a><!-- doxytag: member="Cairo::Surface::set_fallback_resolution" ref="ac8caca30702fe2bd69ae89929ee784e8" args="(double x_pixels_per_inch, double y_pixels_per_inch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Surface::set_fallback_resolution </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x_pixels_per_inch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y_pixels_per_inch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the fallback resolution of the image in dots per inch. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x_pixels_per_inch</td><td>Pixels per inch in the x direction </td></tr>
    <tr><td class="paramname">y_pixels_per_inch</td><td>Pixels per inch in the y direction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7c572103fe56f7c6d0b83f2986338f82"></a><!-- doxytag: member="Cairo::Surface::set_mime_data" ref="a7c572103fe56f7c6d0b83f2986338f82" args="(const std::string &amp;mime_type, unsigned char *data, unsigned long length, const SlotDestroy &amp;slot_destroy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Surface::set_mime_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00254.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>mime_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotDestroy</a> &amp;&#160;</td>
          <td class="paramname"><em>slot_destroy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attach an image in the format mime_type to surface. </p>
<p>To remove the data from a surface, call <a class="el" href="classCairo_1_1Surface.html#a5074b0c28c547802824d6d6cd2b0b8b5" title="Remove the data from a surface.">unset_mime_data()</a> with same mime type.</p>
<p>The attached image (or filename) data can later be used by backends which support it (currently: PDF, PS, SVG and Win32 Printing surfaces) to emit this data instead of making a snapshot of the surface. This approach tends to be faster and requires less memory and disk space.</p>
<p>The recognized MIME types are the following: CAIRO_MIME_TYPE_JPEG, CAIRO_MIME_TYPE_PNG, CAIRO_MIME_TYPE_JP2, CAIRO_MIME_TYPE_URI.</p>
<p>See corresponding backend surface docs for details about which MIME types it can handle. Caution: the associated MIME data will be discarded if you draw on the surface afterwards. Use this function with care.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mime_type</td><td>The MIME type of the image data. </td></tr>
    <tr><td class="paramname">data</td><td>The image data to attach to the surface. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the image data. </td></tr>
    <tr><td class="paramname">slot_destroy</td><td>A callback slot that will be called when the <a class="el" href="classCairo_1_1Surface.html" title="A cairo surface represents an image, either as the destination of a drawing operation or as source wh...">Surface</a> no longer needs the data. For instance, when the <a class="el" href="classCairo_1_1Surface.html" title="A cairo surface represents an image, either as the destination of a drawing operation or as source wh...">Surface</a> is destroyed or when new image data is attached using the same MIME tpe. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad318acd86c1875854ef4e1e2867052c3"></a><!-- doxytag: member="Cairo::Surface::show_page" ref="ad318acd86c1875854ef4e1e2867052c3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Surface::show_page </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Emits and clears the current page for backends that support multiple pages. </p>
<p>Use <a class="el" href="classCairo_1_1Surface.html#aae22bcaa9becbf3ca703a380f70c2c0a" title="Emits the current page for backends that support multiple pages, but doesn&#39;t clear it...">copy_page()</a> if you don't want to clear the page.</p>
<dl class="since"><dt><b>Since:</b></dt><dd>1.6 </dd></dl>

</div>
</div>
<a class="anchor" id="a5074b0c28c547802824d6d6cd2b0b8b5"></a><!-- doxytag: member="Cairo::Surface::unset_mime_data" ref="a5074b0c28c547802824d6d6cd2b0b8b5" args="(const std::string &amp;mime_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Surface::unset_mime_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00254.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>mime_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove the data from a surface. </p>
<p>See <a class="el" href="classCairo_1_1Surface.html#a7c572103fe56f7c6d0b83f2986338f82" title="Attach an image in the format mime_type to surface.">set_mime_data()</a>. </p>

</div>
</div>
<a class="anchor" id="a153405d271814ab4d47b90a1c36d2370"></a><!-- doxytag: member="Cairo::Surface::write_to_png" ref="a153405d271814ab4d47b90a1c36d2370" args="(const std::string &amp;filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Surface::write_to_png </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00254.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes the contents of surface to a new file filename as a PNG image. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>For this function to be available, cairo must have been compiled with PNG support</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the name of a file to write to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a83763b7906a666b095ce376271455457"></a><!-- doxytag: member="Cairo::Surface::write_to_png" ref="a83763b7906a666b095ce376271455457" args="(cairo_write_func_t write_func, void *closure)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Surface::write_to_png </td>
          <td>(</td>
          <td class="paramtype">cairo_write_func_t&#160;</td>
          <td class="paramname"><em>write_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>closure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000011">Deprecated:</a></b></dt><dd>Use write_to_png_stream instead </dd></dl>

</div>
</div>
<a class="anchor" id="ab3eca5bc13abe27f470fdf08134269bb"></a><!-- doxytag: member="Cairo::Surface::write_to_png_stream" ref="ab3eca5bc13abe27f470fdf08134269bb" args="(const SlotWriteFunc &amp;write_func)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cairo::Surface::write_to_png_stream </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libsigc++-2.0.tag:http://library.gnome.org/devel/libsigc++/unstable/" href="http://library.gnome.org/devel/libsigc++/unstable/classsigc_1_1slot.html">SlotWriteFunc</a> &amp;&#160;</td>
          <td class="paramname"><em>write_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes the <a class="el" href="classCairo_1_1Surface.html" title="A cairo surface represents an image, either as the destination of a drawing operation or as source wh...">Surface</a> to the write function. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>For this function to be available, cairo must have been compiled with PNG support</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">write_func</td><td>The function to be called when the backend needs to write data to an output stream</td></tr>
  </table>
  </dd>
</dl>
<dl class="since"><dt><b>Since:</b></dt><dd>1.8 </dd></dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a8c9aea28f0d1f6c2dcb507a2c7bb027c"></a><!-- doxytag: member="Cairo::Surface::m_cobject" ref="a8c9aea28f0d1f6c2dcb507a2c7bb027c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCairo_1_1Surface.html#ad176eb7343b5902df3c19f9f56e59fb4">cobject</a>* <a class="el" href="classCairo_1_1Surface.html#a8c9aea28f0d1f6c2dcb507a2c7bb027c">Cairo::Surface::m_cobject</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The underlying C cairo surface type that is wrapped by this <a class="el" href="classCairo_1_1Surface.html" title="A cairo surface represents an image, either as the destination of a drawing operation or as source wh...">Surface</a>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cairomm/surface.h</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon May 9 2011 09:51:07 for cairomm by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
