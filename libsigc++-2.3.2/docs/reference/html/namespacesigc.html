<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>libsigc++: sigc Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libsigc++
   &#160;<span id="projectnumber">2.3.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sigc Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The libsigc++ namespace.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1adaptor__base.html">adaptor_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hint to the compiler.  <a href="structsigc_1_1adaptor__base.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1adaptor__functor.html">adaptor_functor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an arbitrary functor into an adaptor type.  <a href="structsigc_1_1adaptor__functor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1adaptor__trait.html">adaptor_trait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait that specifies what is the adaptor version of a functor type.  <a href="structsigc_1_1adaptor__trait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1adaptor__trait_3_01T__functor_00_01false_01_4.html">adaptor_trait&lt; T_functor, false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait that specifies what is the adaptor version of a functor type.  <a href="structsigc_1_1adaptor__trait_3_01T__functor_00_01false_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1adaptor__trait_3_01T__functor_00_01true_01_4.html">adaptor_trait&lt; T_functor, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait that specifies what is the adaptor version of a functor type.  <a href="structsigc_1_1adaptor__trait_3_01T__functor_00_01true_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1adapts.html">adapts</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type for adaptors.  <a href="structsigc_1_1adapts.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bind__functor.html">bind_functor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that binds an argument to the wrapped functor.  <a href="structsigc_1_1bind__functor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bind__functor_3_010_00_01T__functor_00_01T__bound_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">bind_functor&lt; 0, T_functor, T_bound, nil, nil, nil, nil, nil, nil &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that binds an argument to the wrapped functor.  <a href="structsigc_1_1bind__functor_3_010_00_01T__functor_00_01T__bound_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">bind_functor&lt;-1, T_functor, T_type1, nil, nil, nil, nil, nil, nil &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that binds 1 argument(s) to the wrapped functor.  <a href="structsigc_1_1bind__functor_3-1_00_01T__functor_00_01T__type1_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1bind__return__functor.html">bind_return_functor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that fixes the return value of the wrapped functor.  <a href="structsigc_1_1bind__return__functor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__argument.html">bound_argument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bound_argument&lt;Foo&gt; object stores a bound (for instance, with <a class="el" href="group__bind.html#ga2f099bc6056b32f2a58134ba8537c6f4" title="Creates an adaptor of type sigc::bind_functor which binds the passed argument to the passed functor...">sigc::bind()</a>, or <a class="el" href="group__bind.html#gaca1ae2466988d67d00a5f2cd16c8d90a" title="Creates an adaptor of type sigc::bind_return_functor which fixes the return value of the passed funct...">sigc::bind_return()</a>) argument.  <a href="classsigc_1_1bound__argument.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__argument_3_01const__reference__wrapper_3_01T__wrapped_01_4_01_4.html">bound_argument&lt; const_reference_wrapper&lt; T_wrapped &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__argument.html" title="A bound_argument&lt;Foo&gt; object stores a bound (for instance, with sigc::bind(), or sigc::bind_return())...">bound_argument</a> object for a bound argument that is passed by <a class="el" href="group__bind.html#ga2f099bc6056b32f2a58134ba8537c6f4" title="Creates an adaptor of type sigc::bind_functor which binds the passed argument to the passed functor...">bind()</a> or returned by <a class="el" href="group__bind.html#gaca1ae2466988d67d00a5f2cd16c8d90a" title="Creates an adaptor of type sigc::bind_return_functor which fixes the return value of the passed funct...">bind_return()</a> by const reference, specialized for const reference_wrapper&lt;&gt; types.  <a href="classsigc_1_1bound__argument_3_01const__reference__wrapper_3_01T__wrapped_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__argument_3_01reference__wrapper_3_01T__wrapped_01_4_01_4.html">bound_argument&lt; reference_wrapper&lt; T_wrapped &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__argument.html" title="A bound_argument&lt;Foo&gt; object stores a bound (for instance, with sigc::bind(), or sigc::bind_return())...">bound_argument</a> object for a bound argument that is passed by <a class="el" href="group__bind.html#ga2f099bc6056b32f2a58134ba8537c6f4" title="Creates an adaptor of type sigc::bind_functor which binds the passed argument to the passed functor...">bind()</a> or returned by <a class="el" href="group__bind.html#gaca1ae2466988d67d00a5f2cd16c8d90a" title="Creates an adaptor of type sigc::bind_return_functor which fixes the return value of the passed funct...">bind_return()</a> by reference, specialized for reference_wrapper&lt;&gt; types.  <a href="classsigc_1_1bound__argument_3_01reference__wrapper_3_01T__wrapped_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor0.html">bound_const_mem_functor0</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor0.html" title="bound_const_mem_functor0 encapsulates a const method with 0 arguments and an object instance...">bound_const_mem_functor0</a> encapsulates a const method with 0 arguments and an object instance.  <a href="classsigc_1_1bound__const__mem__functor0.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor1.html">bound_const_mem_functor1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor1.html" title="bound_const_mem_functor1 encapsulates a const method with 1 arguments and an object instance...">bound_const_mem_functor1</a> encapsulates a const method with 1 arguments and an object instance.  <a href="classsigc_1_1bound__const__mem__functor1.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor2.html">bound_const_mem_functor2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor2.html" title="bound_const_mem_functor2 encapsulates a const method with 2 arguments and an object instance...">bound_const_mem_functor2</a> encapsulates a const method with 2 arguments and an object instance.  <a href="classsigc_1_1bound__const__mem__functor2.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor3.html">bound_const_mem_functor3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor3.html" title="bound_const_mem_functor3 encapsulates a const method with 3 arguments and an object instance...">bound_const_mem_functor3</a> encapsulates a const method with 3 arguments and an object instance.  <a href="classsigc_1_1bound__const__mem__functor3.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor4.html">bound_const_mem_functor4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor4.html" title="bound_const_mem_functor4 encapsulates a const method with 4 arguments and an object instance...">bound_const_mem_functor4</a> encapsulates a const method with 4 arguments and an object instance.  <a href="classsigc_1_1bound__const__mem__functor4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor5.html">bound_const_mem_functor5</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor5.html" title="bound_const_mem_functor5 encapsulates a const method with 5 arguments and an object instance...">bound_const_mem_functor5</a> encapsulates a const method with 5 arguments and an object instance.  <a href="classsigc_1_1bound__const__mem__functor5.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor6.html">bound_const_mem_functor6</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor6.html" title="bound_const_mem_functor6 encapsulates a const method with 6 arguments and an object instance...">bound_const_mem_functor6</a> encapsulates a const method with 6 arguments and an object instance.  <a href="classsigc_1_1bound__const__mem__functor6.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__mem__functor7.html">bound_const_mem_functor7</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__mem__functor7.html" title="bound_const_mem_functor7 encapsulates a const method with 7 arguments and an object instance...">bound_const_mem_functor7</a> encapsulates a const method with 7 arguments and an object instance.  <a href="classsigc_1_1bound__const__mem__functor7.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">bound_const_volatile_mem_functor0</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html" title="bound_const_volatile_mem_functor0 encapsulates a const volatile method with 0 arguments and an object...">bound_const_volatile_mem_functor0</a> encapsulates a const volatile method with 0 arguments and an object instance.  <a href="classsigc_1_1bound__const__volatile__mem__functor0.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">bound_const_volatile_mem_functor1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html" title="bound_const_volatile_mem_functor1 encapsulates a const volatile method with 1 arguments and an object...">bound_const_volatile_mem_functor1</a> encapsulates a const volatile method with 1 arguments and an object instance.  <a href="classsigc_1_1bound__const__volatile__mem__functor1.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">bound_const_volatile_mem_functor2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html" title="bound_const_volatile_mem_functor2 encapsulates a const volatile method with 2 arguments and an object...">bound_const_volatile_mem_functor2</a> encapsulates a const volatile method with 2 arguments and an object instance.  <a href="classsigc_1_1bound__const__volatile__mem__functor2.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">bound_const_volatile_mem_functor3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html" title="bound_const_volatile_mem_functor3 encapsulates a const volatile method with 3 arguments and an object...">bound_const_volatile_mem_functor3</a> encapsulates a const volatile method with 3 arguments and an object instance.  <a href="classsigc_1_1bound__const__volatile__mem__functor3.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">bound_const_volatile_mem_functor4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html" title="bound_const_volatile_mem_functor4 encapsulates a const volatile method with 4 arguments and an object...">bound_const_volatile_mem_functor4</a> encapsulates a const volatile method with 4 arguments and an object instance.  <a href="classsigc_1_1bound__const__volatile__mem__functor4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">bound_const_volatile_mem_functor5</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html" title="bound_const_volatile_mem_functor5 encapsulates a const volatile method with 5 arguments and an object...">bound_const_volatile_mem_functor5</a> encapsulates a const volatile method with 5 arguments and an object instance.  <a href="classsigc_1_1bound__const__volatile__mem__functor5.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">bound_const_volatile_mem_functor6</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html" title="bound_const_volatile_mem_functor6 encapsulates a const volatile method with 6 arguments and an object...">bound_const_volatile_mem_functor6</a> encapsulates a const volatile method with 6 arguments and an object instance.  <a href="classsigc_1_1bound__const__volatile__mem__functor6.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">bound_const_volatile_mem_functor7</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html" title="bound_const_volatile_mem_functor7 encapsulates a const volatile method with 7 arguments and an object...">bound_const_volatile_mem_functor7</a> encapsulates a const volatile method with 7 arguments and an object instance.  <a href="classsigc_1_1bound__const__volatile__mem__functor7.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor0.html">bound_mem_functor0</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor0.html" title="bound_mem_functor0 encapsulates a method with 0 arguments and an object instance. ...">bound_mem_functor0</a> encapsulates a method with 0 arguments and an object instance.  <a href="classsigc_1_1bound__mem__functor0.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor1.html">bound_mem_functor1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor1.html" title="bound_mem_functor1 encapsulates a method with 1 arguments and an object instance. ...">bound_mem_functor1</a> encapsulates a method with 1 arguments and an object instance.  <a href="classsigc_1_1bound__mem__functor1.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor2.html">bound_mem_functor2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor2.html" title="bound_mem_functor2 encapsulates a method with 2 arguments and an object instance. ...">bound_mem_functor2</a> encapsulates a method with 2 arguments and an object instance.  <a href="classsigc_1_1bound__mem__functor2.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor3.html">bound_mem_functor3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor3.html" title="bound_mem_functor3 encapsulates a method with 3 arguments and an object instance. ...">bound_mem_functor3</a> encapsulates a method with 3 arguments and an object instance.  <a href="classsigc_1_1bound__mem__functor3.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor4.html">bound_mem_functor4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor4.html" title="bound_mem_functor4 encapsulates a method with 4 arguments and an object instance. ...">bound_mem_functor4</a> encapsulates a method with 4 arguments and an object instance.  <a href="classsigc_1_1bound__mem__functor4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor5.html">bound_mem_functor5</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor5.html" title="bound_mem_functor5 encapsulates a method with 5 arguments and an object instance. ...">bound_mem_functor5</a> encapsulates a method with 5 arguments and an object instance.  <a href="classsigc_1_1bound__mem__functor5.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor6.html">bound_mem_functor6</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor6.html" title="bound_mem_functor6 encapsulates a method with 6 arguments and an object instance. ...">bound_mem_functor6</a> encapsulates a method with 6 arguments and an object instance.  <a href="classsigc_1_1bound__mem__functor6.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__mem__functor7.html">bound_mem_functor7</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__mem__functor7.html" title="bound_mem_functor7 encapsulates a method with 7 arguments and an object instance. ...">bound_mem_functor7</a> encapsulates a method with 7 arguments and an object instance.  <a href="classsigc_1_1bound__mem__functor7.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html">bound_volatile_mem_functor0</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html" title="bound_volatile_mem_functor0 encapsulates a volatile method with 0 arguments and an object instance...">bound_volatile_mem_functor0</a> encapsulates a volatile method with 0 arguments and an object instance.  <a href="classsigc_1_1bound__volatile__mem__functor0.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html">bound_volatile_mem_functor1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html" title="bound_volatile_mem_functor1 encapsulates a volatile method with 1 arguments and an object instance...">bound_volatile_mem_functor1</a> encapsulates a volatile method with 1 arguments and an object instance.  <a href="classsigc_1_1bound__volatile__mem__functor1.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html">bound_volatile_mem_functor2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html" title="bound_volatile_mem_functor2 encapsulates a volatile method with 2 arguments and an object instance...">bound_volatile_mem_functor2</a> encapsulates a volatile method with 2 arguments and an object instance.  <a href="classsigc_1_1bound__volatile__mem__functor2.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html">bound_volatile_mem_functor3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html" title="bound_volatile_mem_functor3 encapsulates a volatile method with 3 arguments and an object instance...">bound_volatile_mem_functor3</a> encapsulates a volatile method with 3 arguments and an object instance.  <a href="classsigc_1_1bound__volatile__mem__functor3.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html">bound_volatile_mem_functor4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html" title="bound_volatile_mem_functor4 encapsulates a volatile method with 4 arguments and an object instance...">bound_volatile_mem_functor4</a> encapsulates a volatile method with 4 arguments and an object instance.  <a href="classsigc_1_1bound__volatile__mem__functor4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html">bound_volatile_mem_functor5</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html" title="bound_volatile_mem_functor5 encapsulates a volatile method with 5 arguments and an object instance...">bound_volatile_mem_functor5</a> encapsulates a volatile method with 5 arguments and an object instance.  <a href="classsigc_1_1bound__volatile__mem__functor5.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html">bound_volatile_mem_functor6</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html" title="bound_volatile_mem_functor6 encapsulates a volatile method with 6 arguments and an object instance...">bound_volatile_mem_functor6</a> encapsulates a volatile method with 6 arguments and an object instance.  <a href="classsigc_1_1bound__volatile__mem__functor6.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html">bound_volatile_mem_functor7</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html" title="bound_volatile_mem_functor7 encapsulates a volatile method with 7 arguments and an object instance...">bound_volatile_mem_functor7</a> encapsulates a volatile method with 7 arguments and an object instance.  <a href="classsigc_1_1bound__volatile__mem__functor7.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1compose1__functor.html">compose1_functor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that combines two functors.  <a href="structsigc_1_1compose1__functor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1compose2__functor.html">compose2_functor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that combines three functors.  <a href="structsigc_1_1compose2__functor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1connection.html">connection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convinience class for safe disconnection.  <a href="structsigc_1_1connection.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__limit__reference.html">const_limit_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const_limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;), but make sure that, if Foo inherits from <a class="el" href="structsigc_1_1trackable.html" title="Base class for objects with auto-disconnection. ">sigc::trackable</a>, then <a class="el" href="group__sigcfunctors.html#ga64cb7832acc1e58efb5ffe0b4f5e9404" title="This function performs a functor on each of the targets of a functor. ">visit_each&lt;&gt;()</a> will "limit" itself to the <a class="el" href="structsigc_1_1trackable.html" title="Base class for objects with auto-disconnection. ">sigc::trackable</a> reference instead of the derived reference.  <a href="classsigc_1_1const__limit__reference.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__limit__reference_3_01T__type_00_01true_01_4.html">const_limit_reference&lt; T_type, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__limit__reference.html" title="A const_limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;), but make sure that, if Foo inherits from sigc::trackable, then visit_each&lt;&gt;() will &quot;limit&quot; itself to the sigc::trackable reference instead of the derived reference. ">const_limit_reference</a> object for a class that derives from trackable.  <a href="classsigc_1_1const__limit__reference_3_01T__type_00_01true_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor0.html">const_mem_functor0</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor0.html" title="const_mem_functor0 wraps const methods with 0 argument(s). ">const_mem_functor0</a> wraps const methods with 0 argument(s).  <a href="classsigc_1_1const__mem__functor0.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor1.html">const_mem_functor1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor1.html" title="const_mem_functor1 wraps const methods with 1 argument(s). ">const_mem_functor1</a> wraps const methods with 1 argument(s).  <a href="classsigc_1_1const__mem__functor1.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor2.html">const_mem_functor2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor2.html" title="const_mem_functor2 wraps const methods with 2 argument(s). ">const_mem_functor2</a> wraps const methods with 2 argument(s).  <a href="classsigc_1_1const__mem__functor2.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor3.html">const_mem_functor3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor3.html" title="const_mem_functor3 wraps const methods with 3 argument(s). ">const_mem_functor3</a> wraps const methods with 3 argument(s).  <a href="classsigc_1_1const__mem__functor3.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor4.html">const_mem_functor4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor4.html" title="const_mem_functor4 wraps const methods with 4 argument(s). ">const_mem_functor4</a> wraps const methods with 4 argument(s).  <a href="classsigc_1_1const__mem__functor4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor5.html">const_mem_functor5</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor5.html" title="const_mem_functor5 wraps const methods with 5 argument(s). ">const_mem_functor5</a> wraps const methods with 5 argument(s).  <a href="classsigc_1_1const__mem__functor5.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor6.html">const_mem_functor6</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor6.html" title="const_mem_functor6 wraps const methods with 6 argument(s). ">const_mem_functor6</a> wraps const methods with 6 argument(s).  <a href="classsigc_1_1const__mem__functor6.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__mem__functor7.html">const_mem_functor7</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__mem__functor7.html" title="const_mem_functor7 wraps const methods with 7 argument(s). ">const_mem_functor7</a> wraps const methods with 7 argument(s).  <a href="classsigc_1_1const__mem__functor7.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1const__reference__wrapper.html">const_reference_wrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const reference wrapper.  <a href="structsigc_1_1const__reference__wrapper.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__limit__reference.html">const_volatile_limit_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const_volatile_limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;), but make sure that, if Foo inherits from <a class="el" href="structsigc_1_1trackable.html" title="Base class for objects with auto-disconnection. ">sigc::trackable</a>, then <a class="el" href="group__sigcfunctors.html#ga64cb7832acc1e58efb5ffe0b4f5e9404" title="This function performs a functor on each of the targets of a functor. ">visit_each&lt;&gt;()</a> will "limit" itself to the <a class="el" href="structsigc_1_1trackable.html" title="Base class for objects with auto-disconnection. ">sigc::trackable</a> reference instead of the derived reference.  <a href="classsigc_1_1const__volatile__limit__reference.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__limit__reference_3_01T__type_00_01true_01_4.html">const_volatile_limit_reference&lt; T_type, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__limit__reference.html" title="A const_volatile_limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;), but make sure that...">const_volatile_limit_reference</a> object for a class that derives from trackable.  <a href="classsigc_1_1const__volatile__limit__reference_3_01T__type_00_01true_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor0.html">const_volatile_mem_functor0</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor0.html" title="const_volatile_mem_functor0 wraps const volatile methods with 0 argument(s). ">const_volatile_mem_functor0</a> wraps const volatile methods with 0 argument(s).  <a href="classsigc_1_1const__volatile__mem__functor0.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor1.html">const_volatile_mem_functor1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor1.html" title="const_volatile_mem_functor1 wraps const volatile methods with 1 argument(s). ">const_volatile_mem_functor1</a> wraps const volatile methods with 1 argument(s).  <a href="classsigc_1_1const__volatile__mem__functor1.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor2.html">const_volatile_mem_functor2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor2.html" title="const_volatile_mem_functor2 wraps const volatile methods with 2 argument(s). ">const_volatile_mem_functor2</a> wraps const volatile methods with 2 argument(s).  <a href="classsigc_1_1const__volatile__mem__functor2.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor3.html">const_volatile_mem_functor3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor3.html" title="const_volatile_mem_functor3 wraps const volatile methods with 3 argument(s). ">const_volatile_mem_functor3</a> wraps const volatile methods with 3 argument(s).  <a href="classsigc_1_1const__volatile__mem__functor3.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor4.html">const_volatile_mem_functor4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor4.html" title="const_volatile_mem_functor4 wraps const volatile methods with 4 argument(s). ">const_volatile_mem_functor4</a> wraps const volatile methods with 4 argument(s).  <a href="classsigc_1_1const__volatile__mem__functor4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor5.html">const_volatile_mem_functor5</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor5.html" title="const_volatile_mem_functor5 wraps const volatile methods with 5 argument(s). ">const_volatile_mem_functor5</a> wraps const volatile methods with 5 argument(s).  <a href="classsigc_1_1const__volatile__mem__functor5.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor6.html">const_volatile_mem_functor6</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor6.html" title="const_volatile_mem_functor6 wraps const volatile methods with 6 argument(s). ">const_volatile_mem_functor6</a> wraps const volatile methods with 6 argument(s).  <a href="classsigc_1_1const__volatile__mem__functor6.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1const__volatile__mem__functor7.html">const_volatile_mem_functor7</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1const__volatile__mem__functor7.html" title="const_volatile_mem_functor7 wraps const volatile methods with 7 argument(s). ">const_volatile_mem_functor7</a> wraps const volatile methods with 7 argument(s).  <a href="classsigc_1_1const__volatile__mem__functor7.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1deduce__result__type.html">deduce_result_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce the return type of a functor.  <a href="structsigc_1_1deduce__result__type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1exception__catch__functor.html">exception_catch_functor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1exception__catch__functor_3_01T__functor_00_01T__catcher_00_01void_01_4.html">exception_catch_functor&lt; T_functor, T_catcher, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1functor__base.html">functor_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hint to the compiler.  <a href="structsigc_1_1functor__base.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1functor__trait.html">functor_trait</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait that specifies the return type of any type.  <a href="structsigc_1_1functor__trait.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1hide__functor.html">hide_functor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that adds a dummy parameter to the wrapped functor.  <a href="structsigc_1_1hide__functor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1hide__functor_3_010_00_01T__functor_01_4.html">hide_functor&lt; 0, T_functor &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that adds a dummy parameter to the wrapped functor.  <a href="structsigc_1_1hide__functor_3_010_00_01T__functor_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1hide__functor_3-1_00_01T__functor_01_4.html">hide_functor&lt;-1, T_functor &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that adds a dummy parameter to the wrapped functor.  <a href="structsigc_1_1hide__functor_3-1_00_01T__functor_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1is__base__and__derived.html">is_base_and_derived</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time determination of base-class relationship in C++ (adapted to match the syntax of boost's type_traits library).  <a href="structsigc_1_1is__base__and__derived.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1is__base__and__derived_3_01T__base_00_01T__base_01_4.html">is_base_and_derived&lt; T_base, T_base &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda.html">lambda</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lambda type.  <a href="structsigc_1_1lambda.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__base.html">lambda_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hint to the compiler.  <a href="structsigc_1_1lambda__base.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__group1.html">lambda_group1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structsigc_1_1lambda__group1.html" title="lambda_group1 wraps a functor and rebuilds its arguments from 1 lambda expressions. ">lambda_group1</a> wraps a functor and rebuilds its arguments from 1 lambda expressions.  <a href="structsigc_1_1lambda__group1.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__group2.html">lambda_group2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structsigc_1_1lambda__group2.html" title="lambda_group2 wraps a functor and rebuilds its arguments from 2 lambda expressions. ">lambda_group2</a> wraps a functor and rebuilds its arguments from 2 lambda expressions.  <a href="structsigc_1_1lambda__group2.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1lambda__group3.html">lambda_group3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structsigc_1_1lambda__group3.html" title="lambda_group3 wraps a functor and rebuilds its arguments from 3 lambda expressions. ">lambda_group3</a> wraps a functor and rebuilds its arguments from 3 lambda expressions.  <a href="structsigc_1_1lambda__group3.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1limit__reference.html">limit_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;), but make sure that, if Foo inherits from <a class="el" href="structsigc_1_1trackable.html" title="Base class for objects with auto-disconnection. ">sigc::trackable</a>, then <a class="el" href="group__sigcfunctors.html#ga64cb7832acc1e58efb5ffe0b4f5e9404" title="This function performs a functor on each of the targets of a functor. ">visit_each&lt;&gt;()</a> will "limit" itself to the <a class="el" href="structsigc_1_1trackable.html" title="Base class for objects with auto-disconnection. ">sigc::trackable</a> reference instead of the derived reference.  <a href="classsigc_1_1limit__reference.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1limit__reference_3_01T__type_00_01true_01_4.html">limit_reference&lt; T_type, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1limit__reference.html" title="A limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;), but make sure that, if Foo inherits from sig...">limit_reference</a> object for a class that derives from trackable.  <a href="classsigc_1_1limit__reference_3_01T__type_00_01true_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor0.html">mem_functor0</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor0.html" title="mem_functor0 wraps methods with 0 argument(s). ">mem_functor0</a> wraps methods with 0 argument(s).  <a href="classsigc_1_1mem__functor0.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor1.html">mem_functor1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor1.html" title="mem_functor1 wraps methods with 1 argument(s). ">mem_functor1</a> wraps methods with 1 argument(s).  <a href="classsigc_1_1mem__functor1.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor2.html">mem_functor2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor2.html" title="mem_functor2 wraps methods with 2 argument(s). ">mem_functor2</a> wraps methods with 2 argument(s).  <a href="classsigc_1_1mem__functor2.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor3.html">mem_functor3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor3.html" title="mem_functor3 wraps methods with 3 argument(s). ">mem_functor3</a> wraps methods with 3 argument(s).  <a href="classsigc_1_1mem__functor3.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor4.html">mem_functor4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor4.html" title="mem_functor4 wraps methods with 4 argument(s). ">mem_functor4</a> wraps methods with 4 argument(s).  <a href="classsigc_1_1mem__functor4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor5.html">mem_functor5</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor5.html" title="mem_functor5 wraps methods with 5 argument(s). ">mem_functor5</a> wraps methods with 5 argument(s).  <a href="classsigc_1_1mem__functor5.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor6.html">mem_functor6</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor6.html" title="mem_functor6 wraps methods with 6 argument(s). ">mem_functor6</a> wraps methods with 6 argument(s).  <a href="classsigc_1_1mem__functor6.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1mem__functor7.html">mem_functor7</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1mem__functor7.html" title="mem_functor7 wraps methods with 7 argument(s). ">mem_functor7</a> wraps methods with 7 argument(s).  <a href="classsigc_1_1mem__functor7.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1nil.html">nil</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">nil struct type.  <a href="structsigc_1_1nil.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1pointer__functor0.html">pointer_functor0</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1pointer__functor0.html" title="pointer_functor0 wraps existing non-member functions with 0 argument(s). ">pointer_functor0</a> wraps existing non-member functions with 0 argument(s).  <a href="classsigc_1_1pointer__functor0.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1pointer__functor1.html">pointer_functor1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1pointer__functor1.html" title="pointer_functor1 wraps existing non-member functions with 1 argument(s). ">pointer_functor1</a> wraps existing non-member functions with 1 argument(s).  <a href="classsigc_1_1pointer__functor1.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1pointer__functor2.html">pointer_functor2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1pointer__functor2.html" title="pointer_functor2 wraps existing non-member functions with 2 argument(s). ">pointer_functor2</a> wraps existing non-member functions with 2 argument(s).  <a href="classsigc_1_1pointer__functor2.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1pointer__functor3.html">pointer_functor3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1pointer__functor3.html" title="pointer_functor3 wraps existing non-member functions with 3 argument(s). ">pointer_functor3</a> wraps existing non-member functions with 3 argument(s).  <a href="classsigc_1_1pointer__functor3.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1pointer__functor4.html">pointer_functor4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1pointer__functor4.html" title="pointer_functor4 wraps existing non-member functions with 4 argument(s). ">pointer_functor4</a> wraps existing non-member functions with 4 argument(s).  <a href="classsigc_1_1pointer__functor4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1pointer__functor5.html">pointer_functor5</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1pointer__functor5.html" title="pointer_functor5 wraps existing non-member functions with 5 argument(s). ">pointer_functor5</a> wraps existing non-member functions with 5 argument(s).  <a href="classsigc_1_1pointer__functor5.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1pointer__functor6.html">pointer_functor6</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1pointer__functor6.html" title="pointer_functor6 wraps existing non-member functions with 6 argument(s). ">pointer_functor6</a> wraps existing non-member functions with 6 argument(s).  <a href="classsigc_1_1pointer__functor6.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1pointer__functor7.html">pointer_functor7</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1pointer__functor7.html" title="pointer_functor7 wraps existing non-member functions with 7 argument(s). ">pointer_functor7</a> wraps existing non-member functions with 7 argument(s).  <a href="classsigc_1_1pointer__functor7.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1reference__wrapper.html">reference_wrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference wrapper.  <a href="structsigc_1_1reference__wrapper.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that performs C-style casts on the parameters passed on to the functor.  <a href="structsigc_1_1retype__functor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1retype__return__functor.html">retype_return_functor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that performs a C-style cast on the return value of a functor.  <a href="structsigc_1_1retype__return__functor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1retype__return__functor_3_01void_00_01T__functor_01_4.html">retype_return_functor&lt; void, T_functor &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that performs a C-style cast on the return value of a functor.  <a href="structsigc_1_1retype__return__functor_3_01void_00_01T__functor_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal.html">signal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1signal.html" title="Convenience wrapper for the numbered sigc::signal# templates. ">sigc::signal</a># templates.  <a href="classsigc_1_1signal.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal0.html">signal0</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal declaration.  <a href="classsigc_1_1signal0.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal1.html">signal1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal declaration.  <a href="classsigc_1_1signal1.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal2.html">signal2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal declaration.  <a href="classsigc_1_1signal2.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal3.html">signal3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal declaration.  <a href="classsigc_1_1signal3.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal4.html">signal4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal declaration.  <a href="classsigc_1_1signal4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal5.html">signal5</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal declaration.  <a href="classsigc_1_1signal5.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal6.html">signal6</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal declaration.  <a href="classsigc_1_1signal6.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal7.html">signal7</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal declaration.  <a href="classsigc_1_1signal7.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal_3_01T__return_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">signal&lt; T_return, nil, nil, nil, nil, nil, nil, nil &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1signal0.html" title="Signal declaration. ">sigc::signal0</a> template.  <a href="classsigc_1_1signal_3_01T__return_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">signal&lt; T_return, T_arg1, nil, nil, nil, nil, nil, nil &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1signal1.html" title="Signal declaration. ">sigc::signal1</a> template.  <a href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">signal&lt; T_return, T_arg1, T_arg2, nil, nil, nil, nil, nil &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1signal2.html" title="Signal declaration. ">sigc::signal2</a> template.  <a href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">signal&lt; T_return, T_arg1, T_arg2, T_arg3, nil, nil, nil, nil &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1signal3.html" title="Signal declaration. ">sigc::signal3</a> template.  <a href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01nil_00_01nil_00_01nil_01_4.html">signal&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, nil, nil, nil &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1signal4.html" title="Signal declaration. ">sigc::signal4</a> template.  <a href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01nil_00_01nil_00_01nil_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_00_01nil_00_01nil_01_4.html">signal&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, nil, nil &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1signal5.html" title="Signal declaration. ">sigc::signal5</a> template.  <a href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_00_01nil_00_01nil_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_00_01T__arg6_00_01nil_01_4.html">signal&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, nil &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1signal6.html" title="Signal declaration. ">sigc::signal6</a> template.  <a href="classsigc_1_1signal_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_00_01T__arg6_00_01nil_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1signal__base.html">signal_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for the <a class="el" href="classsigc_1_1signal.html" title="Convenience wrapper for the numbered sigc::signal# templates. ">sigc::signal</a># templates.  <a href="structsigc_1_1signal__base.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot.html">slot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1slot.html" title="Convenience wrapper for the numbered sigc::slot# templates. ">sigc::slot</a># templates.  <a href="classsigc_1_1slot.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot0.html">slot0</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque.  <a href="classsigc_1_1slot0.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot1.html">slot1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque.  <a href="classsigc_1_1slot1.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot2.html">slot2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque.  <a href="classsigc_1_1slot2.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot3.html">slot3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque.  <a href="classsigc_1_1slot3.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot4.html">slot4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque.  <a href="classsigc_1_1slot4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot5.html">slot5</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque.  <a href="classsigc_1_1slot5.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot6.html">slot6</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque.  <a href="classsigc_1_1slot6.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot7.html">slot7</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an arbitrary functor to a unified type which is opaque.  <a href="classsigc_1_1slot7.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot_3_01T__return_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">slot&lt; T_return, nil, nil, nil, nil, nil, nil, nil &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1slot0.html" title="Converts an arbitrary functor to a unified type which is opaque. ">sigc::slot0</a> template.  <a href="classsigc_1_1slot_3_01T__return_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">slot&lt; T_return, T_arg1, nil, nil, nil, nil, nil, nil &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1slot1.html" title="Converts an arbitrary functor to a unified type which is opaque. ">sigc::slot1</a> template.  <a href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">slot&lt; T_return, T_arg1, T_arg2, nil, nil, nil, nil, nil &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1slot2.html" title="Converts an arbitrary functor to a unified type which is opaque. ">sigc::slot2</a> template.  <a href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_00_01nil_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html">slot&lt; T_return, T_arg1, T_arg2, T_arg3, nil, nil, nil, nil &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1slot3.html" title="Converts an arbitrary functor to a unified type which is opaque. ">sigc::slot3</a> template.  <a href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01nil_00_01nil_00_01nil_00_01nil_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01nil_00_01nil_00_01nil_01_4.html">slot&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, nil, nil, nil &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1slot4.html" title="Converts an arbitrary functor to a unified type which is opaque. ">sigc::slot4</a> template.  <a href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01nil_00_01nil_00_01nil_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_00_01nil_00_01nil_01_4.html">slot&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, nil, nil &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1slot5.html" title="Converts an arbitrary functor to a unified type which is opaque. ">sigc::slot5</a> template.  <a href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_00_01nil_00_01nil_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_00_01T__arg6_00_01nil_01_4.html">slot&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, nil &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for the numbered <a class="el" href="classsigc_1_1slot6.html" title="Converts an arbitrary functor to a unified type which is opaque. ">sigc::slot6</a> template.  <a href="classsigc_1_1slot_3_01T__return_00_01T__arg1_00_01T__arg2_00_01T__arg3_00_01T__arg4_00_01T__arg5_00_01T__arg6_00_01nil_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1slot__base.html">slot_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type for slots.  <a href="classsigc_1_1slot__base.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1slot__const__iterator.html">slot_const_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-style const iterator for <a class="el" href="structsigc_1_1slot__list.html" title="STL-style list interface for sigc::signal#. ">slot_list</a>.  <a href="structsigc_1_1slot__const__iterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1slot__iterator.html">slot_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-style iterator for <a class="el" href="structsigc_1_1slot__list.html" title="STL-style list interface for sigc::signal#. ">slot_list</a>.  <a href="structsigc_1_1slot__iterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1slot__list.html">slot_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-style list interface for <a class="el" href="classsigc_1_1signal.html" title="Convenience wrapper for the numbered sigc::signal# templates. ">sigc::signal</a>#.  <a href="structsigc_1_1slot__list.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1track__obj__functor1.html">track_obj_functor1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1track__obj__functor1.html" title="track_obj_functor1 wraps a functor and stores a reference to a trackable object. ">track_obj_functor1</a> wraps a functor and stores a reference to a trackable object.  <a href="classsigc_1_1track__obj__functor1.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1track__obj__functor2.html">track_obj_functor2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1track__obj__functor2.html" title="track_obj_functor2 wraps a functor and stores 2 references to trackable objects. ">track_obj_functor2</a> wraps a functor and stores 2 references to trackable objects.  <a href="classsigc_1_1track__obj__functor2.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1track__obj__functor3.html">track_obj_functor3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1track__obj__functor3.html" title="track_obj_functor3 wraps a functor and stores 3 references to trackable objects. ">track_obj_functor3</a> wraps a functor and stores 3 references to trackable objects.  <a href="classsigc_1_1track__obj__functor3.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1track__obj__functor4.html">track_obj_functor4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1track__obj__functor4.html" title="track_obj_functor4 wraps a functor and stores 4 references to trackable objects. ">track_obj_functor4</a> wraps a functor and stores 4 references to trackable objects.  <a href="classsigc_1_1track__obj__functor4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1track__obj__functor5.html">track_obj_functor5</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1track__obj__functor5.html" title="track_obj_functor5 wraps a functor and stores 5 references to trackable objects. ">track_obj_functor5</a> wraps a functor and stores 5 references to trackable objects.  <a href="classsigc_1_1track__obj__functor5.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1track__obj__functor6.html">track_obj_functor6</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1track__obj__functor6.html" title="track_obj_functor6 wraps a functor and stores 6 references to trackable objects. ">track_obj_functor6</a> wraps a functor and stores 6 references to trackable objects.  <a href="classsigc_1_1track__obj__functor6.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1track__obj__functor7.html">track_obj_functor7</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1track__obj__functor7.html" title="track_obj_functor7 wraps a functor and stores 7 references to trackable objects. ">track_obj_functor7</a> wraps a functor and stores 7 references to trackable objects.  <a href="classsigc_1_1track__obj__functor7.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1trackable.html">trackable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for objects with auto-disconnection.  <a href="structsigc_1_1trackable.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1type__trait.html">type_trait</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1type__trait_3_01const_01T__type_01_6_01_4.html">type_trait&lt; const T_type&amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1type__trait_3_01T__type_01_6_01_4.html">type_trait&lt; T_type&amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1type__trait_3_01T__type[N]_4.html">type_trait&lt; T_type[N]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1type__trait_3_01void_01_4.html">type_trait&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1unwrap__lambda__type.html">unwrap_lambda_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduces the type of the object stored in an object of the passed lambda type.  <a href="structsigc_1_1unwrap__lambda__type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1unwrap__lambda__type_3_01lambda_3_01T__type_01_4_01_4.html">unwrap_lambda_type&lt; lambda&lt; T_type &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduces the type of the object stored in an object of the passed lambda type.  <a href="structsigc_1_1unwrap__lambda__type_3_01lambda_3_01T__type_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1unwrap__reference_3_01const__reference__wrapper_3_01T__type_01_4_01_4.html">unwrap_reference&lt; const_reference_wrapper&lt; T_type &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1unwrap__reference_3_01reference__wrapper_3_01T__type_01_4_01_4.html">unwrap_reference&lt; reference_wrapper&lt; T_type &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsigc_1_1visitor.html">visitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structsigc_1_1visitor.html#a9fe5d6be845e622a99a0db5d3621d4b3">sigc::visitor&lt;T_functor&gt;::do_visit_each()</a> performs a functor on each of the targets of a functor.  <a href="structsigc_1_1visitor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__limit__reference.html">volatile_limit_reference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A volatile_limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;), but make sure that, if Foo inherits from <a class="el" href="structsigc_1_1trackable.html" title="Base class for objects with auto-disconnection. ">sigc::trackable</a>, then <a class="el" href="group__sigcfunctors.html#ga64cb7832acc1e58efb5ffe0b4f5e9404" title="This function performs a functor on each of the targets of a functor. ">visit_each&lt;&gt;()</a> will "limit" itself to the <a class="el" href="structsigc_1_1trackable.html" title="Base class for objects with auto-disconnection. ">sigc::trackable</a> reference instead of the derived reference.  <a href="classsigc_1_1volatile__limit__reference.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__limit__reference_3_01T__type_00_01true_01_4.html">volatile_limit_reference&lt; T_type, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__limit__reference.html" title="A volatile_limit_reference&lt;Foo&gt; object stores a reference (Foo&amp;), but make sure that, if Foo inherits from sigc::trackable, then visit_each&lt;&gt;() will &quot;limit&quot; itself to the sigc::trackable reference instead of the derived reference. ">volatile_limit_reference</a> object for a class that derives from trackable.  <a href="classsigc_1_1volatile__limit__reference_3_01T__type_00_01true_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor0.html">volatile_mem_functor0</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor0.html" title="volatile_mem_functor0 wraps volatile methods with 0 argument(s). ">volatile_mem_functor0</a> wraps volatile methods with 0 argument(s).  <a href="classsigc_1_1volatile__mem__functor0.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor1.html">volatile_mem_functor1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor1.html" title="volatile_mem_functor1 wraps volatile methods with 1 argument(s). ">volatile_mem_functor1</a> wraps volatile methods with 1 argument(s).  <a href="classsigc_1_1volatile__mem__functor1.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor2.html">volatile_mem_functor2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor2.html" title="volatile_mem_functor2 wraps volatile methods with 2 argument(s). ">volatile_mem_functor2</a> wraps volatile methods with 2 argument(s).  <a href="classsigc_1_1volatile__mem__functor2.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor3.html">volatile_mem_functor3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor3.html" title="volatile_mem_functor3 wraps volatile methods with 3 argument(s). ">volatile_mem_functor3</a> wraps volatile methods with 3 argument(s).  <a href="classsigc_1_1volatile__mem__functor3.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor4.html">volatile_mem_functor4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor4.html" title="volatile_mem_functor4 wraps volatile methods with 4 argument(s). ">volatile_mem_functor4</a> wraps volatile methods with 4 argument(s).  <a href="classsigc_1_1volatile__mem__functor4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor5.html">volatile_mem_functor5</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor5.html" title="volatile_mem_functor5 wraps volatile methods with 5 argument(s). ">volatile_mem_functor5</a> wraps volatile methods with 5 argument(s).  <a href="classsigc_1_1volatile__mem__functor5.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor6.html">volatile_mem_functor6</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor6.html" title="volatile_mem_functor6 wraps volatile methods with 6 argument(s). ">volatile_mem_functor6</a> wraps volatile methods with 6 argument(s).  <a href="classsigc_1_1volatile__mem__functor6.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsigc_1_1volatile__mem__functor7.html">volatile_mem_functor7</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsigc_1_1volatile__mem__functor7.html" title="volatile_mem_functor7 wraps volatile methods with 7 argument(s). ">volatile_mem_functor7</a> wraps volatile methods with 7 argument(s).  <a href="classsigc_1_1volatile__mem__functor7.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga2f099bc6056b32f2a58134ba8537c6f4"><td class="memTemplParams" colspan="2">template&lt;int I_location, class T_bound1 , class T_functor &gt; </td></tr>
<tr class="memitem:ga2f099bc6056b32f2a58134ba8537c6f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1bind__functor.html">bind_functor</a>&lt; I_location, <br class="typebreak"/>
T_functor, T_bound1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#ga2f099bc6056b32f2a58134ba8537c6f4">bind</a> (const T_functor&amp; _A_func, T_bound1 _A_b1)</td></tr>
<tr class="memdesc:ga2f099bc6056b32f2a58134ba8537c6f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1bind__functor.html" title="Adaptor that binds an argument to the wrapped functor. ">sigc::bind_functor</a> which binds the passed argument to the passed functor.  <a href="group__bind.html#ga2f099bc6056b32f2a58134ba8537c6f4">More...</a><br/></td></tr>
<tr class="separator:ga2f099bc6056b32f2a58134ba8537c6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga211b3361bb1ae7484b2b276fd926b962"><td class="memTemplParams" colspan="2">template&lt;class T_type1 , class T_functor &gt; </td></tr>
<tr class="memitem:ga211b3361bb1ae7484b2b276fd926b962"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1bind__functor.html">bind_functor</a>&lt;-1, T_functor, <br class="typebreak"/>
T_type1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#ga211b3361bb1ae7484b2b276fd926b962">bind</a> (const T_functor&amp; _A_func, T_type1 _A_b1)</td></tr>
<tr class="memdesc:ga211b3361bb1ae7484b2b276fd926b962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1bind__functor.html" title="Adaptor that binds an argument to the wrapped functor. ">sigc::bind_functor</a> which fixes the last 1 argument(s) of the passed functor.  <a href="group__bind.html#ga211b3361bb1ae7484b2b276fd926b962">More...</a><br/></td></tr>
<tr class="separator:ga211b3361bb1ae7484b2b276fd926b962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1e076f0734addb8080f1cbcac602591"><td class="memTemplParams" colspan="2">template&lt;class T_type1 , class T_type2 , class T_functor &gt; </td></tr>
<tr class="memitem:gaf1e076f0734addb8080f1cbcac602591"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1bind__functor.html">bind_functor</a>&lt;-1, T_functor, <br class="typebreak"/>
T_type1, T_type2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#gaf1e076f0734addb8080f1cbcac602591">bind</a> (const T_functor&amp; _A_func, T_type1 _A_b1, T_type2 _A_b2)</td></tr>
<tr class="memdesc:gaf1e076f0734addb8080f1cbcac602591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1bind__functor.html" title="Adaptor that binds an argument to the wrapped functor. ">sigc::bind_functor</a> which fixes the last 2 argument(s) of the passed functor.  <a href="group__bind.html#gaf1e076f0734addb8080f1cbcac602591">More...</a><br/></td></tr>
<tr class="separator:gaf1e076f0734addb8080f1cbcac602591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga047061c9fa7d9dcde68c27cceed476a1"><td class="memTemplParams" colspan="2">template&lt;class T_type1 , class T_type2 , class T_type3 , class T_functor &gt; </td></tr>
<tr class="memitem:ga047061c9fa7d9dcde68c27cceed476a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1bind__functor.html">bind_functor</a>&lt;-1, T_functor, <br class="typebreak"/>
T_type1, T_type2, T_type3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#ga047061c9fa7d9dcde68c27cceed476a1">bind</a> (const T_functor&amp; _A_func, T_type1 _A_b1, T_type2 _A_b2, T_type3 _A_b3)</td></tr>
<tr class="memdesc:ga047061c9fa7d9dcde68c27cceed476a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1bind__functor.html" title="Adaptor that binds an argument to the wrapped functor. ">sigc::bind_functor</a> which fixes the last 3 argument(s) of the passed functor.  <a href="group__bind.html#ga047061c9fa7d9dcde68c27cceed476a1">More...</a><br/></td></tr>
<tr class="separator:ga047061c9fa7d9dcde68c27cceed476a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8366abceb86ee653ec2ac50cef9fd16d"><td class="memTemplParams" colspan="2">template&lt;class T_type1 , class T_type2 , class T_type3 , class T_type4 , class T_functor &gt; </td></tr>
<tr class="memitem:ga8366abceb86ee653ec2ac50cef9fd16d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1bind__functor.html">bind_functor</a>&lt;-1, T_functor, <br class="typebreak"/>
T_type1, T_type2, T_type3, <br class="typebreak"/>
T_type4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#ga8366abceb86ee653ec2ac50cef9fd16d">bind</a> (const T_functor&amp; _A_func, T_type1 _A_b1, T_type2 _A_b2, T_type3 _A_b3, T_type4 _A_b4)</td></tr>
<tr class="memdesc:ga8366abceb86ee653ec2ac50cef9fd16d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1bind__functor.html" title="Adaptor that binds an argument to the wrapped functor. ">sigc::bind_functor</a> which fixes the last 4 argument(s) of the passed functor.  <a href="group__bind.html#ga8366abceb86ee653ec2ac50cef9fd16d">More...</a><br/></td></tr>
<tr class="separator:ga8366abceb86ee653ec2ac50cef9fd16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f163c830d7906906cf21ff0c5e0f17f"><td class="memTemplParams" colspan="2">template&lt;class T_type1 , class T_type2 , class T_type3 , class T_type4 , class T_type5 , class T_functor &gt; </td></tr>
<tr class="memitem:ga7f163c830d7906906cf21ff0c5e0f17f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1bind__functor.html">bind_functor</a>&lt;-1, T_functor, <br class="typebreak"/>
T_type1, T_type2, T_type3, <br class="typebreak"/>
T_type4, T_type5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#ga7f163c830d7906906cf21ff0c5e0f17f">bind</a> (const T_functor&amp; _A_func, T_type1 _A_b1, T_type2 _A_b2, T_type3 _A_b3, T_type4 _A_b4, T_type5 _A_b5)</td></tr>
<tr class="memdesc:ga7f163c830d7906906cf21ff0c5e0f17f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1bind__functor.html" title="Adaptor that binds an argument to the wrapped functor. ">sigc::bind_functor</a> which fixes the last 5 argument(s) of the passed functor.  <a href="group__bind.html#ga7f163c830d7906906cf21ff0c5e0f17f">More...</a><br/></td></tr>
<tr class="separator:ga7f163c830d7906906cf21ff0c5e0f17f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac370f58b773f68c229c181f07e9b9e79"><td class="memTemplParams" colspan="2">template&lt;class T_type1 , class T_type2 , class T_type3 , class T_type4 , class T_type5 , class T_type6 , class T_functor &gt; </td></tr>
<tr class="memitem:gac370f58b773f68c229c181f07e9b9e79"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1bind__functor.html">bind_functor</a>&lt;-1, T_functor, <br class="typebreak"/>
T_type1, T_type2, T_type3, <br class="typebreak"/>
T_type4, T_type5, T_type6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#gac370f58b773f68c229c181f07e9b9e79">bind</a> (const T_functor&amp; _A_func, T_type1 _A_b1, T_type2 _A_b2, T_type3 _A_b3, T_type4 _A_b4, T_type5 _A_b5, T_type6 _A_b6)</td></tr>
<tr class="memdesc:gac370f58b773f68c229c181f07e9b9e79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1bind__functor.html" title="Adaptor that binds an argument to the wrapped functor. ">sigc::bind_functor</a> which fixes the last 6 argument(s) of the passed functor.  <a href="group__bind.html#gac370f58b773f68c229c181f07e9b9e79">More...</a><br/></td></tr>
<tr class="separator:gac370f58b773f68c229c181f07e9b9e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga962b581ef0c17562bb3317783d3ffe7d"><td class="memTemplParams" colspan="2">template&lt;class T_type1 , class T_type2 , class T_type3 , class T_type4 , class T_type5 , class T_type6 , class T_type7 , class T_functor &gt; </td></tr>
<tr class="memitem:ga962b581ef0c17562bb3317783d3ffe7d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1bind__functor.html">bind_functor</a>&lt;-1, T_functor, <br class="typebreak"/>
T_type1, T_type2, T_type3, <br class="typebreak"/>
T_type4, T_type5, T_type6, <br class="typebreak"/>
T_type7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#ga962b581ef0c17562bb3317783d3ffe7d">bind</a> (const T_functor&amp; _A_func, T_type1 _A_b1, T_type2 _A_b2, T_type3 _A_b3, T_type4 _A_b4, T_type5 _A_b5, T_type6 _A_b6, T_type7 _A_b7)</td></tr>
<tr class="memdesc:ga962b581ef0c17562bb3317783d3ffe7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1bind__functor.html" title="Adaptor that binds an argument to the wrapped functor. ">sigc::bind_functor</a> which fixes the last 7 argument(s) of the passed functor.  <a href="group__bind.html#ga962b581ef0c17562bb3317783d3ffe7d">More...</a><br/></td></tr>
<tr class="separator:ga962b581ef0c17562bb3317783d3ffe7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca1ae2466988d67d00a5f2cd16c8d90a"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_functor &gt; </td></tr>
<tr class="memitem:gaca1ae2466988d67d00a5f2cd16c8d90a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1bind__return__functor.html">bind_return_functor</a>&lt; T_return, <br class="typebreak"/>
T_functor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bind.html#gaca1ae2466988d67d00a5f2cd16c8d90a">bind_return</a> (const T_functor&amp; _A_functor, T_return _A_ret_value)</td></tr>
<tr class="memdesc:gaca1ae2466988d67d00a5f2cd16c8d90a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1bind__return__functor.html" title="Adaptor that fixes the return value of the wrapped functor. ">sigc::bind_return_functor</a> which fixes the return value of the passed functor to the passed argument.  <a href="group__bind.html#gaca1ae2466988d67d00a5f2cd16c8d90a">More...</a><br/></td></tr>
<tr class="separator:gaca1ae2466988d67d00a5f2cd16c8d90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34cf5da8f6323bfdc41bc7113d6ad20a"><td class="memTemplParams" colspan="2">template&lt;class T_setter , class T_getter &gt; </td></tr>
<tr class="memitem:ga34cf5da8f6323bfdc41bc7113d6ad20a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1compose1__functor.html">compose1_functor</a>&lt; T_setter, <br class="typebreak"/>
T_getter &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compose.html#ga34cf5da8f6323bfdc41bc7113d6ad20a">compose</a> (const T_setter&amp; _A_setter, const T_getter&amp; _A_getter)</td></tr>
<tr class="memdesc:ga34cf5da8f6323bfdc41bc7113d6ad20a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1compose1__functor.html" title="Adaptor that combines two functors. ">sigc::compose1_functor</a> which combines two functors.  <a href="group__compose.html#ga34cf5da8f6323bfdc41bc7113d6ad20a">More...</a><br/></td></tr>
<tr class="separator:ga34cf5da8f6323bfdc41bc7113d6ad20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4abf2a45eb2307a3dc5d870c86b0450d"><td class="memTemplParams" colspan="2">template&lt;class T_setter , class T_getter1 , class T_getter2 &gt; </td></tr>
<tr class="memitem:ga4abf2a45eb2307a3dc5d870c86b0450d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1compose2__functor.html">compose2_functor</a>&lt; T_setter, <br class="typebreak"/>
T_getter1, T_getter2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__compose.html#ga4abf2a45eb2307a3dc5d870c86b0450d">compose</a> (const T_setter&amp; _A_setter, const T_getter1&amp; _A_getter1, const T_getter2&amp; _A_getter2)</td></tr>
<tr class="memdesc:ga4abf2a45eb2307a3dc5d870c86b0450d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1compose2__functor.html" title="Adaptor that combines three functors. ">sigc::compose2_functor</a> which combines three functors.  <a href="group__compose.html#ga4abf2a45eb2307a3dc5d870c86b0450d">More...</a><br/></td></tr>
<tr class="separator:ga4abf2a45eb2307a3dc5d870c86b0450d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae3b8a1ba26920cee4d7d9df2c39ed9"><td class="memTemplParams" colspan="2">template&lt;class T_functor , class T_catcher &gt; </td></tr>
<tr class="memitem:a0ae3b8a1ba26920cee4d7d9df2c39ed9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1exception__catch__functor.html">exception_catch_functor</a><br class="typebreak"/>
&lt; T_functor, T_catcher &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#a0ae3b8a1ba26920cee4d7d9df2c39ed9">exception_catch</a> (const T_functor&amp; _A_func, const T_catcher&amp; _A_catcher)</td></tr>
<tr class="separator:a0ae3b8a1ba26920cee4d7d9df2c39ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56a5905d189af5fab33d8c456f097a29"><td class="memTemplParams" colspan="2">template&lt;class T_functor , class T_type1 &gt; </td></tr>
<tr class="memitem:ga56a5905d189af5fab33d8c456f097a29"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__group1.html">lambda_group1</a><br class="typebreak"/>
&lt; T_functor, typename <br class="typebreak"/>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_type1 &gt;<br class="typebreak"/>
::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lambdas.html#ga56a5905d189af5fab33d8c456f097a29">group</a> (const T_functor&amp; _A_func, T_type1 _A_1)</td></tr>
<tr class="memdesc:ga56a5905d189af5fab33d8c456f097a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alters an arbitrary functor by rebuilding its arguments from 1 lambda expressions.  <a href="group__lambdas.html#ga56a5905d189af5fab33d8c456f097a29">More...</a><br/></td></tr>
<tr class="separator:ga56a5905d189af5fab33d8c456f097a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadbc8eaf9aa10213c228b53e69f3fead"><td class="memTemplParams" colspan="2">template&lt;class T_functor , class T_type1 , class T_type2 &gt; </td></tr>
<tr class="memitem:gaadbc8eaf9aa10213c228b53e69f3fead"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__group2.html">lambda_group2</a><br class="typebreak"/>
&lt; T_functor, typename <br class="typebreak"/>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_type1 &gt;<br class="typebreak"/>
::type, typename <br class="typebreak"/>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_type2 &gt;<br class="typebreak"/>
::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lambdas.html#gaadbc8eaf9aa10213c228b53e69f3fead">group</a> (const T_functor&amp; _A_func, T_type1 _A_1, T_type2 _A_2)</td></tr>
<tr class="memdesc:gaadbc8eaf9aa10213c228b53e69f3fead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alters an arbitrary functor by rebuilding its arguments from 2 lambda expressions.  <a href="group__lambdas.html#gaadbc8eaf9aa10213c228b53e69f3fead">More...</a><br/></td></tr>
<tr class="separator:gaadbc8eaf9aa10213c228b53e69f3fead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga993b22c0e13eb536edd9bcc3afd6d949"><td class="memTemplParams" colspan="2">template&lt;class T_functor , class T_type1 , class T_type2 , class T_type3 &gt; </td></tr>
<tr class="memitem:ga993b22c0e13eb536edd9bcc3afd6d949"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; <a class="el" href="structsigc_1_1lambda__group3.html">lambda_group3</a><br class="typebreak"/>
&lt; T_functor, typename <br class="typebreak"/>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_type1 &gt;<br class="typebreak"/>
::type, typename <br class="typebreak"/>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_type2 &gt;<br class="typebreak"/>
::type, typename <br class="typebreak"/>
<a class="el" href="structsigc_1_1unwrap__reference.html">unwrap_reference</a>&lt; T_type3 &gt;<br class="typebreak"/>
::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lambdas.html#ga993b22c0e13eb536edd9bcc3afd6d949">group</a> (const T_functor&amp; _A_func, T_type1 _A_1, T_type2 _A_2, T_type3 _A_3)</td></tr>
<tr class="memdesc:ga993b22c0e13eb536edd9bcc3afd6d949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alters an arbitrary functor by rebuilding its arguments from 3 lambda expressions.  <a href="group__lambdas.html#ga993b22c0e13eb536edd9bcc3afd6d949">More...</a><br/></td></tr>
<tr class="separator:ga993b22c0e13eb536edd9bcc3afd6d949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2cefea3a99acd44f68121424103172d"><td class="memTemplParams" colspan="2">template&lt;int I_location, class T_functor &gt; </td></tr>
<tr class="memitem:gaf2cefea3a99acd44f68121424103172d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1hide__functor.html">hide_functor</a>&lt; I_location, <br class="typebreak"/>
T_functor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__hide.html#gaf2cefea3a99acd44f68121424103172d">hide</a> (const T_functor&amp; _A_func)</td></tr>
<tr class="memdesc:gaf2cefea3a99acd44f68121424103172d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1hide__functor.html" title="Adaptor that adds a dummy parameter to the wrapped functor. ">sigc::hide_functor</a> which adds a dummy parameter to the passed functor.  <a href="group__hide.html#gaf2cefea3a99acd44f68121424103172d">More...</a><br/></td></tr>
<tr class="separator:gaf2cefea3a99acd44f68121424103172d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbbacd3553268d85b95e3a85aefb67e5"><td class="memTemplParams" colspan="2">template&lt;class T_functor &gt; </td></tr>
<tr class="memitem:gacbbacd3553268d85b95e3a85aefb67e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1hide__functor.html">hide_functor</a>&lt;-1, T_functor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__hide.html#gacbbacd3553268d85b95e3a85aefb67e5">hide</a> (const T_functor&amp; _A_func)</td></tr>
<tr class="memdesc:gacbbacd3553268d85b95e3a85aefb67e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1hide__functor.html" title="Adaptor that adds a dummy parameter to the wrapped functor. ">sigc::hide_functor</a> which adds a dummy parameter to the passed functor.  <a href="group__hide.html#gacbbacd3553268d85b95e3a85aefb67e5">More...</a><br/></td></tr>
<tr class="separator:gacbbacd3553268d85b95e3a85aefb67e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4e6f5491471c12440f1c5d480726b98"><td class="memTemplParams" colspan="2">template&lt;class T_functor &gt; </td></tr>
<tr class="memitem:gae4e6f5491471c12440f1c5d480726b98"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__return__functor.html">retype_return_functor</a>&lt; void, <br class="typebreak"/>
T_functor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__hide.html#gae4e6f5491471c12440f1c5d480726b98">hide_return</a> (const T_functor&amp; _A_functor)</td></tr>
<tr class="memdesc:gae4e6f5491471c12440f1c5d480726b98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__return__functor.html" title="Adaptor that performs a C-style cast on the return value of a functor. ">sigc::retype_return_functor</a> which drops the return value of the passed functor.  <a href="group__hide.html#gae4e6f5491471c12440f1c5d480726b98">More...</a><br/></td></tr>
<tr class="separator:gae4e6f5491471c12440f1c5d480726b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf6b6d22c503b439019f0a2e77352419"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gadf6b6d22c503b439019f0a2e77352419"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor0.html">mem_functor0</a>&lt; T_return, T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gadf6b6d22c503b439019f0a2e77352419">mem_fun</a> (T_return(T_obj::* _A_func)())</td></tr>
<tr class="memdesc:gadf6b6d22c503b439019f0a2e77352419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor0.html" title="mem_functor0 wraps methods with 0 argument(s). ">sigc::mem_functor0</a> which wraps a method.  <a href="group__mem__fun.html#gadf6b6d22c503b439019f0a2e77352419">More...</a><br/></td></tr>
<tr class="separator:gadf6b6d22c503b439019f0a2e77352419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab661fef0f04e2e439912eee6989e9657"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gab661fef0f04e2e439912eee6989e9657"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor1.html">mem_functor1</a>&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gab661fef0f04e2e439912eee6989e9657">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1))</td></tr>
<tr class="memdesc:gab661fef0f04e2e439912eee6989e9657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor1.html" title="mem_functor1 wraps methods with 1 argument(s). ">sigc::mem_functor1</a> which wraps a method.  <a href="group__mem__fun.html#gab661fef0f04e2e439912eee6989e9657">More...</a><br/></td></tr>
<tr class="separator:gab661fef0f04e2e439912eee6989e9657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bcfe2d4b91ff49bc8bf27af5a5f3bc5"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga4bcfe2d4b91ff49bc8bf27af5a5f3bc5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor2.html">mem_functor2</a>&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga4bcfe2d4b91ff49bc8bf27af5a5f3bc5">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2))</td></tr>
<tr class="memdesc:ga4bcfe2d4b91ff49bc8bf27af5a5f3bc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor2.html" title="mem_functor2 wraps methods with 2 argument(s). ">sigc::mem_functor2</a> which wraps a method.  <a href="group__mem__fun.html#ga4bcfe2d4b91ff49bc8bf27af5a5f3bc5">More...</a><br/></td></tr>
<tr class="separator:ga4bcfe2d4b91ff49bc8bf27af5a5f3bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3778234963fa65d4f638856d91109d1"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gaa3778234963fa65d4f638856d91109d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor3.html">mem_functor3</a>&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaa3778234963fa65d4f638856d91109d1">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>
<tr class="memdesc:gaa3778234963fa65d4f638856d91109d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor3.html" title="mem_functor3 wraps methods with 3 argument(s). ">sigc::mem_functor3</a> which wraps a method.  <a href="group__mem__fun.html#gaa3778234963fa65d4f638856d91109d1">More...</a><br/></td></tr>
<tr class="separator:gaa3778234963fa65d4f638856d91109d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadadd40aba6dadd0edbaac609dfae3938"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gadadd40aba6dadd0edbaac609dfae3938"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor4.html">mem_functor4</a>&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3, T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gadadd40aba6dadd0edbaac609dfae3938">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>
<tr class="memdesc:gadadd40aba6dadd0edbaac609dfae3938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor4.html" title="mem_functor4 wraps methods with 4 argument(s). ">sigc::mem_functor4</a> which wraps a method.  <a href="group__mem__fun.html#gadadd40aba6dadd0edbaac609dfae3938">More...</a><br/></td></tr>
<tr class="separator:gadadd40aba6dadd0edbaac609dfae3938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa01df6c622d59cfd2d0d8aa3c04c36d1"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gaa01df6c622d59cfd2d0d8aa3c04c36d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor5.html">mem_functor5</a>&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3, T_arg4, <br class="typebreak"/>
T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaa01df6c622d59cfd2d0d8aa3c04c36d1">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>
<tr class="memdesc:gaa01df6c622d59cfd2d0d8aa3c04c36d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor5.html" title="mem_functor5 wraps methods with 5 argument(s). ">sigc::mem_functor5</a> which wraps a method.  <a href="group__mem__fun.html#gaa01df6c622d59cfd2d0d8aa3c04c36d1">More...</a><br/></td></tr>
<tr class="separator:gaa01df6c622d59cfd2d0d8aa3c04c36d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9030b647c35e06c68342fee34e8fd320"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga9030b647c35e06c68342fee34e8fd320"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor6.html">mem_functor6</a>&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3, T_arg4, <br class="typebreak"/>
T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga9030b647c35e06c68342fee34e8fd320">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>
<tr class="memdesc:ga9030b647c35e06c68342fee34e8fd320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor6.html" title="mem_functor6 wraps methods with 6 argument(s). ">sigc::mem_functor6</a> which wraps a method.  <a href="group__mem__fun.html#ga9030b647c35e06c68342fee34e8fd320">More...</a><br/></td></tr>
<tr class="separator:ga9030b647c35e06c68342fee34e8fd320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54e4bf947e8c93c56931b8e8f7ed0d2e"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga54e4bf947e8c93c56931b8e8f7ed0d2e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor7.html">mem_functor7</a>&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3, T_arg4, <br class="typebreak"/>
T_arg5, T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga54e4bf947e8c93c56931b8e8f7ed0d2e">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>
<tr class="memdesc:ga54e4bf947e8c93c56931b8e8f7ed0d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor7.html" title="mem_functor7 wraps methods with 7 argument(s). ">sigc::mem_functor7</a> which wraps a method.  <a href="group__mem__fun.html#ga54e4bf947e8c93c56931b8e8f7ed0d2e">More...</a><br/></td></tr>
<tr class="separator:ga54e4bf947e8c93c56931b8e8f7ed0d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf6b6d22c503b439019f0a2e77352419"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gadf6b6d22c503b439019f0a2e77352419"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1const__mem__functor0.html">const_mem_functor0</a>&lt; T_return, <br class="typebreak"/>
T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gadf6b6d22c503b439019f0a2e77352419">mem_fun</a> (T_return(T_obj::* _A_func)() const)</td></tr>
<tr class="memdesc:gadf6b6d22c503b439019f0a2e77352419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor0.html" title="const_mem_functor0 wraps const methods with 0 argument(s). ">sigc::const_mem_functor0</a> which wraps a const method.  <a href="#gadf6b6d22c503b439019f0a2e77352419">More...</a><br/></td></tr>
<tr class="separator:gadf6b6d22c503b439019f0a2e77352419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab661fef0f04e2e439912eee6989e9657"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gab661fef0f04e2e439912eee6989e9657"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1const__mem__functor1.html">const_mem_functor1</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gab661fef0f04e2e439912eee6989e9657">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1) const)</td></tr>
<tr class="memdesc:gab661fef0f04e2e439912eee6989e9657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor1.html" title="const_mem_functor1 wraps const methods with 1 argument(s). ">sigc::const_mem_functor1</a> which wraps a const method.  <a href="#gab661fef0f04e2e439912eee6989e9657">More...</a><br/></td></tr>
<tr class="separator:gab661fef0f04e2e439912eee6989e9657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bcfe2d4b91ff49bc8bf27af5a5f3bc5"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga4bcfe2d4b91ff49bc8bf27af5a5f3bc5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1const__mem__functor2.html">const_mem_functor2</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga4bcfe2d4b91ff49bc8bf27af5a5f3bc5">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2) const)</td></tr>
<tr class="memdesc:ga4bcfe2d4b91ff49bc8bf27af5a5f3bc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor2.html" title="const_mem_functor2 wraps const methods with 2 argument(s). ">sigc::const_mem_functor2</a> which wraps a const method.  <a href="#ga4bcfe2d4b91ff49bc8bf27af5a5f3bc5">More...</a><br/></td></tr>
<tr class="separator:ga4bcfe2d4b91ff49bc8bf27af5a5f3bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3778234963fa65d4f638856d91109d1"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gaa3778234963fa65d4f638856d91109d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1const__mem__functor3.html">const_mem_functor3</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gaa3778234963fa65d4f638856d91109d1">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3) const)</td></tr>
<tr class="memdesc:gaa3778234963fa65d4f638856d91109d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor3.html" title="const_mem_functor3 wraps const methods with 3 argument(s). ">sigc::const_mem_functor3</a> which wraps a const method.  <a href="#gaa3778234963fa65d4f638856d91109d1">More...</a><br/></td></tr>
<tr class="separator:gaa3778234963fa65d4f638856d91109d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadadd40aba6dadd0edbaac609dfae3938"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gadadd40aba6dadd0edbaac609dfae3938"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1const__mem__functor4.html">const_mem_functor4</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gadadd40aba6dadd0edbaac609dfae3938">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const)</td></tr>
<tr class="memdesc:gadadd40aba6dadd0edbaac609dfae3938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor4.html" title="const_mem_functor4 wraps const methods with 4 argument(s). ">sigc::const_mem_functor4</a> which wraps a const method.  <a href="#gadadd40aba6dadd0edbaac609dfae3938">More...</a><br/></td></tr>
<tr class="separator:gadadd40aba6dadd0edbaac609dfae3938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa01df6c622d59cfd2d0d8aa3c04c36d1"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gaa01df6c622d59cfd2d0d8aa3c04c36d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1const__mem__functor5.html">const_mem_functor5</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gaa01df6c622d59cfd2d0d8aa3c04c36d1">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const)</td></tr>
<tr class="memdesc:gaa01df6c622d59cfd2d0d8aa3c04c36d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor5.html" title="const_mem_functor5 wraps const methods with 5 argument(s). ">sigc::const_mem_functor5</a> which wraps a const method.  <a href="#gaa01df6c622d59cfd2d0d8aa3c04c36d1">More...</a><br/></td></tr>
<tr class="separator:gaa01df6c622d59cfd2d0d8aa3c04c36d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9030b647c35e06c68342fee34e8fd320"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga9030b647c35e06c68342fee34e8fd320"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1const__mem__functor6.html">const_mem_functor6</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga9030b647c35e06c68342fee34e8fd320">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const)</td></tr>
<tr class="memdesc:ga9030b647c35e06c68342fee34e8fd320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor6.html" title="const_mem_functor6 wraps const methods with 6 argument(s). ">sigc::const_mem_functor6</a> which wraps a const method.  <a href="#ga9030b647c35e06c68342fee34e8fd320">More...</a><br/></td></tr>
<tr class="separator:ga9030b647c35e06c68342fee34e8fd320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54e4bf947e8c93c56931b8e8f7ed0d2e"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga54e4bf947e8c93c56931b8e8f7ed0d2e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1const__mem__functor7.html">const_mem_functor7</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga54e4bf947e8c93c56931b8e8f7ed0d2e">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const)</td></tr>
<tr class="memdesc:ga54e4bf947e8c93c56931b8e8f7ed0d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor7.html" title="const_mem_functor7 wraps const methods with 7 argument(s). ">sigc::const_mem_functor7</a> which wraps a const method.  <a href="#ga54e4bf947e8c93c56931b8e8f7ed0d2e">More...</a><br/></td></tr>
<tr class="separator:ga54e4bf947e8c93c56931b8e8f7ed0d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf6b6d22c503b439019f0a2e77352419"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gadf6b6d22c503b439019f0a2e77352419"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1volatile__mem__functor0.html">volatile_mem_functor0</a><br class="typebreak"/>
&lt; T_return, T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gadf6b6d22c503b439019f0a2e77352419">mem_fun</a> (T_return(T_obj::* _A_func)() volatile)</td></tr>
<tr class="memdesc:gadf6b6d22c503b439019f0a2e77352419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor0.html" title="volatile_mem_functor0 wraps volatile methods with 0 argument(s). ">sigc::volatile_mem_functor0</a> which wraps a volatile method.  <a href="#gadf6b6d22c503b439019f0a2e77352419">More...</a><br/></td></tr>
<tr class="separator:gadf6b6d22c503b439019f0a2e77352419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab661fef0f04e2e439912eee6989e9657"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gab661fef0f04e2e439912eee6989e9657"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1volatile__mem__functor1.html">volatile_mem_functor1</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gab661fef0f04e2e439912eee6989e9657">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1) volatile)</td></tr>
<tr class="memdesc:gab661fef0f04e2e439912eee6989e9657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor1.html" title="volatile_mem_functor1 wraps volatile methods with 1 argument(s). ">sigc::volatile_mem_functor1</a> which wraps a volatile method.  <a href="#gab661fef0f04e2e439912eee6989e9657">More...</a><br/></td></tr>
<tr class="separator:gab661fef0f04e2e439912eee6989e9657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bcfe2d4b91ff49bc8bf27af5a5f3bc5"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga4bcfe2d4b91ff49bc8bf27af5a5f3bc5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1volatile__mem__functor2.html">volatile_mem_functor2</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga4bcfe2d4b91ff49bc8bf27af5a5f3bc5">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2) volatile)</td></tr>
<tr class="memdesc:ga4bcfe2d4b91ff49bc8bf27af5a5f3bc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor2.html" title="volatile_mem_functor2 wraps volatile methods with 2 argument(s). ">sigc::volatile_mem_functor2</a> which wraps a volatile method.  <a href="#ga4bcfe2d4b91ff49bc8bf27af5a5f3bc5">More...</a><br/></td></tr>
<tr class="separator:ga4bcfe2d4b91ff49bc8bf27af5a5f3bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3778234963fa65d4f638856d91109d1"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gaa3778234963fa65d4f638856d91109d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1volatile__mem__functor3.html">volatile_mem_functor3</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gaa3778234963fa65d4f638856d91109d1">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3) volatile)</td></tr>
<tr class="memdesc:gaa3778234963fa65d4f638856d91109d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor3.html" title="volatile_mem_functor3 wraps volatile methods with 3 argument(s). ">sigc::volatile_mem_functor3</a> which wraps a volatile method.  <a href="#gaa3778234963fa65d4f638856d91109d1">More...</a><br/></td></tr>
<tr class="separator:gaa3778234963fa65d4f638856d91109d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadadd40aba6dadd0edbaac609dfae3938"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gadadd40aba6dadd0edbaac609dfae3938"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1volatile__mem__functor4.html">volatile_mem_functor4</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gadadd40aba6dadd0edbaac609dfae3938">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) volatile)</td></tr>
<tr class="memdesc:gadadd40aba6dadd0edbaac609dfae3938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor4.html" title="volatile_mem_functor4 wraps volatile methods with 4 argument(s). ">sigc::volatile_mem_functor4</a> which wraps a volatile method.  <a href="#gadadd40aba6dadd0edbaac609dfae3938">More...</a><br/></td></tr>
<tr class="separator:gadadd40aba6dadd0edbaac609dfae3938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa01df6c622d59cfd2d0d8aa3c04c36d1"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gaa01df6c622d59cfd2d0d8aa3c04c36d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1volatile__mem__functor5.html">volatile_mem_functor5</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gaa01df6c622d59cfd2d0d8aa3c04c36d1">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) volatile)</td></tr>
<tr class="memdesc:gaa01df6c622d59cfd2d0d8aa3c04c36d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor5.html" title="volatile_mem_functor5 wraps volatile methods with 5 argument(s). ">sigc::volatile_mem_functor5</a> which wraps a volatile method.  <a href="#gaa01df6c622d59cfd2d0d8aa3c04c36d1">More...</a><br/></td></tr>
<tr class="separator:gaa01df6c622d59cfd2d0d8aa3c04c36d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9030b647c35e06c68342fee34e8fd320"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga9030b647c35e06c68342fee34e8fd320"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1volatile__mem__functor6.html">volatile_mem_functor6</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga9030b647c35e06c68342fee34e8fd320">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) volatile)</td></tr>
<tr class="memdesc:ga9030b647c35e06c68342fee34e8fd320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor6.html" title="volatile_mem_functor6 wraps volatile methods with 6 argument(s). ">sigc::volatile_mem_functor6</a> which wraps a volatile method.  <a href="#ga9030b647c35e06c68342fee34e8fd320">More...</a><br/></td></tr>
<tr class="separator:ga9030b647c35e06c68342fee34e8fd320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54e4bf947e8c93c56931b8e8f7ed0d2e"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga54e4bf947e8c93c56931b8e8f7ed0d2e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1volatile__mem__functor7.html">volatile_mem_functor7</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga54e4bf947e8c93c56931b8e8f7ed0d2e">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) volatile)</td></tr>
<tr class="memdesc:ga54e4bf947e8c93c56931b8e8f7ed0d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor7.html" title="volatile_mem_functor7 wraps volatile methods with 7 argument(s). ">sigc::volatile_mem_functor7</a> which wraps a volatile method.  <a href="#ga54e4bf947e8c93c56931b8e8f7ed0d2e">More...</a><br/></td></tr>
<tr class="separator:ga54e4bf947e8c93c56931b8e8f7ed0d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf6b6d22c503b439019f0a2e77352419"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gadf6b6d22c503b439019f0a2e77352419"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1const__volatile__mem__functor0.html">const_volatile_mem_functor0</a><br class="typebreak"/>
&lt; T_return, T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gadf6b6d22c503b439019f0a2e77352419">mem_fun</a> (T_return(T_obj::* _A_func)() const volatile)</td></tr>
<tr class="memdesc:gadf6b6d22c503b439019f0a2e77352419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor0.html" title="const_volatile_mem_functor0 wraps const volatile methods with 0 argument(s). ">sigc::const_volatile_mem_functor0</a> which wraps a const volatile method.  <a href="#gadf6b6d22c503b439019f0a2e77352419">More...</a><br/></td></tr>
<tr class="separator:gadf6b6d22c503b439019f0a2e77352419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab661fef0f04e2e439912eee6989e9657"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gab661fef0f04e2e439912eee6989e9657"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1const__volatile__mem__functor1.html">const_volatile_mem_functor1</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gab661fef0f04e2e439912eee6989e9657">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1) const volatile)</td></tr>
<tr class="memdesc:gab661fef0f04e2e439912eee6989e9657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor1.html" title="const_volatile_mem_functor1 wraps const volatile methods with 1 argument(s). ">sigc::const_volatile_mem_functor1</a> which wraps a const volatile method.  <a href="#gab661fef0f04e2e439912eee6989e9657">More...</a><br/></td></tr>
<tr class="separator:gab661fef0f04e2e439912eee6989e9657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bcfe2d4b91ff49bc8bf27af5a5f3bc5"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga4bcfe2d4b91ff49bc8bf27af5a5f3bc5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1const__volatile__mem__functor2.html">const_volatile_mem_functor2</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga4bcfe2d4b91ff49bc8bf27af5a5f3bc5">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2) const volatile)</td></tr>
<tr class="memdesc:ga4bcfe2d4b91ff49bc8bf27af5a5f3bc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor2.html" title="const_volatile_mem_functor2 wraps const volatile methods with 2 argument(s). ">sigc::const_volatile_mem_functor2</a> which wraps a const volatile method.  <a href="#ga4bcfe2d4b91ff49bc8bf27af5a5f3bc5">More...</a><br/></td></tr>
<tr class="separator:ga4bcfe2d4b91ff49bc8bf27af5a5f3bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3778234963fa65d4f638856d91109d1"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gaa3778234963fa65d4f638856d91109d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1const__volatile__mem__functor3.html">const_volatile_mem_functor3</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gaa3778234963fa65d4f638856d91109d1">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3) const volatile)</td></tr>
<tr class="memdesc:gaa3778234963fa65d4f638856d91109d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor3.html" title="const_volatile_mem_functor3 wraps const volatile methods with 3 argument(s). ">sigc::const_volatile_mem_functor3</a> which wraps a const volatile method.  <a href="#gaa3778234963fa65d4f638856d91109d1">More...</a><br/></td></tr>
<tr class="separator:gaa3778234963fa65d4f638856d91109d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadadd40aba6dadd0edbaac609dfae3938"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gadadd40aba6dadd0edbaac609dfae3938"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1const__volatile__mem__functor4.html">const_volatile_mem_functor4</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gadadd40aba6dadd0edbaac609dfae3938">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const volatile)</td></tr>
<tr class="memdesc:gadadd40aba6dadd0edbaac609dfae3938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor4.html" title="const_volatile_mem_functor4 wraps const volatile methods with 4 argument(s). ">sigc::const_volatile_mem_functor4</a> which wraps a const volatile method.  <a href="#gadadd40aba6dadd0edbaac609dfae3938">More...</a><br/></td></tr>
<tr class="separator:gadadd40aba6dadd0edbaac609dfae3938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa01df6c622d59cfd2d0d8aa3c04c36d1"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gaa01df6c622d59cfd2d0d8aa3c04c36d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1const__volatile__mem__functor5.html">const_volatile_mem_functor5</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gaa01df6c622d59cfd2d0d8aa3c04c36d1">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const volatile)</td></tr>
<tr class="memdesc:gaa01df6c622d59cfd2d0d8aa3c04c36d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor5.html" title="const_volatile_mem_functor5 wraps const volatile methods with 5 argument(s). ">sigc::const_volatile_mem_functor5</a> which wraps a const volatile method.  <a href="#gaa01df6c622d59cfd2d0d8aa3c04c36d1">More...</a><br/></td></tr>
<tr class="separator:gaa01df6c622d59cfd2d0d8aa3c04c36d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9030b647c35e06c68342fee34e8fd320"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga9030b647c35e06c68342fee34e8fd320"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1const__volatile__mem__functor6.html">const_volatile_mem_functor6</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga9030b647c35e06c68342fee34e8fd320">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const volatile)</td></tr>
<tr class="memdesc:ga9030b647c35e06c68342fee34e8fd320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor6.html" title="const_volatile_mem_functor6 wraps const volatile methods with 6 argument(s). ">sigc::const_volatile_mem_functor6</a> which wraps a const volatile method.  <a href="#ga9030b647c35e06c68342fee34e8fd320">More...</a><br/></td></tr>
<tr class="separator:ga9030b647c35e06c68342fee34e8fd320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54e4bf947e8c93c56931b8e8f7ed0d2e"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga54e4bf947e8c93c56931b8e8f7ed0d2e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1const__volatile__mem__functor7.html">const_volatile_mem_functor7</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga54e4bf947e8c93c56931b8e8f7ed0d2e">mem_fun</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const volatile)</td></tr>
<tr class="memdesc:ga54e4bf947e8c93c56931b8e8f7ed0d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor7.html" title="const_volatile_mem_functor7 wraps const volatile methods with 7 argument(s). ">sigc::const_volatile_mem_functor7</a> which wraps a const volatile method.  <a href="#ga54e4bf947e8c93c56931b8e8f7ed0d2e">More...</a><br/></td></tr>
<tr class="separator:ga54e4bf947e8c93c56931b8e8f7ed0d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f57ec0156d33b4aa98e259d2e2062db"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga7f57ec0156d33b4aa98e259d2e2062db"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor0.html">bound_mem_functor0</a>&lt; T_return, <br class="typebreak"/>
T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga7f57ec0156d33b4aa98e259d2e2062db">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)())</td></tr>
<tr class="memdesc:ga7f57ec0156d33b4aa98e259d2e2062db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor0.html" title="bound_mem_functor0 encapsulates a method with 0 arguments and an object instance. ...">sigc::bound_mem_functor0</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#ga7f57ec0156d33b4aa98e259d2e2062db">More...</a><br/></td></tr>
<tr class="separator:ga7f57ec0156d33b4aa98e259d2e2062db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeef6e55681664df29b31edec51ea034d"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gaeef6e55681664df29b31edec51ea034d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor0.html">bound_mem_functor0</a>&lt; T_return, <br class="typebreak"/>
T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaeef6e55681664df29b31edec51ea034d">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)())</td></tr>
<tr class="memdesc:gaeef6e55681664df29b31edec51ea034d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor0.html" title="bound_mem_functor0 encapsulates a method with 0 arguments and an object instance. ...">sigc::bound_mem_functor0</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#gaeef6e55681664df29b31edec51ea034d">More...</a><br/></td></tr>
<tr class="separator:gaeef6e55681664df29b31edec51ea034d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0df7af9f32990cc624c4bb60782b4f78"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga0df7af9f32990cc624c4bb60782b4f78"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor1.html">bound_mem_functor1</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga0df7af9f32990cc624c4bb60782b4f78">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1))</td></tr>
<tr class="memdesc:ga0df7af9f32990cc624c4bb60782b4f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor1.html" title="bound_mem_functor1 encapsulates a method with 1 arguments and an object instance. ...">sigc::bound_mem_functor1</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#ga0df7af9f32990cc624c4bb60782b4f78">More...</a><br/></td></tr>
<tr class="separator:ga0df7af9f32990cc624c4bb60782b4f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7de39a04dfc6d37b2d12a25cdccfbe95"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga7de39a04dfc6d37b2d12a25cdccfbe95"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor1.html">bound_mem_functor1</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga7de39a04dfc6d37b2d12a25cdccfbe95">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1))</td></tr>
<tr class="memdesc:ga7de39a04dfc6d37b2d12a25cdccfbe95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor1.html" title="bound_mem_functor1 encapsulates a method with 1 arguments and an object instance. ...">sigc::bound_mem_functor1</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#ga7de39a04dfc6d37b2d12a25cdccfbe95">More...</a><br/></td></tr>
<tr class="separator:ga7de39a04dfc6d37b2d12a25cdccfbe95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga118b2610268701be95cdc6fddb7bab3b"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga118b2610268701be95cdc6fddb7bab3b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor2.html">bound_mem_functor2</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga118b2610268701be95cdc6fddb7bab3b">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2))</td></tr>
<tr class="memdesc:ga118b2610268701be95cdc6fddb7bab3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor2.html" title="bound_mem_functor2 encapsulates a method with 2 arguments and an object instance. ...">sigc::bound_mem_functor2</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#ga118b2610268701be95cdc6fddb7bab3b">More...</a><br/></td></tr>
<tr class="separator:ga118b2610268701be95cdc6fddb7bab3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1add5c927b51b935b4f2d40558079fa"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gab1add5c927b51b935b4f2d40558079fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor2.html">bound_mem_functor2</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gab1add5c927b51b935b4f2d40558079fa">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2))</td></tr>
<tr class="memdesc:gab1add5c927b51b935b4f2d40558079fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor2.html" title="bound_mem_functor2 encapsulates a method with 2 arguments and an object instance. ...">sigc::bound_mem_functor2</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#gab1add5c927b51b935b4f2d40558079fa">More...</a><br/></td></tr>
<tr class="separator:gab1add5c927b51b935b4f2d40558079fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb6bd4518e0f0c524dba13a6cbb2e319"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gaeb6bd4518e0f0c524dba13a6cbb2e319"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor3.html">bound_mem_functor3</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaeb6bd4518e0f0c524dba13a6cbb2e319">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>
<tr class="memdesc:gaeb6bd4518e0f0c524dba13a6cbb2e319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor3.html" title="bound_mem_functor3 encapsulates a method with 3 arguments and an object instance. ...">sigc::bound_mem_functor3</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#gaeb6bd4518e0f0c524dba13a6cbb2e319">More...</a><br/></td></tr>
<tr class="separator:gaeb6bd4518e0f0c524dba13a6cbb2e319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f1aa3b60c0d2d8b2470bba0b2b36023"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga1f1aa3b60c0d2d8b2470bba0b2b36023"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor3.html">bound_mem_functor3</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga1f1aa3b60c0d2d8b2470bba0b2b36023">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>
<tr class="memdesc:ga1f1aa3b60c0d2d8b2470bba0b2b36023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor3.html" title="bound_mem_functor3 encapsulates a method with 3 arguments and an object instance. ...">sigc::bound_mem_functor3</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#ga1f1aa3b60c0d2d8b2470bba0b2b36023">More...</a><br/></td></tr>
<tr class="separator:ga1f1aa3b60c0d2d8b2470bba0b2b36023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02c906c95895c58e39ee301bb1577994"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga02c906c95895c58e39ee301bb1577994"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor4.html">bound_mem_functor4</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga02c906c95895c58e39ee301bb1577994">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>
<tr class="memdesc:ga02c906c95895c58e39ee301bb1577994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor4.html" title="bound_mem_functor4 encapsulates a method with 4 arguments and an object instance. ...">sigc::bound_mem_functor4</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#ga02c906c95895c58e39ee301bb1577994">More...</a><br/></td></tr>
<tr class="separator:ga02c906c95895c58e39ee301bb1577994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga481ef34d8423d26e8ff0a1916cd295d5"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga481ef34d8423d26e8ff0a1916cd295d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor4.html">bound_mem_functor4</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga481ef34d8423d26e8ff0a1916cd295d5">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>
<tr class="memdesc:ga481ef34d8423d26e8ff0a1916cd295d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor4.html" title="bound_mem_functor4 encapsulates a method with 4 arguments and an object instance. ...">sigc::bound_mem_functor4</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#ga481ef34d8423d26e8ff0a1916cd295d5">More...</a><br/></td></tr>
<tr class="separator:ga481ef34d8423d26e8ff0a1916cd295d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab138ae1a340be983166b69872826b37d"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gab138ae1a340be983166b69872826b37d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor5.html">bound_mem_functor5</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gab138ae1a340be983166b69872826b37d">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>
<tr class="memdesc:gab138ae1a340be983166b69872826b37d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor5.html" title="bound_mem_functor5 encapsulates a method with 5 arguments and an object instance. ...">sigc::bound_mem_functor5</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#gab138ae1a340be983166b69872826b37d">More...</a><br/></td></tr>
<tr class="separator:gab138ae1a340be983166b69872826b37d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09fb13b1684ec7c092ffef695dbb261a"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga09fb13b1684ec7c092ffef695dbb261a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor5.html">bound_mem_functor5</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga09fb13b1684ec7c092ffef695dbb261a">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>
<tr class="memdesc:ga09fb13b1684ec7c092ffef695dbb261a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor5.html" title="bound_mem_functor5 encapsulates a method with 5 arguments and an object instance. ...">sigc::bound_mem_functor5</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#ga09fb13b1684ec7c092ffef695dbb261a">More...</a><br/></td></tr>
<tr class="separator:ga09fb13b1684ec7c092ffef695dbb261a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e3841c4844715d2f2d832ed506f028f"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga3e3841c4844715d2f2d832ed506f028f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor6.html">bound_mem_functor6</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga3e3841c4844715d2f2d832ed506f028f">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>
<tr class="memdesc:ga3e3841c4844715d2f2d832ed506f028f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor6.html" title="bound_mem_functor6 encapsulates a method with 6 arguments and an object instance. ...">sigc::bound_mem_functor6</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#ga3e3841c4844715d2f2d832ed506f028f">More...</a><br/></td></tr>
<tr class="separator:ga3e3841c4844715d2f2d832ed506f028f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d9b992d69123a524b6c70c458ad0d40"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga0d9b992d69123a524b6c70c458ad0d40"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor6.html">bound_mem_functor6</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga0d9b992d69123a524b6c70c458ad0d40">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>
<tr class="memdesc:ga0d9b992d69123a524b6c70c458ad0d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor6.html" title="bound_mem_functor6 encapsulates a method with 6 arguments and an object instance. ...">sigc::bound_mem_functor6</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#ga0d9b992d69123a524b6c70c458ad0d40">More...</a><br/></td></tr>
<tr class="separator:ga0d9b992d69123a524b6c70c458ad0d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea5a2ace2699b8d1ffe93585e335548d"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gaea5a2ace2699b8d1ffe93585e335548d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor7.html">bound_mem_functor7</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaea5a2ace2699b8d1ffe93585e335548d">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>
<tr class="memdesc:gaea5a2ace2699b8d1ffe93585e335548d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor7.html" title="bound_mem_functor7 encapsulates a method with 7 arguments and an object instance. ...">sigc::bound_mem_functor7</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#gaea5a2ace2699b8d1ffe93585e335548d">More...</a><br/></td></tr>
<tr class="separator:gaea5a2ace2699b8d1ffe93585e335548d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dcdaf235baa50049e6088d246853037"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga5dcdaf235baa50049e6088d246853037"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor7.html">bound_mem_functor7</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga5dcdaf235baa50049e6088d246853037">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>
<tr class="memdesc:ga5dcdaf235baa50049e6088d246853037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor7.html" title="bound_mem_functor7 encapsulates a method with 7 arguments and an object instance. ...">sigc::bound_mem_functor7</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#ga5dcdaf235baa50049e6088d246853037">More...</a><br/></td></tr>
<tr class="separator:ga5dcdaf235baa50049e6088d246853037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f57ec0156d33b4aa98e259d2e2062db"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga7f57ec0156d33b4aa98e259d2e2062db"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor0.html">bound_const_mem_functor0</a><br class="typebreak"/>
&lt; T_return, T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga7f57ec0156d33b4aa98e259d2e2062db">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)() const)</td></tr>
<tr class="memdesc:ga7f57ec0156d33b4aa98e259d2e2062db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor0.html" title="bound_const_mem_functor0 encapsulates a const method with 0 arguments and an object instance...">sigc::bound_const_mem_functor0</a> which encapsulates a method and an object instance.  <a href="#ga7f57ec0156d33b4aa98e259d2e2062db">More...</a><br/></td></tr>
<tr class="separator:ga7f57ec0156d33b4aa98e259d2e2062db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeef6e55681664df29b31edec51ea034d"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gaeef6e55681664df29b31edec51ea034d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor0.html">bound_const_mem_functor0</a><br class="typebreak"/>
&lt; T_return, T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gaeef6e55681664df29b31edec51ea034d">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)() const)</td></tr>
<tr class="memdesc:gaeef6e55681664df29b31edec51ea034d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor0.html" title="bound_const_mem_functor0 encapsulates a const method with 0 arguments and an object instance...">sigc::bound_const_mem_functor0</a> which encapsulates a method and an object instance.  <a href="#gaeef6e55681664df29b31edec51ea034d">More...</a><br/></td></tr>
<tr class="separator:gaeef6e55681664df29b31edec51ea034d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0df7af9f32990cc624c4bb60782b4f78"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga0df7af9f32990cc624c4bb60782b4f78"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor1.html">bound_const_mem_functor1</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga0df7af9f32990cc624c4bb60782b4f78">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1) const)</td></tr>
<tr class="memdesc:ga0df7af9f32990cc624c4bb60782b4f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor1.html" title="bound_const_mem_functor1 encapsulates a const method with 1 arguments and an object instance...">sigc::bound_const_mem_functor1</a> which encapsulates a method and an object instance.  <a href="#ga0df7af9f32990cc624c4bb60782b4f78">More...</a><br/></td></tr>
<tr class="separator:ga0df7af9f32990cc624c4bb60782b4f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7de39a04dfc6d37b2d12a25cdccfbe95"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga7de39a04dfc6d37b2d12a25cdccfbe95"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor1.html">bound_const_mem_functor1</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga7de39a04dfc6d37b2d12a25cdccfbe95">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1) const)</td></tr>
<tr class="memdesc:ga7de39a04dfc6d37b2d12a25cdccfbe95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor1.html" title="bound_const_mem_functor1 encapsulates a const method with 1 arguments and an object instance...">sigc::bound_const_mem_functor1</a> which encapsulates a method and an object instance.  <a href="#ga7de39a04dfc6d37b2d12a25cdccfbe95">More...</a><br/></td></tr>
<tr class="separator:ga7de39a04dfc6d37b2d12a25cdccfbe95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga118b2610268701be95cdc6fddb7bab3b"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga118b2610268701be95cdc6fddb7bab3b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor2.html">bound_const_mem_functor2</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga118b2610268701be95cdc6fddb7bab3b">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2) const)</td></tr>
<tr class="memdesc:ga118b2610268701be95cdc6fddb7bab3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor2.html" title="bound_const_mem_functor2 encapsulates a const method with 2 arguments and an object instance...">sigc::bound_const_mem_functor2</a> which encapsulates a method and an object instance.  <a href="#ga118b2610268701be95cdc6fddb7bab3b">More...</a><br/></td></tr>
<tr class="separator:ga118b2610268701be95cdc6fddb7bab3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1add5c927b51b935b4f2d40558079fa"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gab1add5c927b51b935b4f2d40558079fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor2.html">bound_const_mem_functor2</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gab1add5c927b51b935b4f2d40558079fa">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2) const)</td></tr>
<tr class="memdesc:gab1add5c927b51b935b4f2d40558079fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor2.html" title="bound_const_mem_functor2 encapsulates a const method with 2 arguments and an object instance...">sigc::bound_const_mem_functor2</a> which encapsulates a method and an object instance.  <a href="#gab1add5c927b51b935b4f2d40558079fa">More...</a><br/></td></tr>
<tr class="separator:gab1add5c927b51b935b4f2d40558079fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb6bd4518e0f0c524dba13a6cbb2e319"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gaeb6bd4518e0f0c524dba13a6cbb2e319"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor3.html">bound_const_mem_functor3</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gaeb6bd4518e0f0c524dba13a6cbb2e319">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3) const)</td></tr>
<tr class="memdesc:gaeb6bd4518e0f0c524dba13a6cbb2e319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor3.html" title="bound_const_mem_functor3 encapsulates a const method with 3 arguments and an object instance...">sigc::bound_const_mem_functor3</a> which encapsulates a method and an object instance.  <a href="#gaeb6bd4518e0f0c524dba13a6cbb2e319">More...</a><br/></td></tr>
<tr class="separator:gaeb6bd4518e0f0c524dba13a6cbb2e319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f1aa3b60c0d2d8b2470bba0b2b36023"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga1f1aa3b60c0d2d8b2470bba0b2b36023"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor3.html">bound_const_mem_functor3</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga1f1aa3b60c0d2d8b2470bba0b2b36023">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3) const)</td></tr>
<tr class="memdesc:ga1f1aa3b60c0d2d8b2470bba0b2b36023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor3.html" title="bound_const_mem_functor3 encapsulates a const method with 3 arguments and an object instance...">sigc::bound_const_mem_functor3</a> which encapsulates a method and an object instance.  <a href="#ga1f1aa3b60c0d2d8b2470bba0b2b36023">More...</a><br/></td></tr>
<tr class="separator:ga1f1aa3b60c0d2d8b2470bba0b2b36023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02c906c95895c58e39ee301bb1577994"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga02c906c95895c58e39ee301bb1577994"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor4.html">bound_const_mem_functor4</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga02c906c95895c58e39ee301bb1577994">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const)</td></tr>
<tr class="memdesc:ga02c906c95895c58e39ee301bb1577994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor4.html" title="bound_const_mem_functor4 encapsulates a const method with 4 arguments and an object instance...">sigc::bound_const_mem_functor4</a> which encapsulates a method and an object instance.  <a href="#ga02c906c95895c58e39ee301bb1577994">More...</a><br/></td></tr>
<tr class="separator:ga02c906c95895c58e39ee301bb1577994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga481ef34d8423d26e8ff0a1916cd295d5"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga481ef34d8423d26e8ff0a1916cd295d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor4.html">bound_const_mem_functor4</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga481ef34d8423d26e8ff0a1916cd295d5">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const)</td></tr>
<tr class="memdesc:ga481ef34d8423d26e8ff0a1916cd295d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor4.html" title="bound_const_mem_functor4 encapsulates a const method with 4 arguments and an object instance...">sigc::bound_const_mem_functor4</a> which encapsulates a method and an object instance.  <a href="#ga481ef34d8423d26e8ff0a1916cd295d5">More...</a><br/></td></tr>
<tr class="separator:ga481ef34d8423d26e8ff0a1916cd295d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab138ae1a340be983166b69872826b37d"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gab138ae1a340be983166b69872826b37d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor5.html">bound_const_mem_functor5</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gab138ae1a340be983166b69872826b37d">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const)</td></tr>
<tr class="memdesc:gab138ae1a340be983166b69872826b37d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor5.html" title="bound_const_mem_functor5 encapsulates a const method with 5 arguments and an object instance...">sigc::bound_const_mem_functor5</a> which encapsulates a method and an object instance.  <a href="#gab138ae1a340be983166b69872826b37d">More...</a><br/></td></tr>
<tr class="separator:gab138ae1a340be983166b69872826b37d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09fb13b1684ec7c092ffef695dbb261a"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga09fb13b1684ec7c092ffef695dbb261a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor5.html">bound_const_mem_functor5</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga09fb13b1684ec7c092ffef695dbb261a">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const)</td></tr>
<tr class="memdesc:ga09fb13b1684ec7c092ffef695dbb261a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor5.html" title="bound_const_mem_functor5 encapsulates a const method with 5 arguments and an object instance...">sigc::bound_const_mem_functor5</a> which encapsulates a method and an object instance.  <a href="#ga09fb13b1684ec7c092ffef695dbb261a">More...</a><br/></td></tr>
<tr class="separator:ga09fb13b1684ec7c092ffef695dbb261a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e3841c4844715d2f2d832ed506f028f"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga3e3841c4844715d2f2d832ed506f028f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor6.html">bound_const_mem_functor6</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga3e3841c4844715d2f2d832ed506f028f">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const)</td></tr>
<tr class="memdesc:ga3e3841c4844715d2f2d832ed506f028f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor6.html" title="bound_const_mem_functor6 encapsulates a const method with 6 arguments and an object instance...">sigc::bound_const_mem_functor6</a> which encapsulates a method and an object instance.  <a href="#ga3e3841c4844715d2f2d832ed506f028f">More...</a><br/></td></tr>
<tr class="separator:ga3e3841c4844715d2f2d832ed506f028f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d9b992d69123a524b6c70c458ad0d40"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga0d9b992d69123a524b6c70c458ad0d40"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor6.html">bound_const_mem_functor6</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga0d9b992d69123a524b6c70c458ad0d40">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const)</td></tr>
<tr class="memdesc:ga0d9b992d69123a524b6c70c458ad0d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor6.html" title="bound_const_mem_functor6 encapsulates a const method with 6 arguments and an object instance...">sigc::bound_const_mem_functor6</a> which encapsulates a method and an object instance.  <a href="#ga0d9b992d69123a524b6c70c458ad0d40">More...</a><br/></td></tr>
<tr class="separator:ga0d9b992d69123a524b6c70c458ad0d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea5a2ace2699b8d1ffe93585e335548d"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gaea5a2ace2699b8d1ffe93585e335548d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor7.html">bound_const_mem_functor7</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gaea5a2ace2699b8d1ffe93585e335548d">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const)</td></tr>
<tr class="memdesc:gaea5a2ace2699b8d1ffe93585e335548d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor7.html" title="bound_const_mem_functor7 encapsulates a const method with 7 arguments and an object instance...">sigc::bound_const_mem_functor7</a> which encapsulates a method and an object instance.  <a href="#gaea5a2ace2699b8d1ffe93585e335548d">More...</a><br/></td></tr>
<tr class="separator:gaea5a2ace2699b8d1ffe93585e335548d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dcdaf235baa50049e6088d246853037"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga5dcdaf235baa50049e6088d246853037"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor7.html">bound_const_mem_functor7</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga5dcdaf235baa50049e6088d246853037">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const)</td></tr>
<tr class="memdesc:ga5dcdaf235baa50049e6088d246853037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor7.html" title="bound_const_mem_functor7 encapsulates a const method with 7 arguments and an object instance...">sigc::bound_const_mem_functor7</a> which encapsulates a method and an object instance.  <a href="#ga5dcdaf235baa50049e6088d246853037">More...</a><br/></td></tr>
<tr class="separator:ga5dcdaf235baa50049e6088d246853037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f57ec0156d33b4aa98e259d2e2062db"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga7f57ec0156d33b4aa98e259d2e2062db"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html">bound_volatile_mem_functor0</a><br class="typebreak"/>
&lt; T_return, T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga7f57ec0156d33b4aa98e259d2e2062db">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)() volatile)</td></tr>
<tr class="memdesc:ga7f57ec0156d33b4aa98e259d2e2062db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html" title="bound_volatile_mem_functor0 encapsulates a volatile method with 0 arguments and an object instance...">sigc::bound_volatile_mem_functor0</a> which encapsulates a method and an object instance.  <a href="#ga7f57ec0156d33b4aa98e259d2e2062db">More...</a><br/></td></tr>
<tr class="separator:ga7f57ec0156d33b4aa98e259d2e2062db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeef6e55681664df29b31edec51ea034d"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gaeef6e55681664df29b31edec51ea034d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html">bound_volatile_mem_functor0</a><br class="typebreak"/>
&lt; T_return, T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gaeef6e55681664df29b31edec51ea034d">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)() volatile)</td></tr>
<tr class="memdesc:gaeef6e55681664df29b31edec51ea034d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html" title="bound_volatile_mem_functor0 encapsulates a volatile method with 0 arguments and an object instance...">sigc::bound_volatile_mem_functor0</a> which encapsulates a method and an object instance.  <a href="#gaeef6e55681664df29b31edec51ea034d">More...</a><br/></td></tr>
<tr class="separator:gaeef6e55681664df29b31edec51ea034d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0df7af9f32990cc624c4bb60782b4f78"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga0df7af9f32990cc624c4bb60782b4f78"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html">bound_volatile_mem_functor1</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga0df7af9f32990cc624c4bb60782b4f78">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1) volatile)</td></tr>
<tr class="memdesc:ga0df7af9f32990cc624c4bb60782b4f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html" title="bound_volatile_mem_functor1 encapsulates a volatile method with 1 arguments and an object instance...">sigc::bound_volatile_mem_functor1</a> which encapsulates a method and an object instance.  <a href="#ga0df7af9f32990cc624c4bb60782b4f78">More...</a><br/></td></tr>
<tr class="separator:ga0df7af9f32990cc624c4bb60782b4f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7de39a04dfc6d37b2d12a25cdccfbe95"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga7de39a04dfc6d37b2d12a25cdccfbe95"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html">bound_volatile_mem_functor1</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga7de39a04dfc6d37b2d12a25cdccfbe95">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1) volatile)</td></tr>
<tr class="memdesc:ga7de39a04dfc6d37b2d12a25cdccfbe95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html" title="bound_volatile_mem_functor1 encapsulates a volatile method with 1 arguments and an object instance...">sigc::bound_volatile_mem_functor1</a> which encapsulates a method and an object instance.  <a href="#ga7de39a04dfc6d37b2d12a25cdccfbe95">More...</a><br/></td></tr>
<tr class="separator:ga7de39a04dfc6d37b2d12a25cdccfbe95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga118b2610268701be95cdc6fddb7bab3b"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga118b2610268701be95cdc6fddb7bab3b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html">bound_volatile_mem_functor2</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga118b2610268701be95cdc6fddb7bab3b">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2) volatile)</td></tr>
<tr class="memdesc:ga118b2610268701be95cdc6fddb7bab3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html" title="bound_volatile_mem_functor2 encapsulates a volatile method with 2 arguments and an object instance...">sigc::bound_volatile_mem_functor2</a> which encapsulates a method and an object instance.  <a href="#ga118b2610268701be95cdc6fddb7bab3b">More...</a><br/></td></tr>
<tr class="separator:ga118b2610268701be95cdc6fddb7bab3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1add5c927b51b935b4f2d40558079fa"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gab1add5c927b51b935b4f2d40558079fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html">bound_volatile_mem_functor2</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gab1add5c927b51b935b4f2d40558079fa">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2) volatile)</td></tr>
<tr class="memdesc:gab1add5c927b51b935b4f2d40558079fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html" title="bound_volatile_mem_functor2 encapsulates a volatile method with 2 arguments and an object instance...">sigc::bound_volatile_mem_functor2</a> which encapsulates a method and an object instance.  <a href="#gab1add5c927b51b935b4f2d40558079fa">More...</a><br/></td></tr>
<tr class="separator:gab1add5c927b51b935b4f2d40558079fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb6bd4518e0f0c524dba13a6cbb2e319"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gaeb6bd4518e0f0c524dba13a6cbb2e319"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html">bound_volatile_mem_functor3</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gaeb6bd4518e0f0c524dba13a6cbb2e319">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3) volatile)</td></tr>
<tr class="memdesc:gaeb6bd4518e0f0c524dba13a6cbb2e319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html" title="bound_volatile_mem_functor3 encapsulates a volatile method with 3 arguments and an object instance...">sigc::bound_volatile_mem_functor3</a> which encapsulates a method and an object instance.  <a href="#gaeb6bd4518e0f0c524dba13a6cbb2e319">More...</a><br/></td></tr>
<tr class="separator:gaeb6bd4518e0f0c524dba13a6cbb2e319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f1aa3b60c0d2d8b2470bba0b2b36023"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga1f1aa3b60c0d2d8b2470bba0b2b36023"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html">bound_volatile_mem_functor3</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga1f1aa3b60c0d2d8b2470bba0b2b36023">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3) volatile)</td></tr>
<tr class="memdesc:ga1f1aa3b60c0d2d8b2470bba0b2b36023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html" title="bound_volatile_mem_functor3 encapsulates a volatile method with 3 arguments and an object instance...">sigc::bound_volatile_mem_functor3</a> which encapsulates a method and an object instance.  <a href="#ga1f1aa3b60c0d2d8b2470bba0b2b36023">More...</a><br/></td></tr>
<tr class="separator:ga1f1aa3b60c0d2d8b2470bba0b2b36023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02c906c95895c58e39ee301bb1577994"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga02c906c95895c58e39ee301bb1577994"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html">bound_volatile_mem_functor4</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga02c906c95895c58e39ee301bb1577994">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) volatile)</td></tr>
<tr class="memdesc:ga02c906c95895c58e39ee301bb1577994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html" title="bound_volatile_mem_functor4 encapsulates a volatile method with 4 arguments and an object instance...">sigc::bound_volatile_mem_functor4</a> which encapsulates a method and an object instance.  <a href="#ga02c906c95895c58e39ee301bb1577994">More...</a><br/></td></tr>
<tr class="separator:ga02c906c95895c58e39ee301bb1577994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga481ef34d8423d26e8ff0a1916cd295d5"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga481ef34d8423d26e8ff0a1916cd295d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html">bound_volatile_mem_functor4</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga481ef34d8423d26e8ff0a1916cd295d5">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) volatile)</td></tr>
<tr class="memdesc:ga481ef34d8423d26e8ff0a1916cd295d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html" title="bound_volatile_mem_functor4 encapsulates a volatile method with 4 arguments and an object instance...">sigc::bound_volatile_mem_functor4</a> which encapsulates a method and an object instance.  <a href="#ga481ef34d8423d26e8ff0a1916cd295d5">More...</a><br/></td></tr>
<tr class="separator:ga481ef34d8423d26e8ff0a1916cd295d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab138ae1a340be983166b69872826b37d"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gab138ae1a340be983166b69872826b37d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html">bound_volatile_mem_functor5</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gab138ae1a340be983166b69872826b37d">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) volatile)</td></tr>
<tr class="memdesc:gab138ae1a340be983166b69872826b37d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html" title="bound_volatile_mem_functor5 encapsulates a volatile method with 5 arguments and an object instance...">sigc::bound_volatile_mem_functor5</a> which encapsulates a method and an object instance.  <a href="#gab138ae1a340be983166b69872826b37d">More...</a><br/></td></tr>
<tr class="separator:gab138ae1a340be983166b69872826b37d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09fb13b1684ec7c092ffef695dbb261a"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga09fb13b1684ec7c092ffef695dbb261a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html">bound_volatile_mem_functor5</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga09fb13b1684ec7c092ffef695dbb261a">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) volatile)</td></tr>
<tr class="memdesc:ga09fb13b1684ec7c092ffef695dbb261a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html" title="bound_volatile_mem_functor5 encapsulates a volatile method with 5 arguments and an object instance...">sigc::bound_volatile_mem_functor5</a> which encapsulates a method and an object instance.  <a href="#ga09fb13b1684ec7c092ffef695dbb261a">More...</a><br/></td></tr>
<tr class="separator:ga09fb13b1684ec7c092ffef695dbb261a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e3841c4844715d2f2d832ed506f028f"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga3e3841c4844715d2f2d832ed506f028f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html">bound_volatile_mem_functor6</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga3e3841c4844715d2f2d832ed506f028f">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) volatile)</td></tr>
<tr class="memdesc:ga3e3841c4844715d2f2d832ed506f028f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html" title="bound_volatile_mem_functor6 encapsulates a volatile method with 6 arguments and an object instance...">sigc::bound_volatile_mem_functor6</a> which encapsulates a method and an object instance.  <a href="#ga3e3841c4844715d2f2d832ed506f028f">More...</a><br/></td></tr>
<tr class="separator:ga3e3841c4844715d2f2d832ed506f028f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d9b992d69123a524b6c70c458ad0d40"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga0d9b992d69123a524b6c70c458ad0d40"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html">bound_volatile_mem_functor6</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga0d9b992d69123a524b6c70c458ad0d40">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) volatile)</td></tr>
<tr class="memdesc:ga0d9b992d69123a524b6c70c458ad0d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html" title="bound_volatile_mem_functor6 encapsulates a volatile method with 6 arguments and an object instance...">sigc::bound_volatile_mem_functor6</a> which encapsulates a method and an object instance.  <a href="#ga0d9b992d69123a524b6c70c458ad0d40">More...</a><br/></td></tr>
<tr class="separator:ga0d9b992d69123a524b6c70c458ad0d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea5a2ace2699b8d1ffe93585e335548d"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gaea5a2ace2699b8d1ffe93585e335548d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html">bound_volatile_mem_functor7</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gaea5a2ace2699b8d1ffe93585e335548d">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) volatile)</td></tr>
<tr class="memdesc:gaea5a2ace2699b8d1ffe93585e335548d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html" title="bound_volatile_mem_functor7 encapsulates a volatile method with 7 arguments and an object instance...">sigc::bound_volatile_mem_functor7</a> which encapsulates a method and an object instance.  <a href="#gaea5a2ace2699b8d1ffe93585e335548d">More...</a><br/></td></tr>
<tr class="separator:gaea5a2ace2699b8d1ffe93585e335548d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dcdaf235baa50049e6088d246853037"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga5dcdaf235baa50049e6088d246853037"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html">bound_volatile_mem_functor7</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga5dcdaf235baa50049e6088d246853037">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) volatile)</td></tr>
<tr class="memdesc:ga5dcdaf235baa50049e6088d246853037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html" title="bound_volatile_mem_functor7 encapsulates a volatile method with 7 arguments and an object instance...">sigc::bound_volatile_mem_functor7</a> which encapsulates a method and an object instance.  <a href="#ga5dcdaf235baa50049e6088d246853037">More...</a><br/></td></tr>
<tr class="separator:ga5dcdaf235baa50049e6088d246853037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f57ec0156d33b4aa98e259d2e2062db"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga7f57ec0156d33b4aa98e259d2e2062db"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">bound_const_volatile_mem_functor0</a><br class="typebreak"/>
&lt; T_return, T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga7f57ec0156d33b4aa98e259d2e2062db">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)() const volatile)</td></tr>
<tr class="memdesc:ga7f57ec0156d33b4aa98e259d2e2062db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html" title="bound_const_volatile_mem_functor0 encapsulates a const volatile method with 0 arguments and an object...">sigc::bound_const_volatile_mem_functor0</a> which encapsulates a method and an object instance.  <a href="#ga7f57ec0156d33b4aa98e259d2e2062db">More...</a><br/></td></tr>
<tr class="separator:ga7f57ec0156d33b4aa98e259d2e2062db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeef6e55681664df29b31edec51ea034d"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gaeef6e55681664df29b31edec51ea034d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">bound_const_volatile_mem_functor0</a><br class="typebreak"/>
&lt; T_return, T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gaeef6e55681664df29b31edec51ea034d">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)() const volatile)</td></tr>
<tr class="memdesc:gaeef6e55681664df29b31edec51ea034d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html" title="bound_const_volatile_mem_functor0 encapsulates a const volatile method with 0 arguments and an object...">sigc::bound_const_volatile_mem_functor0</a> which encapsulates a method and an object instance.  <a href="#gaeef6e55681664df29b31edec51ea034d">More...</a><br/></td></tr>
<tr class="separator:gaeef6e55681664df29b31edec51ea034d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0df7af9f32990cc624c4bb60782b4f78"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga0df7af9f32990cc624c4bb60782b4f78"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">bound_const_volatile_mem_functor1</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga0df7af9f32990cc624c4bb60782b4f78">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1) const volatile)</td></tr>
<tr class="memdesc:ga0df7af9f32990cc624c4bb60782b4f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html" title="bound_const_volatile_mem_functor1 encapsulates a const volatile method with 1 arguments and an object...">sigc::bound_const_volatile_mem_functor1</a> which encapsulates a method and an object instance.  <a href="#ga0df7af9f32990cc624c4bb60782b4f78">More...</a><br/></td></tr>
<tr class="separator:ga0df7af9f32990cc624c4bb60782b4f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7de39a04dfc6d37b2d12a25cdccfbe95"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga7de39a04dfc6d37b2d12a25cdccfbe95"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">bound_const_volatile_mem_functor1</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga7de39a04dfc6d37b2d12a25cdccfbe95">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1) const volatile)</td></tr>
<tr class="memdesc:ga7de39a04dfc6d37b2d12a25cdccfbe95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html" title="bound_const_volatile_mem_functor1 encapsulates a const volatile method with 1 arguments and an object...">sigc::bound_const_volatile_mem_functor1</a> which encapsulates a method and an object instance.  <a href="#ga7de39a04dfc6d37b2d12a25cdccfbe95">More...</a><br/></td></tr>
<tr class="separator:ga7de39a04dfc6d37b2d12a25cdccfbe95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga118b2610268701be95cdc6fddb7bab3b"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga118b2610268701be95cdc6fddb7bab3b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">bound_const_volatile_mem_functor2</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga118b2610268701be95cdc6fddb7bab3b">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2) const volatile)</td></tr>
<tr class="memdesc:ga118b2610268701be95cdc6fddb7bab3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html" title="bound_const_volatile_mem_functor2 encapsulates a const volatile method with 2 arguments and an object...">sigc::bound_const_volatile_mem_functor2</a> which encapsulates a method and an object instance.  <a href="#ga118b2610268701be95cdc6fddb7bab3b">More...</a><br/></td></tr>
<tr class="separator:ga118b2610268701be95cdc6fddb7bab3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1add5c927b51b935b4f2d40558079fa"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gab1add5c927b51b935b4f2d40558079fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">bound_const_volatile_mem_functor2</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gab1add5c927b51b935b4f2d40558079fa">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2) const volatile)</td></tr>
<tr class="memdesc:gab1add5c927b51b935b4f2d40558079fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html" title="bound_const_volatile_mem_functor2 encapsulates a const volatile method with 2 arguments and an object...">sigc::bound_const_volatile_mem_functor2</a> which encapsulates a method and an object instance.  <a href="#gab1add5c927b51b935b4f2d40558079fa">More...</a><br/></td></tr>
<tr class="separator:gab1add5c927b51b935b4f2d40558079fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb6bd4518e0f0c524dba13a6cbb2e319"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gaeb6bd4518e0f0c524dba13a6cbb2e319"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">bound_const_volatile_mem_functor3</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gaeb6bd4518e0f0c524dba13a6cbb2e319">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3) const volatile)</td></tr>
<tr class="memdesc:gaeb6bd4518e0f0c524dba13a6cbb2e319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html" title="bound_const_volatile_mem_functor3 encapsulates a const volatile method with 3 arguments and an object...">sigc::bound_const_volatile_mem_functor3</a> which encapsulates a method and an object instance.  <a href="#gaeb6bd4518e0f0c524dba13a6cbb2e319">More...</a><br/></td></tr>
<tr class="separator:gaeb6bd4518e0f0c524dba13a6cbb2e319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f1aa3b60c0d2d8b2470bba0b2b36023"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga1f1aa3b60c0d2d8b2470bba0b2b36023"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">bound_const_volatile_mem_functor3</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga1f1aa3b60c0d2d8b2470bba0b2b36023">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3) const volatile)</td></tr>
<tr class="memdesc:ga1f1aa3b60c0d2d8b2470bba0b2b36023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html" title="bound_const_volatile_mem_functor3 encapsulates a const volatile method with 3 arguments and an object...">sigc::bound_const_volatile_mem_functor3</a> which encapsulates a method and an object instance.  <a href="#ga1f1aa3b60c0d2d8b2470bba0b2b36023">More...</a><br/></td></tr>
<tr class="separator:ga1f1aa3b60c0d2d8b2470bba0b2b36023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02c906c95895c58e39ee301bb1577994"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga02c906c95895c58e39ee301bb1577994"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">bound_const_volatile_mem_functor4</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga02c906c95895c58e39ee301bb1577994">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const volatile)</td></tr>
<tr class="memdesc:ga02c906c95895c58e39ee301bb1577994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html" title="bound_const_volatile_mem_functor4 encapsulates a const volatile method with 4 arguments and an object...">sigc::bound_const_volatile_mem_functor4</a> which encapsulates a method and an object instance.  <a href="#ga02c906c95895c58e39ee301bb1577994">More...</a><br/></td></tr>
<tr class="separator:ga02c906c95895c58e39ee301bb1577994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga481ef34d8423d26e8ff0a1916cd295d5"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga481ef34d8423d26e8ff0a1916cd295d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">bound_const_volatile_mem_functor4</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga481ef34d8423d26e8ff0a1916cd295d5">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const volatile)</td></tr>
<tr class="memdesc:ga481ef34d8423d26e8ff0a1916cd295d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html" title="bound_const_volatile_mem_functor4 encapsulates a const volatile method with 4 arguments and an object...">sigc::bound_const_volatile_mem_functor4</a> which encapsulates a method and an object instance.  <a href="#ga481ef34d8423d26e8ff0a1916cd295d5">More...</a><br/></td></tr>
<tr class="separator:ga481ef34d8423d26e8ff0a1916cd295d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab138ae1a340be983166b69872826b37d"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gab138ae1a340be983166b69872826b37d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">bound_const_volatile_mem_functor5</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gab138ae1a340be983166b69872826b37d">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const volatile)</td></tr>
<tr class="memdesc:gab138ae1a340be983166b69872826b37d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html" title="bound_const_volatile_mem_functor5 encapsulates a const volatile method with 5 arguments and an object...">sigc::bound_const_volatile_mem_functor5</a> which encapsulates a method and an object instance.  <a href="#gab138ae1a340be983166b69872826b37d">More...</a><br/></td></tr>
<tr class="separator:gab138ae1a340be983166b69872826b37d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09fb13b1684ec7c092ffef695dbb261a"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga09fb13b1684ec7c092ffef695dbb261a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">bound_const_volatile_mem_functor5</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga09fb13b1684ec7c092ffef695dbb261a">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const volatile)</td></tr>
<tr class="memdesc:ga09fb13b1684ec7c092ffef695dbb261a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html" title="bound_const_volatile_mem_functor5 encapsulates a const volatile method with 5 arguments and an object...">sigc::bound_const_volatile_mem_functor5</a> which encapsulates a method and an object instance.  <a href="#ga09fb13b1684ec7c092ffef695dbb261a">More...</a><br/></td></tr>
<tr class="separator:ga09fb13b1684ec7c092ffef695dbb261a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e3841c4844715d2f2d832ed506f028f"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga3e3841c4844715d2f2d832ed506f028f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">bound_const_volatile_mem_functor6</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga3e3841c4844715d2f2d832ed506f028f">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const volatile)</td></tr>
<tr class="memdesc:ga3e3841c4844715d2f2d832ed506f028f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html" title="bound_const_volatile_mem_functor6 encapsulates a const volatile method with 6 arguments and an object...">sigc::bound_const_volatile_mem_functor6</a> which encapsulates a method and an object instance.  <a href="#ga3e3841c4844715d2f2d832ed506f028f">More...</a><br/></td></tr>
<tr class="separator:ga3e3841c4844715d2f2d832ed506f028f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d9b992d69123a524b6c70c458ad0d40"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga0d9b992d69123a524b6c70c458ad0d40"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">bound_const_volatile_mem_functor6</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga0d9b992d69123a524b6c70c458ad0d40">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const volatile)</td></tr>
<tr class="memdesc:ga0d9b992d69123a524b6c70c458ad0d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html" title="bound_const_volatile_mem_functor6 encapsulates a const volatile method with 6 arguments and an object...">sigc::bound_const_volatile_mem_functor6</a> which encapsulates a method and an object instance.  <a href="#ga0d9b992d69123a524b6c70c458ad0d40">More...</a><br/></td></tr>
<tr class="separator:ga0d9b992d69123a524b6c70c458ad0d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea5a2ace2699b8d1ffe93585e335548d"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gaea5a2ace2699b8d1ffe93585e335548d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">bound_const_volatile_mem_functor7</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gaea5a2ace2699b8d1ffe93585e335548d">mem_fun</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const volatile)</td></tr>
<tr class="memdesc:gaea5a2ace2699b8d1ffe93585e335548d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html" title="bound_const_volatile_mem_functor7 encapsulates a const volatile method with 7 arguments and an object...">sigc::bound_const_volatile_mem_functor7</a> which encapsulates a method and an object instance.  <a href="#gaea5a2ace2699b8d1ffe93585e335548d">More...</a><br/></td></tr>
<tr class="separator:gaea5a2ace2699b8d1ffe93585e335548d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dcdaf235baa50049e6088d246853037"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga5dcdaf235baa50049e6088d246853037"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">bound_const_volatile_mem_functor7</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga5dcdaf235baa50049e6088d246853037">mem_fun</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const volatile)</td></tr>
<tr class="memdesc:ga5dcdaf235baa50049e6088d246853037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html" title="bound_const_volatile_mem_functor7 encapsulates a const volatile method with 7 arguments and an object...">sigc::bound_const_volatile_mem_functor7</a> which encapsulates a method and an object instance.  <a href="#ga5dcdaf235baa50049e6088d246853037">More...</a><br/></td></tr>
<tr class="separator:ga5dcdaf235baa50049e6088d246853037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga765b35689a909fbc2a627be8256c5b1f"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga765b35689a909fbc2a627be8256c5b1f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor0.html">mem_functor0</a>&lt; T_return, T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga765b35689a909fbc2a627be8256c5b1f">mem_fun0</a> (T_return(T_obj::* _A_func)())</td></tr>
<tr class="memdesc:ga765b35689a909fbc2a627be8256c5b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor0.html" title="mem_functor0 wraps methods with 0 argument(s). ">sigc::mem_functor0</a> which wraps a method.  <a href="group__mem__fun.html#ga765b35689a909fbc2a627be8256c5b1f">More...</a><br/></td></tr>
<tr class="separator:ga765b35689a909fbc2a627be8256c5b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga765b35689a909fbc2a627be8256c5b1f"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga765b35689a909fbc2a627be8256c5b1f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1const__mem__functor0.html">const_mem_functor0</a>&lt; T_return, <br class="typebreak"/>
T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga765b35689a909fbc2a627be8256c5b1f">mem_fun0</a> (T_return(T_obj::* _A_func)() const)</td></tr>
<tr class="memdesc:ga765b35689a909fbc2a627be8256c5b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor0.html" title="const_mem_functor0 wraps const methods with 0 argument(s). ">sigc::const_mem_functor0</a> which wraps a const method.  <a href="#ga765b35689a909fbc2a627be8256c5b1f">More...</a><br/></td></tr>
<tr class="separator:ga765b35689a909fbc2a627be8256c5b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga765b35689a909fbc2a627be8256c5b1f"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga765b35689a909fbc2a627be8256c5b1f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1volatile__mem__functor0.html">volatile_mem_functor0</a><br class="typebreak"/>
&lt; T_return, T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga765b35689a909fbc2a627be8256c5b1f">mem_fun0</a> (T_return(T_obj::* _A_func)() volatile)</td></tr>
<tr class="memdesc:ga765b35689a909fbc2a627be8256c5b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor0.html" title="volatile_mem_functor0 wraps volatile methods with 0 argument(s). ">sigc::volatile_mem_functor0</a> which wraps a volatile method.  <a href="#ga765b35689a909fbc2a627be8256c5b1f">More...</a><br/></td></tr>
<tr class="separator:ga765b35689a909fbc2a627be8256c5b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga765b35689a909fbc2a627be8256c5b1f"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga765b35689a909fbc2a627be8256c5b1f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1const__volatile__mem__functor0.html">const_volatile_mem_functor0</a><br class="typebreak"/>
&lt; T_return, T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga765b35689a909fbc2a627be8256c5b1f">mem_fun0</a> (T_return(T_obj::* _A_func)() const volatile)</td></tr>
<tr class="memdesc:ga765b35689a909fbc2a627be8256c5b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor0.html" title="const_volatile_mem_functor0 wraps const volatile methods with 0 argument(s). ">sigc::const_volatile_mem_functor0</a> which wraps a const volatile method.  <a href="#ga765b35689a909fbc2a627be8256c5b1f">More...</a><br/></td></tr>
<tr class="separator:ga765b35689a909fbc2a627be8256c5b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae03d0b73b85e85d2ad8bc43b19b855e3"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gae03d0b73b85e85d2ad8bc43b19b855e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor0.html">bound_mem_functor0</a>&lt; T_return, <br class="typebreak"/>
T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gae03d0b73b85e85d2ad8bc43b19b855e3">mem_fun0</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)())</td></tr>
<tr class="memdesc:gae03d0b73b85e85d2ad8bc43b19b855e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor0.html" title="bound_mem_functor0 encapsulates a method with 0 arguments and an object instance. ...">sigc::bound_mem_functor0</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#gae03d0b73b85e85d2ad8bc43b19b855e3">More...</a><br/></td></tr>
<tr class="separator:gae03d0b73b85e85d2ad8bc43b19b855e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf71277763f14050e2d270fcf3ea41dc9"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gaf71277763f14050e2d270fcf3ea41dc9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor0.html">bound_mem_functor0</a>&lt; T_return, <br class="typebreak"/>
T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaf71277763f14050e2d270fcf3ea41dc9">mem_fun0</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)())</td></tr>
<tr class="memdesc:gaf71277763f14050e2d270fcf3ea41dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor0.html" title="bound_mem_functor0 encapsulates a method with 0 arguments and an object instance. ...">sigc::bound_mem_functor0</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#gaf71277763f14050e2d270fcf3ea41dc9">More...</a><br/></td></tr>
<tr class="separator:gaf71277763f14050e2d270fcf3ea41dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae03d0b73b85e85d2ad8bc43b19b855e3"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gae03d0b73b85e85d2ad8bc43b19b855e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor0.html">bound_const_mem_functor0</a><br class="typebreak"/>
&lt; T_return, T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gae03d0b73b85e85d2ad8bc43b19b855e3">mem_fun0</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)() const)</td></tr>
<tr class="memdesc:gae03d0b73b85e85d2ad8bc43b19b855e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor0.html" title="bound_const_mem_functor0 encapsulates a const method with 0 arguments and an object instance...">sigc::bound_const_mem_functor0</a> which encapsulates a method and an object instance.  <a href="#gae03d0b73b85e85d2ad8bc43b19b855e3">More...</a><br/></td></tr>
<tr class="separator:gae03d0b73b85e85d2ad8bc43b19b855e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf71277763f14050e2d270fcf3ea41dc9"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gaf71277763f14050e2d270fcf3ea41dc9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor0.html">bound_const_mem_functor0</a><br class="typebreak"/>
&lt; T_return, T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gaf71277763f14050e2d270fcf3ea41dc9">mem_fun0</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)() const)</td></tr>
<tr class="memdesc:gaf71277763f14050e2d270fcf3ea41dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor0.html" title="bound_const_mem_functor0 encapsulates a const method with 0 arguments and an object instance...">sigc::bound_const_mem_functor0</a> which encapsulates a method and an object instance.  <a href="#gaf71277763f14050e2d270fcf3ea41dc9">More...</a><br/></td></tr>
<tr class="separator:gaf71277763f14050e2d270fcf3ea41dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae03d0b73b85e85d2ad8bc43b19b855e3"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gae03d0b73b85e85d2ad8bc43b19b855e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html">bound_volatile_mem_functor0</a><br class="typebreak"/>
&lt; T_return, T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gae03d0b73b85e85d2ad8bc43b19b855e3">mem_fun0</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)() volatile)</td></tr>
<tr class="memdesc:gae03d0b73b85e85d2ad8bc43b19b855e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html" title="bound_volatile_mem_functor0 encapsulates a volatile method with 0 arguments and an object instance...">sigc::bound_volatile_mem_functor0</a> which encapsulates a method and an object instance.  <a href="#gae03d0b73b85e85d2ad8bc43b19b855e3">More...</a><br/></td></tr>
<tr class="separator:gae03d0b73b85e85d2ad8bc43b19b855e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf71277763f14050e2d270fcf3ea41dc9"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gaf71277763f14050e2d270fcf3ea41dc9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html">bound_volatile_mem_functor0</a><br class="typebreak"/>
&lt; T_return, T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gaf71277763f14050e2d270fcf3ea41dc9">mem_fun0</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)() volatile)</td></tr>
<tr class="memdesc:gaf71277763f14050e2d270fcf3ea41dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html" title="bound_volatile_mem_functor0 encapsulates a volatile method with 0 arguments and an object instance...">sigc::bound_volatile_mem_functor0</a> which encapsulates a method and an object instance.  <a href="#gaf71277763f14050e2d270fcf3ea41dc9">More...</a><br/></td></tr>
<tr class="separator:gaf71277763f14050e2d270fcf3ea41dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae03d0b73b85e85d2ad8bc43b19b855e3"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gae03d0b73b85e85d2ad8bc43b19b855e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">bound_const_volatile_mem_functor0</a><br class="typebreak"/>
&lt; T_return, T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gae03d0b73b85e85d2ad8bc43b19b855e3">mem_fun0</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)() const volatile)</td></tr>
<tr class="memdesc:gae03d0b73b85e85d2ad8bc43b19b855e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html" title="bound_const_volatile_mem_functor0 encapsulates a const volatile method with 0 arguments and an object...">sigc::bound_const_volatile_mem_functor0</a> which encapsulates a method and an object instance.  <a href="#gae03d0b73b85e85d2ad8bc43b19b855e3">More...</a><br/></td></tr>
<tr class="separator:gae03d0b73b85e85d2ad8bc43b19b855e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf71277763f14050e2d270fcf3ea41dc9"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gaf71277763f14050e2d270fcf3ea41dc9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">bound_const_volatile_mem_functor0</a><br class="typebreak"/>
&lt; T_return, T_obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gaf71277763f14050e2d270fcf3ea41dc9">mem_fun0</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)() const volatile)</td></tr>
<tr class="memdesc:gaf71277763f14050e2d270fcf3ea41dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html" title="bound_const_volatile_mem_functor0 encapsulates a const volatile method with 0 arguments and an object...">sigc::bound_const_volatile_mem_functor0</a> which encapsulates a method and an object instance.  <a href="#gaf71277763f14050e2d270fcf3ea41dc9">More...</a><br/></td></tr>
<tr class="separator:gaf71277763f14050e2d270fcf3ea41dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0bebf0d8a2d36d93746c23d9eea668d"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gae0bebf0d8a2d36d93746c23d9eea668d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor1.html">mem_functor1</a>&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gae0bebf0d8a2d36d93746c23d9eea668d">mem_fun1</a> (T_return(T_obj::* _A_func)(T_arg1))</td></tr>
<tr class="memdesc:gae0bebf0d8a2d36d93746c23d9eea668d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor1.html" title="mem_functor1 wraps methods with 1 argument(s). ">sigc::mem_functor1</a> which wraps a method.  <a href="group__mem__fun.html#gae0bebf0d8a2d36d93746c23d9eea668d">More...</a><br/></td></tr>
<tr class="separator:gae0bebf0d8a2d36d93746c23d9eea668d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0bebf0d8a2d36d93746c23d9eea668d"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gae0bebf0d8a2d36d93746c23d9eea668d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1const__mem__functor1.html">const_mem_functor1</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gae0bebf0d8a2d36d93746c23d9eea668d">mem_fun1</a> (T_return(T_obj::* _A_func)(T_arg1) const)</td></tr>
<tr class="memdesc:gae0bebf0d8a2d36d93746c23d9eea668d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor1.html" title="const_mem_functor1 wraps const methods with 1 argument(s). ">sigc::const_mem_functor1</a> which wraps a const method.  <a href="#gae0bebf0d8a2d36d93746c23d9eea668d">More...</a><br/></td></tr>
<tr class="separator:gae0bebf0d8a2d36d93746c23d9eea668d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0bebf0d8a2d36d93746c23d9eea668d"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gae0bebf0d8a2d36d93746c23d9eea668d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1volatile__mem__functor1.html">volatile_mem_functor1</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gae0bebf0d8a2d36d93746c23d9eea668d">mem_fun1</a> (T_return(T_obj::* _A_func)(T_arg1) volatile)</td></tr>
<tr class="memdesc:gae0bebf0d8a2d36d93746c23d9eea668d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor1.html" title="volatile_mem_functor1 wraps volatile methods with 1 argument(s). ">sigc::volatile_mem_functor1</a> which wraps a volatile method.  <a href="#gae0bebf0d8a2d36d93746c23d9eea668d">More...</a><br/></td></tr>
<tr class="separator:gae0bebf0d8a2d36d93746c23d9eea668d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0bebf0d8a2d36d93746c23d9eea668d"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gae0bebf0d8a2d36d93746c23d9eea668d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1const__volatile__mem__functor1.html">const_volatile_mem_functor1</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gae0bebf0d8a2d36d93746c23d9eea668d">mem_fun1</a> (T_return(T_obj::* _A_func)(T_arg1) const volatile)</td></tr>
<tr class="memdesc:gae0bebf0d8a2d36d93746c23d9eea668d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor1.html" title="const_volatile_mem_functor1 wraps const volatile methods with 1 argument(s). ">sigc::const_volatile_mem_functor1</a> which wraps a const volatile method.  <a href="#gae0bebf0d8a2d36d93746c23d9eea668d">More...</a><br/></td></tr>
<tr class="separator:gae0bebf0d8a2d36d93746c23d9eea668d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dd8d2ed97310dbf4fa394999f0be7b7"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga3dd8d2ed97310dbf4fa394999f0be7b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor1.html">bound_mem_functor1</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga3dd8d2ed97310dbf4fa394999f0be7b7">mem_fun1</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1))</td></tr>
<tr class="memdesc:ga3dd8d2ed97310dbf4fa394999f0be7b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor1.html" title="bound_mem_functor1 encapsulates a method with 1 arguments and an object instance. ...">sigc::bound_mem_functor1</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#ga3dd8d2ed97310dbf4fa394999f0be7b7">More...</a><br/></td></tr>
<tr class="separator:ga3dd8d2ed97310dbf4fa394999f0be7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaade596a4dacfd1429039525bb9f399d0"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gaade596a4dacfd1429039525bb9f399d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor1.html">bound_mem_functor1</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaade596a4dacfd1429039525bb9f399d0">mem_fun1</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1))</td></tr>
<tr class="memdesc:gaade596a4dacfd1429039525bb9f399d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor1.html" title="bound_mem_functor1 encapsulates a method with 1 arguments and an object instance. ...">sigc::bound_mem_functor1</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#gaade596a4dacfd1429039525bb9f399d0">More...</a><br/></td></tr>
<tr class="separator:gaade596a4dacfd1429039525bb9f399d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dd8d2ed97310dbf4fa394999f0be7b7"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga3dd8d2ed97310dbf4fa394999f0be7b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor1.html">bound_const_mem_functor1</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga3dd8d2ed97310dbf4fa394999f0be7b7">mem_fun1</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1) const)</td></tr>
<tr class="memdesc:ga3dd8d2ed97310dbf4fa394999f0be7b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor1.html" title="bound_const_mem_functor1 encapsulates a const method with 1 arguments and an object instance...">sigc::bound_const_mem_functor1</a> which encapsulates a method and an object instance.  <a href="#ga3dd8d2ed97310dbf4fa394999f0be7b7">More...</a><br/></td></tr>
<tr class="separator:ga3dd8d2ed97310dbf4fa394999f0be7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaade596a4dacfd1429039525bb9f399d0"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gaade596a4dacfd1429039525bb9f399d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor1.html">bound_const_mem_functor1</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gaade596a4dacfd1429039525bb9f399d0">mem_fun1</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1) const)</td></tr>
<tr class="memdesc:gaade596a4dacfd1429039525bb9f399d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor1.html" title="bound_const_mem_functor1 encapsulates a const method with 1 arguments and an object instance...">sigc::bound_const_mem_functor1</a> which encapsulates a method and an object instance.  <a href="#gaade596a4dacfd1429039525bb9f399d0">More...</a><br/></td></tr>
<tr class="separator:gaade596a4dacfd1429039525bb9f399d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dd8d2ed97310dbf4fa394999f0be7b7"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga3dd8d2ed97310dbf4fa394999f0be7b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html">bound_volatile_mem_functor1</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga3dd8d2ed97310dbf4fa394999f0be7b7">mem_fun1</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1) volatile)</td></tr>
<tr class="memdesc:ga3dd8d2ed97310dbf4fa394999f0be7b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html" title="bound_volatile_mem_functor1 encapsulates a volatile method with 1 arguments and an object instance...">sigc::bound_volatile_mem_functor1</a> which encapsulates a method and an object instance.  <a href="#ga3dd8d2ed97310dbf4fa394999f0be7b7">More...</a><br/></td></tr>
<tr class="separator:ga3dd8d2ed97310dbf4fa394999f0be7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaade596a4dacfd1429039525bb9f399d0"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gaade596a4dacfd1429039525bb9f399d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html">bound_volatile_mem_functor1</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gaade596a4dacfd1429039525bb9f399d0">mem_fun1</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1) volatile)</td></tr>
<tr class="memdesc:gaade596a4dacfd1429039525bb9f399d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html" title="bound_volatile_mem_functor1 encapsulates a volatile method with 1 arguments and an object instance...">sigc::bound_volatile_mem_functor1</a> which encapsulates a method and an object instance.  <a href="#gaade596a4dacfd1429039525bb9f399d0">More...</a><br/></td></tr>
<tr class="separator:gaade596a4dacfd1429039525bb9f399d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dd8d2ed97310dbf4fa394999f0be7b7"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga3dd8d2ed97310dbf4fa394999f0be7b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">bound_const_volatile_mem_functor1</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga3dd8d2ed97310dbf4fa394999f0be7b7">mem_fun1</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1) const volatile)</td></tr>
<tr class="memdesc:ga3dd8d2ed97310dbf4fa394999f0be7b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html" title="bound_const_volatile_mem_functor1 encapsulates a const volatile method with 1 arguments and an object...">sigc::bound_const_volatile_mem_functor1</a> which encapsulates a method and an object instance.  <a href="#ga3dd8d2ed97310dbf4fa394999f0be7b7">More...</a><br/></td></tr>
<tr class="separator:ga3dd8d2ed97310dbf4fa394999f0be7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaade596a4dacfd1429039525bb9f399d0"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gaade596a4dacfd1429039525bb9f399d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">bound_const_volatile_mem_functor1</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gaade596a4dacfd1429039525bb9f399d0">mem_fun1</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1) const volatile)</td></tr>
<tr class="memdesc:gaade596a4dacfd1429039525bb9f399d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html" title="bound_const_volatile_mem_functor1 encapsulates a const volatile method with 1 arguments and an object...">sigc::bound_const_volatile_mem_functor1</a> which encapsulates a method and an object instance.  <a href="#gaade596a4dacfd1429039525bb9f399d0">More...</a><br/></td></tr>
<tr class="separator:gaade596a4dacfd1429039525bb9f399d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab76f41aeada332b353b6fe2e96008831"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gab76f41aeada332b353b6fe2e96008831"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor2.html">mem_functor2</a>&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gab76f41aeada332b353b6fe2e96008831">mem_fun2</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2))</td></tr>
<tr class="memdesc:gab76f41aeada332b353b6fe2e96008831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor2.html" title="mem_functor2 wraps methods with 2 argument(s). ">sigc::mem_functor2</a> which wraps a method.  <a href="group__mem__fun.html#gab76f41aeada332b353b6fe2e96008831">More...</a><br/></td></tr>
<tr class="separator:gab76f41aeada332b353b6fe2e96008831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab76f41aeada332b353b6fe2e96008831"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gab76f41aeada332b353b6fe2e96008831"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1const__mem__functor2.html">const_mem_functor2</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gab76f41aeada332b353b6fe2e96008831">mem_fun2</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2) const)</td></tr>
<tr class="memdesc:gab76f41aeada332b353b6fe2e96008831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor2.html" title="const_mem_functor2 wraps const methods with 2 argument(s). ">sigc::const_mem_functor2</a> which wraps a const method.  <a href="#gab76f41aeada332b353b6fe2e96008831">More...</a><br/></td></tr>
<tr class="separator:gab76f41aeada332b353b6fe2e96008831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab76f41aeada332b353b6fe2e96008831"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gab76f41aeada332b353b6fe2e96008831"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1volatile__mem__functor2.html">volatile_mem_functor2</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gab76f41aeada332b353b6fe2e96008831">mem_fun2</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2) volatile)</td></tr>
<tr class="memdesc:gab76f41aeada332b353b6fe2e96008831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor2.html" title="volatile_mem_functor2 wraps volatile methods with 2 argument(s). ">sigc::volatile_mem_functor2</a> which wraps a volatile method.  <a href="#gab76f41aeada332b353b6fe2e96008831">More...</a><br/></td></tr>
<tr class="separator:gab76f41aeada332b353b6fe2e96008831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab76f41aeada332b353b6fe2e96008831"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gab76f41aeada332b353b6fe2e96008831"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1const__volatile__mem__functor2.html">const_volatile_mem_functor2</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gab76f41aeada332b353b6fe2e96008831">mem_fun2</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2) const volatile)</td></tr>
<tr class="memdesc:gab76f41aeada332b353b6fe2e96008831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor2.html" title="const_volatile_mem_functor2 wraps const volatile methods with 2 argument(s). ">sigc::const_volatile_mem_functor2</a> which wraps a const volatile method.  <a href="#gab76f41aeada332b353b6fe2e96008831">More...</a><br/></td></tr>
<tr class="separator:gab76f41aeada332b353b6fe2e96008831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga184da4166c8b5409dc4b98d7bc16dff8"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga184da4166c8b5409dc4b98d7bc16dff8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor2.html">bound_mem_functor2</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga184da4166c8b5409dc4b98d7bc16dff8">mem_fun2</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2))</td></tr>
<tr class="memdesc:ga184da4166c8b5409dc4b98d7bc16dff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor2.html" title="bound_mem_functor2 encapsulates a method with 2 arguments and an object instance. ...">sigc::bound_mem_functor2</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#ga184da4166c8b5409dc4b98d7bc16dff8">More...</a><br/></td></tr>
<tr class="separator:ga184da4166c8b5409dc4b98d7bc16dff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee7652f1a0625df50af50e28b5e2423e"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gaee7652f1a0625df50af50e28b5e2423e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor2.html">bound_mem_functor2</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaee7652f1a0625df50af50e28b5e2423e">mem_fun2</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2))</td></tr>
<tr class="memdesc:gaee7652f1a0625df50af50e28b5e2423e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor2.html" title="bound_mem_functor2 encapsulates a method with 2 arguments and an object instance. ...">sigc::bound_mem_functor2</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#gaee7652f1a0625df50af50e28b5e2423e">More...</a><br/></td></tr>
<tr class="separator:gaee7652f1a0625df50af50e28b5e2423e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga184da4166c8b5409dc4b98d7bc16dff8"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga184da4166c8b5409dc4b98d7bc16dff8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor2.html">bound_const_mem_functor2</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga184da4166c8b5409dc4b98d7bc16dff8">mem_fun2</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2) const)</td></tr>
<tr class="memdesc:ga184da4166c8b5409dc4b98d7bc16dff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor2.html" title="bound_const_mem_functor2 encapsulates a const method with 2 arguments and an object instance...">sigc::bound_const_mem_functor2</a> which encapsulates a method and an object instance.  <a href="#ga184da4166c8b5409dc4b98d7bc16dff8">More...</a><br/></td></tr>
<tr class="separator:ga184da4166c8b5409dc4b98d7bc16dff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee7652f1a0625df50af50e28b5e2423e"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gaee7652f1a0625df50af50e28b5e2423e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor2.html">bound_const_mem_functor2</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gaee7652f1a0625df50af50e28b5e2423e">mem_fun2</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2) const)</td></tr>
<tr class="memdesc:gaee7652f1a0625df50af50e28b5e2423e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor2.html" title="bound_const_mem_functor2 encapsulates a const method with 2 arguments and an object instance...">sigc::bound_const_mem_functor2</a> which encapsulates a method and an object instance.  <a href="#gaee7652f1a0625df50af50e28b5e2423e">More...</a><br/></td></tr>
<tr class="separator:gaee7652f1a0625df50af50e28b5e2423e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga184da4166c8b5409dc4b98d7bc16dff8"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga184da4166c8b5409dc4b98d7bc16dff8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html">bound_volatile_mem_functor2</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga184da4166c8b5409dc4b98d7bc16dff8">mem_fun2</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2) volatile)</td></tr>
<tr class="memdesc:ga184da4166c8b5409dc4b98d7bc16dff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html" title="bound_volatile_mem_functor2 encapsulates a volatile method with 2 arguments and an object instance...">sigc::bound_volatile_mem_functor2</a> which encapsulates a method and an object instance.  <a href="#ga184da4166c8b5409dc4b98d7bc16dff8">More...</a><br/></td></tr>
<tr class="separator:ga184da4166c8b5409dc4b98d7bc16dff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee7652f1a0625df50af50e28b5e2423e"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gaee7652f1a0625df50af50e28b5e2423e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html">bound_volatile_mem_functor2</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gaee7652f1a0625df50af50e28b5e2423e">mem_fun2</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2) volatile)</td></tr>
<tr class="memdesc:gaee7652f1a0625df50af50e28b5e2423e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html" title="bound_volatile_mem_functor2 encapsulates a volatile method with 2 arguments and an object instance...">sigc::bound_volatile_mem_functor2</a> which encapsulates a method and an object instance.  <a href="#gaee7652f1a0625df50af50e28b5e2423e">More...</a><br/></td></tr>
<tr class="separator:gaee7652f1a0625df50af50e28b5e2423e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga184da4166c8b5409dc4b98d7bc16dff8"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga184da4166c8b5409dc4b98d7bc16dff8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">bound_const_volatile_mem_functor2</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga184da4166c8b5409dc4b98d7bc16dff8">mem_fun2</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2) const volatile)</td></tr>
<tr class="memdesc:ga184da4166c8b5409dc4b98d7bc16dff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html" title="bound_const_volatile_mem_functor2 encapsulates a const volatile method with 2 arguments and an object...">sigc::bound_const_volatile_mem_functor2</a> which encapsulates a method and an object instance.  <a href="#ga184da4166c8b5409dc4b98d7bc16dff8">More...</a><br/></td></tr>
<tr class="separator:ga184da4166c8b5409dc4b98d7bc16dff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee7652f1a0625df50af50e28b5e2423e"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gaee7652f1a0625df50af50e28b5e2423e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">bound_const_volatile_mem_functor2</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gaee7652f1a0625df50af50e28b5e2423e">mem_fun2</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2) const volatile)</td></tr>
<tr class="memdesc:gaee7652f1a0625df50af50e28b5e2423e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html" title="bound_const_volatile_mem_functor2 encapsulates a const volatile method with 2 arguments and an object...">sigc::bound_const_volatile_mem_functor2</a> which encapsulates a method and an object instance.  <a href="#gaee7652f1a0625df50af50e28b5e2423e">More...</a><br/></td></tr>
<tr class="separator:gaee7652f1a0625df50af50e28b5e2423e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2379e0d689fe4a99c7c669fc29817457"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga2379e0d689fe4a99c7c669fc29817457"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor3.html">mem_functor3</a>&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga2379e0d689fe4a99c7c669fc29817457">mem_fun3</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>
<tr class="memdesc:ga2379e0d689fe4a99c7c669fc29817457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor3.html" title="mem_functor3 wraps methods with 3 argument(s). ">sigc::mem_functor3</a> which wraps a method.  <a href="group__mem__fun.html#ga2379e0d689fe4a99c7c669fc29817457">More...</a><br/></td></tr>
<tr class="separator:ga2379e0d689fe4a99c7c669fc29817457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2379e0d689fe4a99c7c669fc29817457"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga2379e0d689fe4a99c7c669fc29817457"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1const__mem__functor3.html">const_mem_functor3</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga2379e0d689fe4a99c7c669fc29817457">mem_fun3</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3) const)</td></tr>
<tr class="memdesc:ga2379e0d689fe4a99c7c669fc29817457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor3.html" title="const_mem_functor3 wraps const methods with 3 argument(s). ">sigc::const_mem_functor3</a> which wraps a const method.  <a href="#ga2379e0d689fe4a99c7c669fc29817457">More...</a><br/></td></tr>
<tr class="separator:ga2379e0d689fe4a99c7c669fc29817457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2379e0d689fe4a99c7c669fc29817457"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga2379e0d689fe4a99c7c669fc29817457"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1volatile__mem__functor3.html">volatile_mem_functor3</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga2379e0d689fe4a99c7c669fc29817457">mem_fun3</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3) volatile)</td></tr>
<tr class="memdesc:ga2379e0d689fe4a99c7c669fc29817457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor3.html" title="volatile_mem_functor3 wraps volatile methods with 3 argument(s). ">sigc::volatile_mem_functor3</a> which wraps a volatile method.  <a href="#ga2379e0d689fe4a99c7c669fc29817457">More...</a><br/></td></tr>
<tr class="separator:ga2379e0d689fe4a99c7c669fc29817457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2379e0d689fe4a99c7c669fc29817457"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga2379e0d689fe4a99c7c669fc29817457"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1const__volatile__mem__functor3.html">const_volatile_mem_functor3</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga2379e0d689fe4a99c7c669fc29817457">mem_fun3</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3) const volatile)</td></tr>
<tr class="memdesc:ga2379e0d689fe4a99c7c669fc29817457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor3.html" title="const_volatile_mem_functor3 wraps const volatile methods with 3 argument(s). ">sigc::const_volatile_mem_functor3</a> which wraps a const volatile method.  <a href="#ga2379e0d689fe4a99c7c669fc29817457">More...</a><br/></td></tr>
<tr class="separator:ga2379e0d689fe4a99c7c669fc29817457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f2fdbf02e8cac9492326a4a8ffdd012"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga4f2fdbf02e8cac9492326a4a8ffdd012"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor3.html">bound_mem_functor3</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga4f2fdbf02e8cac9492326a4a8ffdd012">mem_fun3</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>
<tr class="memdesc:ga4f2fdbf02e8cac9492326a4a8ffdd012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor3.html" title="bound_mem_functor3 encapsulates a method with 3 arguments and an object instance. ...">sigc::bound_mem_functor3</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#ga4f2fdbf02e8cac9492326a4a8ffdd012">More...</a><br/></td></tr>
<tr class="separator:ga4f2fdbf02e8cac9492326a4a8ffdd012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14e07df139b5cb6897e671c50fc33cde"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga14e07df139b5cb6897e671c50fc33cde"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor3.html">bound_mem_functor3</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga14e07df139b5cb6897e671c50fc33cde">mem_fun3</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>
<tr class="memdesc:ga14e07df139b5cb6897e671c50fc33cde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor3.html" title="bound_mem_functor3 encapsulates a method with 3 arguments and an object instance. ...">sigc::bound_mem_functor3</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#ga14e07df139b5cb6897e671c50fc33cde">More...</a><br/></td></tr>
<tr class="separator:ga14e07df139b5cb6897e671c50fc33cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f2fdbf02e8cac9492326a4a8ffdd012"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga4f2fdbf02e8cac9492326a4a8ffdd012"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor3.html">bound_const_mem_functor3</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga4f2fdbf02e8cac9492326a4a8ffdd012">mem_fun3</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3) const)</td></tr>
<tr class="memdesc:ga4f2fdbf02e8cac9492326a4a8ffdd012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor3.html" title="bound_const_mem_functor3 encapsulates a const method with 3 arguments and an object instance...">sigc::bound_const_mem_functor3</a> which encapsulates a method and an object instance.  <a href="#ga4f2fdbf02e8cac9492326a4a8ffdd012">More...</a><br/></td></tr>
<tr class="separator:ga4f2fdbf02e8cac9492326a4a8ffdd012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14e07df139b5cb6897e671c50fc33cde"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga14e07df139b5cb6897e671c50fc33cde"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor3.html">bound_const_mem_functor3</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga14e07df139b5cb6897e671c50fc33cde">mem_fun3</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3) const)</td></tr>
<tr class="memdesc:ga14e07df139b5cb6897e671c50fc33cde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor3.html" title="bound_const_mem_functor3 encapsulates a const method with 3 arguments and an object instance...">sigc::bound_const_mem_functor3</a> which encapsulates a method and an object instance.  <a href="#ga14e07df139b5cb6897e671c50fc33cde">More...</a><br/></td></tr>
<tr class="separator:ga14e07df139b5cb6897e671c50fc33cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f2fdbf02e8cac9492326a4a8ffdd012"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga4f2fdbf02e8cac9492326a4a8ffdd012"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html">bound_volatile_mem_functor3</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga4f2fdbf02e8cac9492326a4a8ffdd012">mem_fun3</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3) volatile)</td></tr>
<tr class="memdesc:ga4f2fdbf02e8cac9492326a4a8ffdd012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html" title="bound_volatile_mem_functor3 encapsulates a volatile method with 3 arguments and an object instance...">sigc::bound_volatile_mem_functor3</a> which encapsulates a method and an object instance.  <a href="#ga4f2fdbf02e8cac9492326a4a8ffdd012">More...</a><br/></td></tr>
<tr class="separator:ga4f2fdbf02e8cac9492326a4a8ffdd012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14e07df139b5cb6897e671c50fc33cde"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga14e07df139b5cb6897e671c50fc33cde"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html">bound_volatile_mem_functor3</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga14e07df139b5cb6897e671c50fc33cde">mem_fun3</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3) volatile)</td></tr>
<tr class="memdesc:ga14e07df139b5cb6897e671c50fc33cde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html" title="bound_volatile_mem_functor3 encapsulates a volatile method with 3 arguments and an object instance...">sigc::bound_volatile_mem_functor3</a> which encapsulates a method and an object instance.  <a href="#ga14e07df139b5cb6897e671c50fc33cde">More...</a><br/></td></tr>
<tr class="separator:ga14e07df139b5cb6897e671c50fc33cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f2fdbf02e8cac9492326a4a8ffdd012"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga4f2fdbf02e8cac9492326a4a8ffdd012"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">bound_const_volatile_mem_functor3</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga4f2fdbf02e8cac9492326a4a8ffdd012">mem_fun3</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3) const volatile)</td></tr>
<tr class="memdesc:ga4f2fdbf02e8cac9492326a4a8ffdd012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html" title="bound_const_volatile_mem_functor3 encapsulates a const volatile method with 3 arguments and an object...">sigc::bound_const_volatile_mem_functor3</a> which encapsulates a method and an object instance.  <a href="#ga4f2fdbf02e8cac9492326a4a8ffdd012">More...</a><br/></td></tr>
<tr class="separator:ga4f2fdbf02e8cac9492326a4a8ffdd012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14e07df139b5cb6897e671c50fc33cde"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga14e07df139b5cb6897e671c50fc33cde"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">bound_const_volatile_mem_functor3</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga14e07df139b5cb6897e671c50fc33cde">mem_fun3</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3) const volatile)</td></tr>
<tr class="memdesc:ga14e07df139b5cb6897e671c50fc33cde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html" title="bound_const_volatile_mem_functor3 encapsulates a const volatile method with 3 arguments and an object...">sigc::bound_const_volatile_mem_functor3</a> which encapsulates a method and an object instance.  <a href="#ga14e07df139b5cb6897e671c50fc33cde">More...</a><br/></td></tr>
<tr class="separator:ga14e07df139b5cb6897e671c50fc33cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bedd04f76ad3e21f614912562e95d83"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga1bedd04f76ad3e21f614912562e95d83"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor4.html">mem_functor4</a>&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3, T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga1bedd04f76ad3e21f614912562e95d83">mem_fun4</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>
<tr class="memdesc:ga1bedd04f76ad3e21f614912562e95d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor4.html" title="mem_functor4 wraps methods with 4 argument(s). ">sigc::mem_functor4</a> which wraps a method.  <a href="group__mem__fun.html#ga1bedd04f76ad3e21f614912562e95d83">More...</a><br/></td></tr>
<tr class="separator:ga1bedd04f76ad3e21f614912562e95d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bedd04f76ad3e21f614912562e95d83"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga1bedd04f76ad3e21f614912562e95d83"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1const__mem__functor4.html">const_mem_functor4</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga1bedd04f76ad3e21f614912562e95d83">mem_fun4</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const)</td></tr>
<tr class="memdesc:ga1bedd04f76ad3e21f614912562e95d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor4.html" title="const_mem_functor4 wraps const methods with 4 argument(s). ">sigc::const_mem_functor4</a> which wraps a const method.  <a href="#ga1bedd04f76ad3e21f614912562e95d83">More...</a><br/></td></tr>
<tr class="separator:ga1bedd04f76ad3e21f614912562e95d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bedd04f76ad3e21f614912562e95d83"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga1bedd04f76ad3e21f614912562e95d83"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1volatile__mem__functor4.html">volatile_mem_functor4</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga1bedd04f76ad3e21f614912562e95d83">mem_fun4</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) volatile)</td></tr>
<tr class="memdesc:ga1bedd04f76ad3e21f614912562e95d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor4.html" title="volatile_mem_functor4 wraps volatile methods with 4 argument(s). ">sigc::volatile_mem_functor4</a> which wraps a volatile method.  <a href="#ga1bedd04f76ad3e21f614912562e95d83">More...</a><br/></td></tr>
<tr class="separator:ga1bedd04f76ad3e21f614912562e95d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bedd04f76ad3e21f614912562e95d83"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga1bedd04f76ad3e21f614912562e95d83"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1const__volatile__mem__functor4.html">const_volatile_mem_functor4</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga1bedd04f76ad3e21f614912562e95d83">mem_fun4</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const volatile)</td></tr>
<tr class="memdesc:ga1bedd04f76ad3e21f614912562e95d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor4.html" title="const_volatile_mem_functor4 wraps const volatile methods with 4 argument(s). ">sigc::const_volatile_mem_functor4</a> which wraps a const volatile method.  <a href="#ga1bedd04f76ad3e21f614912562e95d83">More...</a><br/></td></tr>
<tr class="separator:ga1bedd04f76ad3e21f614912562e95d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94a2525ef116e16598b81b853544a170"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga94a2525ef116e16598b81b853544a170"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor4.html">bound_mem_functor4</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga94a2525ef116e16598b81b853544a170">mem_fun4</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>
<tr class="memdesc:ga94a2525ef116e16598b81b853544a170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor4.html" title="bound_mem_functor4 encapsulates a method with 4 arguments and an object instance. ...">sigc::bound_mem_functor4</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#ga94a2525ef116e16598b81b853544a170">More...</a><br/></td></tr>
<tr class="separator:ga94a2525ef116e16598b81b853544a170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86da5637e2735480d525ffa930e7e21a"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga86da5637e2735480d525ffa930e7e21a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor4.html">bound_mem_functor4</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga86da5637e2735480d525ffa930e7e21a">mem_fun4</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>
<tr class="memdesc:ga86da5637e2735480d525ffa930e7e21a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor4.html" title="bound_mem_functor4 encapsulates a method with 4 arguments and an object instance. ...">sigc::bound_mem_functor4</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#ga86da5637e2735480d525ffa930e7e21a">More...</a><br/></td></tr>
<tr class="separator:ga86da5637e2735480d525ffa930e7e21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94a2525ef116e16598b81b853544a170"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga94a2525ef116e16598b81b853544a170"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor4.html">bound_const_mem_functor4</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga94a2525ef116e16598b81b853544a170">mem_fun4</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const)</td></tr>
<tr class="memdesc:ga94a2525ef116e16598b81b853544a170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor4.html" title="bound_const_mem_functor4 encapsulates a const method with 4 arguments and an object instance...">sigc::bound_const_mem_functor4</a> which encapsulates a method and an object instance.  <a href="#ga94a2525ef116e16598b81b853544a170">More...</a><br/></td></tr>
<tr class="separator:ga94a2525ef116e16598b81b853544a170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86da5637e2735480d525ffa930e7e21a"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga86da5637e2735480d525ffa930e7e21a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor4.html">bound_const_mem_functor4</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga86da5637e2735480d525ffa930e7e21a">mem_fun4</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const)</td></tr>
<tr class="memdesc:ga86da5637e2735480d525ffa930e7e21a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor4.html" title="bound_const_mem_functor4 encapsulates a const method with 4 arguments and an object instance...">sigc::bound_const_mem_functor4</a> which encapsulates a method and an object instance.  <a href="#ga86da5637e2735480d525ffa930e7e21a">More...</a><br/></td></tr>
<tr class="separator:ga86da5637e2735480d525ffa930e7e21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94a2525ef116e16598b81b853544a170"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga94a2525ef116e16598b81b853544a170"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html">bound_volatile_mem_functor4</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga94a2525ef116e16598b81b853544a170">mem_fun4</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) volatile)</td></tr>
<tr class="memdesc:ga94a2525ef116e16598b81b853544a170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html" title="bound_volatile_mem_functor4 encapsulates a volatile method with 4 arguments and an object instance...">sigc::bound_volatile_mem_functor4</a> which encapsulates a method and an object instance.  <a href="#ga94a2525ef116e16598b81b853544a170">More...</a><br/></td></tr>
<tr class="separator:ga94a2525ef116e16598b81b853544a170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86da5637e2735480d525ffa930e7e21a"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga86da5637e2735480d525ffa930e7e21a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html">bound_volatile_mem_functor4</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga86da5637e2735480d525ffa930e7e21a">mem_fun4</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) volatile)</td></tr>
<tr class="memdesc:ga86da5637e2735480d525ffa930e7e21a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html" title="bound_volatile_mem_functor4 encapsulates a volatile method with 4 arguments and an object instance...">sigc::bound_volatile_mem_functor4</a> which encapsulates a method and an object instance.  <a href="#ga86da5637e2735480d525ffa930e7e21a">More...</a><br/></td></tr>
<tr class="separator:ga86da5637e2735480d525ffa930e7e21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94a2525ef116e16598b81b853544a170"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga94a2525ef116e16598b81b853544a170"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">bound_const_volatile_mem_functor4</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga94a2525ef116e16598b81b853544a170">mem_fun4</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const volatile)</td></tr>
<tr class="memdesc:ga94a2525ef116e16598b81b853544a170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html" title="bound_const_volatile_mem_functor4 encapsulates a const volatile method with 4 arguments and an object...">sigc::bound_const_volatile_mem_functor4</a> which encapsulates a method and an object instance.  <a href="#ga94a2525ef116e16598b81b853544a170">More...</a><br/></td></tr>
<tr class="separator:ga94a2525ef116e16598b81b853544a170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86da5637e2735480d525ffa930e7e21a"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga86da5637e2735480d525ffa930e7e21a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">bound_const_volatile_mem_functor4</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga86da5637e2735480d525ffa930e7e21a">mem_fun4</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4) const volatile)</td></tr>
<tr class="memdesc:ga86da5637e2735480d525ffa930e7e21a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html" title="bound_const_volatile_mem_functor4 encapsulates a const volatile method with 4 arguments and an object...">sigc::bound_const_volatile_mem_functor4</a> which encapsulates a method and an object instance.  <a href="#ga86da5637e2735480d525ffa930e7e21a">More...</a><br/></td></tr>
<tr class="separator:ga86da5637e2735480d525ffa930e7e21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ef4bb904a751d29e2b6803ef81f72fa"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga3ef4bb904a751d29e2b6803ef81f72fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor5.html">mem_functor5</a>&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3, T_arg4, <br class="typebreak"/>
T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga3ef4bb904a751d29e2b6803ef81f72fa">mem_fun5</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>
<tr class="memdesc:ga3ef4bb904a751d29e2b6803ef81f72fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor5.html" title="mem_functor5 wraps methods with 5 argument(s). ">sigc::mem_functor5</a> which wraps a method.  <a href="group__mem__fun.html#ga3ef4bb904a751d29e2b6803ef81f72fa">More...</a><br/></td></tr>
<tr class="separator:ga3ef4bb904a751d29e2b6803ef81f72fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ef4bb904a751d29e2b6803ef81f72fa"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga3ef4bb904a751d29e2b6803ef81f72fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1const__mem__functor5.html">const_mem_functor5</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga3ef4bb904a751d29e2b6803ef81f72fa">mem_fun5</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const)</td></tr>
<tr class="memdesc:ga3ef4bb904a751d29e2b6803ef81f72fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor5.html" title="const_mem_functor5 wraps const methods with 5 argument(s). ">sigc::const_mem_functor5</a> which wraps a const method.  <a href="#ga3ef4bb904a751d29e2b6803ef81f72fa">More...</a><br/></td></tr>
<tr class="separator:ga3ef4bb904a751d29e2b6803ef81f72fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ef4bb904a751d29e2b6803ef81f72fa"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga3ef4bb904a751d29e2b6803ef81f72fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1volatile__mem__functor5.html">volatile_mem_functor5</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga3ef4bb904a751d29e2b6803ef81f72fa">mem_fun5</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) volatile)</td></tr>
<tr class="memdesc:ga3ef4bb904a751d29e2b6803ef81f72fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor5.html" title="volatile_mem_functor5 wraps volatile methods with 5 argument(s). ">sigc::volatile_mem_functor5</a> which wraps a volatile method.  <a href="#ga3ef4bb904a751d29e2b6803ef81f72fa">More...</a><br/></td></tr>
<tr class="separator:ga3ef4bb904a751d29e2b6803ef81f72fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ef4bb904a751d29e2b6803ef81f72fa"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga3ef4bb904a751d29e2b6803ef81f72fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1const__volatile__mem__functor5.html">const_volatile_mem_functor5</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga3ef4bb904a751d29e2b6803ef81f72fa">mem_fun5</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const volatile)</td></tr>
<tr class="memdesc:ga3ef4bb904a751d29e2b6803ef81f72fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor5.html" title="const_volatile_mem_functor5 wraps const volatile methods with 5 argument(s). ">sigc::const_volatile_mem_functor5</a> which wraps a const volatile method.  <a href="#ga3ef4bb904a751d29e2b6803ef81f72fa">More...</a><br/></td></tr>
<tr class="separator:ga3ef4bb904a751d29e2b6803ef81f72fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf060fe3a2be4ff7c0f50aef54b4dc8bf"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gaf060fe3a2be4ff7c0f50aef54b4dc8bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor5.html">bound_mem_functor5</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gaf060fe3a2be4ff7c0f50aef54b4dc8bf">mem_fun5</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>
<tr class="memdesc:gaf060fe3a2be4ff7c0f50aef54b4dc8bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor5.html" title="bound_mem_functor5 encapsulates a method with 5 arguments and an object instance. ...">sigc::bound_mem_functor5</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#gaf060fe3a2be4ff7c0f50aef54b4dc8bf">More...</a><br/></td></tr>
<tr class="separator:gaf060fe3a2be4ff7c0f50aef54b4dc8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c2ca9cef8c857935a59133a73ef61f2"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga5c2ca9cef8c857935a59133a73ef61f2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor5.html">bound_mem_functor5</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga5c2ca9cef8c857935a59133a73ef61f2">mem_fun5</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>
<tr class="memdesc:ga5c2ca9cef8c857935a59133a73ef61f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor5.html" title="bound_mem_functor5 encapsulates a method with 5 arguments and an object instance. ...">sigc::bound_mem_functor5</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#ga5c2ca9cef8c857935a59133a73ef61f2">More...</a><br/></td></tr>
<tr class="separator:ga5c2ca9cef8c857935a59133a73ef61f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf060fe3a2be4ff7c0f50aef54b4dc8bf"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gaf060fe3a2be4ff7c0f50aef54b4dc8bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor5.html">bound_const_mem_functor5</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gaf060fe3a2be4ff7c0f50aef54b4dc8bf">mem_fun5</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const)</td></tr>
<tr class="memdesc:gaf060fe3a2be4ff7c0f50aef54b4dc8bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor5.html" title="bound_const_mem_functor5 encapsulates a const method with 5 arguments and an object instance...">sigc::bound_const_mem_functor5</a> which encapsulates a method and an object instance.  <a href="#gaf060fe3a2be4ff7c0f50aef54b4dc8bf">More...</a><br/></td></tr>
<tr class="separator:gaf060fe3a2be4ff7c0f50aef54b4dc8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c2ca9cef8c857935a59133a73ef61f2"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga5c2ca9cef8c857935a59133a73ef61f2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor5.html">bound_const_mem_functor5</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga5c2ca9cef8c857935a59133a73ef61f2">mem_fun5</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const)</td></tr>
<tr class="memdesc:ga5c2ca9cef8c857935a59133a73ef61f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor5.html" title="bound_const_mem_functor5 encapsulates a const method with 5 arguments and an object instance...">sigc::bound_const_mem_functor5</a> which encapsulates a method and an object instance.  <a href="#ga5c2ca9cef8c857935a59133a73ef61f2">More...</a><br/></td></tr>
<tr class="separator:ga5c2ca9cef8c857935a59133a73ef61f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf060fe3a2be4ff7c0f50aef54b4dc8bf"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gaf060fe3a2be4ff7c0f50aef54b4dc8bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html">bound_volatile_mem_functor5</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gaf060fe3a2be4ff7c0f50aef54b4dc8bf">mem_fun5</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) volatile)</td></tr>
<tr class="memdesc:gaf060fe3a2be4ff7c0f50aef54b4dc8bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html" title="bound_volatile_mem_functor5 encapsulates a volatile method with 5 arguments and an object instance...">sigc::bound_volatile_mem_functor5</a> which encapsulates a method and an object instance.  <a href="#gaf060fe3a2be4ff7c0f50aef54b4dc8bf">More...</a><br/></td></tr>
<tr class="separator:gaf060fe3a2be4ff7c0f50aef54b4dc8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c2ca9cef8c857935a59133a73ef61f2"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga5c2ca9cef8c857935a59133a73ef61f2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html">bound_volatile_mem_functor5</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga5c2ca9cef8c857935a59133a73ef61f2">mem_fun5</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) volatile)</td></tr>
<tr class="memdesc:ga5c2ca9cef8c857935a59133a73ef61f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html" title="bound_volatile_mem_functor5 encapsulates a volatile method with 5 arguments and an object instance...">sigc::bound_volatile_mem_functor5</a> which encapsulates a method and an object instance.  <a href="#ga5c2ca9cef8c857935a59133a73ef61f2">More...</a><br/></td></tr>
<tr class="separator:ga5c2ca9cef8c857935a59133a73ef61f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf060fe3a2be4ff7c0f50aef54b4dc8bf"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gaf060fe3a2be4ff7c0f50aef54b4dc8bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">bound_const_volatile_mem_functor5</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gaf060fe3a2be4ff7c0f50aef54b4dc8bf">mem_fun5</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const volatile)</td></tr>
<tr class="memdesc:gaf060fe3a2be4ff7c0f50aef54b4dc8bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html" title="bound_const_volatile_mem_functor5 encapsulates a const volatile method with 5 arguments and an object...">sigc::bound_const_volatile_mem_functor5</a> which encapsulates a method and an object instance.  <a href="#gaf060fe3a2be4ff7c0f50aef54b4dc8bf">More...</a><br/></td></tr>
<tr class="separator:gaf060fe3a2be4ff7c0f50aef54b4dc8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c2ca9cef8c857935a59133a73ef61f2"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga5c2ca9cef8c857935a59133a73ef61f2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">bound_const_volatile_mem_functor5</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga5c2ca9cef8c857935a59133a73ef61f2">mem_fun5</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const volatile)</td></tr>
<tr class="memdesc:ga5c2ca9cef8c857935a59133a73ef61f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html" title="bound_const_volatile_mem_functor5 encapsulates a const volatile method with 5 arguments and an object...">sigc::bound_const_volatile_mem_functor5</a> which encapsulates a method and an object instance.  <a href="#ga5c2ca9cef8c857935a59133a73ef61f2">More...</a><br/></td></tr>
<tr class="separator:ga5c2ca9cef8c857935a59133a73ef61f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34ace98fbbd18cb635795639d0f22678"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga34ace98fbbd18cb635795639d0f22678"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor6.html">mem_functor6</a>&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3, T_arg4, <br class="typebreak"/>
T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga34ace98fbbd18cb635795639d0f22678">mem_fun6</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>
<tr class="memdesc:ga34ace98fbbd18cb635795639d0f22678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor6.html" title="mem_functor6 wraps methods with 6 argument(s). ">sigc::mem_functor6</a> which wraps a method.  <a href="group__mem__fun.html#ga34ace98fbbd18cb635795639d0f22678">More...</a><br/></td></tr>
<tr class="separator:ga34ace98fbbd18cb635795639d0f22678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34ace98fbbd18cb635795639d0f22678"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga34ace98fbbd18cb635795639d0f22678"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1const__mem__functor6.html">const_mem_functor6</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga34ace98fbbd18cb635795639d0f22678">mem_fun6</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const)</td></tr>
<tr class="memdesc:ga34ace98fbbd18cb635795639d0f22678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor6.html" title="const_mem_functor6 wraps const methods with 6 argument(s). ">sigc::const_mem_functor6</a> which wraps a const method.  <a href="#ga34ace98fbbd18cb635795639d0f22678">More...</a><br/></td></tr>
<tr class="separator:ga34ace98fbbd18cb635795639d0f22678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34ace98fbbd18cb635795639d0f22678"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga34ace98fbbd18cb635795639d0f22678"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1volatile__mem__functor6.html">volatile_mem_functor6</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga34ace98fbbd18cb635795639d0f22678">mem_fun6</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) volatile)</td></tr>
<tr class="memdesc:ga34ace98fbbd18cb635795639d0f22678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor6.html" title="volatile_mem_functor6 wraps volatile methods with 6 argument(s). ">sigc::volatile_mem_functor6</a> which wraps a volatile method.  <a href="#ga34ace98fbbd18cb635795639d0f22678">More...</a><br/></td></tr>
<tr class="separator:ga34ace98fbbd18cb635795639d0f22678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34ace98fbbd18cb635795639d0f22678"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga34ace98fbbd18cb635795639d0f22678"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1const__volatile__mem__functor6.html">const_volatile_mem_functor6</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga34ace98fbbd18cb635795639d0f22678">mem_fun6</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const volatile)</td></tr>
<tr class="memdesc:ga34ace98fbbd18cb635795639d0f22678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor6.html" title="const_volatile_mem_functor6 wraps const volatile methods with 6 argument(s). ">sigc::const_volatile_mem_functor6</a> which wraps a const volatile method.  <a href="#ga34ace98fbbd18cb635795639d0f22678">More...</a><br/></td></tr>
<tr class="separator:ga34ace98fbbd18cb635795639d0f22678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0a6242da9bf96642f25c1363dfef383"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gac0a6242da9bf96642f25c1363dfef383"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor6.html">bound_mem_functor6</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#gac0a6242da9bf96642f25c1363dfef383">mem_fun6</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>
<tr class="memdesc:gac0a6242da9bf96642f25c1363dfef383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor6.html" title="bound_mem_functor6 encapsulates a method with 6 arguments and an object instance. ...">sigc::bound_mem_functor6</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#gac0a6242da9bf96642f25c1363dfef383">More...</a><br/></td></tr>
<tr class="separator:gac0a6242da9bf96642f25c1363dfef383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga947f4410e62a2996023177e490c882b7"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga947f4410e62a2996023177e490c882b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor6.html">bound_mem_functor6</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga947f4410e62a2996023177e490c882b7">mem_fun6</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>
<tr class="memdesc:ga947f4410e62a2996023177e490c882b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor6.html" title="bound_mem_functor6 encapsulates a method with 6 arguments and an object instance. ...">sigc::bound_mem_functor6</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#ga947f4410e62a2996023177e490c882b7">More...</a><br/></td></tr>
<tr class="separator:ga947f4410e62a2996023177e490c882b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0a6242da9bf96642f25c1363dfef383"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gac0a6242da9bf96642f25c1363dfef383"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor6.html">bound_const_mem_functor6</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gac0a6242da9bf96642f25c1363dfef383">mem_fun6</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const)</td></tr>
<tr class="memdesc:gac0a6242da9bf96642f25c1363dfef383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor6.html" title="bound_const_mem_functor6 encapsulates a const method with 6 arguments and an object instance...">sigc::bound_const_mem_functor6</a> which encapsulates a method and an object instance.  <a href="#gac0a6242da9bf96642f25c1363dfef383">More...</a><br/></td></tr>
<tr class="separator:gac0a6242da9bf96642f25c1363dfef383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga947f4410e62a2996023177e490c882b7"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga947f4410e62a2996023177e490c882b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor6.html">bound_const_mem_functor6</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga947f4410e62a2996023177e490c882b7">mem_fun6</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const)</td></tr>
<tr class="memdesc:ga947f4410e62a2996023177e490c882b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor6.html" title="bound_const_mem_functor6 encapsulates a const method with 6 arguments and an object instance...">sigc::bound_const_mem_functor6</a> which encapsulates a method and an object instance.  <a href="#ga947f4410e62a2996023177e490c882b7">More...</a><br/></td></tr>
<tr class="separator:ga947f4410e62a2996023177e490c882b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0a6242da9bf96642f25c1363dfef383"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gac0a6242da9bf96642f25c1363dfef383"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html">bound_volatile_mem_functor6</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gac0a6242da9bf96642f25c1363dfef383">mem_fun6</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) volatile)</td></tr>
<tr class="memdesc:gac0a6242da9bf96642f25c1363dfef383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html" title="bound_volatile_mem_functor6 encapsulates a volatile method with 6 arguments and an object instance...">sigc::bound_volatile_mem_functor6</a> which encapsulates a method and an object instance.  <a href="#gac0a6242da9bf96642f25c1363dfef383">More...</a><br/></td></tr>
<tr class="separator:gac0a6242da9bf96642f25c1363dfef383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga947f4410e62a2996023177e490c882b7"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga947f4410e62a2996023177e490c882b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html">bound_volatile_mem_functor6</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga947f4410e62a2996023177e490c882b7">mem_fun6</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) volatile)</td></tr>
<tr class="memdesc:ga947f4410e62a2996023177e490c882b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html" title="bound_volatile_mem_functor6 encapsulates a volatile method with 6 arguments and an object instance...">sigc::bound_volatile_mem_functor6</a> which encapsulates a method and an object instance.  <a href="#ga947f4410e62a2996023177e490c882b7">More...</a><br/></td></tr>
<tr class="separator:ga947f4410e62a2996023177e490c882b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0a6242da9bf96642f25c1363dfef383"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:gac0a6242da9bf96642f25c1363dfef383"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">bound_const_volatile_mem_functor6</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#gac0a6242da9bf96642f25c1363dfef383">mem_fun6</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const volatile)</td></tr>
<tr class="memdesc:gac0a6242da9bf96642f25c1363dfef383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html" title="bound_const_volatile_mem_functor6 encapsulates a const volatile method with 6 arguments and an object...">sigc::bound_const_volatile_mem_functor6</a> which encapsulates a method and an object instance.  <a href="#gac0a6242da9bf96642f25c1363dfef383">More...</a><br/></td></tr>
<tr class="separator:gac0a6242da9bf96642f25c1363dfef383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga947f4410e62a2996023177e490c882b7"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga947f4410e62a2996023177e490c882b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">bound_const_volatile_mem_functor6</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga947f4410e62a2996023177e490c882b7">mem_fun6</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const volatile)</td></tr>
<tr class="memdesc:ga947f4410e62a2996023177e490c882b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html" title="bound_const_volatile_mem_functor6 encapsulates a const volatile method with 6 arguments and an object...">sigc::bound_const_volatile_mem_functor6</a> which encapsulates a method and an object instance.  <a href="#ga947f4410e62a2996023177e490c882b7">More...</a><br/></td></tr>
<tr class="separator:ga947f4410e62a2996023177e490c882b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d174b01bf94dbda3aea58c25c2b3322"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga3d174b01bf94dbda3aea58c25c2b3322"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1mem__functor7.html">mem_functor7</a>&lt; T_return, T_obj, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3, T_arg4, <br class="typebreak"/>
T_arg5, T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga3d174b01bf94dbda3aea58c25c2b3322">mem_fun7</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>
<tr class="memdesc:ga3d174b01bf94dbda3aea58c25c2b3322"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1mem__functor7.html" title="mem_functor7 wraps methods with 7 argument(s). ">sigc::mem_functor7</a> which wraps a method.  <a href="group__mem__fun.html#ga3d174b01bf94dbda3aea58c25c2b3322">More...</a><br/></td></tr>
<tr class="separator:ga3d174b01bf94dbda3aea58c25c2b3322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d174b01bf94dbda3aea58c25c2b3322"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga3d174b01bf94dbda3aea58c25c2b3322"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1const__mem__functor7.html">const_mem_functor7</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga3d174b01bf94dbda3aea58c25c2b3322">mem_fun7</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const)</td></tr>
<tr class="memdesc:ga3d174b01bf94dbda3aea58c25c2b3322"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor7.html" title="const_mem_functor7 wraps const methods with 7 argument(s). ">sigc::const_mem_functor7</a> which wraps a const method.  <a href="#ga3d174b01bf94dbda3aea58c25c2b3322">More...</a><br/></td></tr>
<tr class="separator:ga3d174b01bf94dbda3aea58c25c2b3322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d174b01bf94dbda3aea58c25c2b3322"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga3d174b01bf94dbda3aea58c25c2b3322"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1volatile__mem__functor7.html">volatile_mem_functor7</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga3d174b01bf94dbda3aea58c25c2b3322">mem_fun7</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) volatile)</td></tr>
<tr class="memdesc:ga3d174b01bf94dbda3aea58c25c2b3322"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor7.html" title="volatile_mem_functor7 wraps volatile methods with 7 argument(s). ">sigc::volatile_mem_functor7</a> which wraps a volatile method.  <a href="#ga3d174b01bf94dbda3aea58c25c2b3322">More...</a><br/></td></tr>
<tr class="separator:ga3d174b01bf94dbda3aea58c25c2b3322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d174b01bf94dbda3aea58c25c2b3322"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga3d174b01bf94dbda3aea58c25c2b3322"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1const__volatile__mem__functor7.html">const_volatile_mem_functor7</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga3d174b01bf94dbda3aea58c25c2b3322">mem_fun7</a> (T_return(T_obj::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const volatile)</td></tr>
<tr class="memdesc:ga3d174b01bf94dbda3aea58c25c2b3322"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor7.html" title="const_volatile_mem_functor7 wraps const volatile methods with 7 argument(s). ">sigc::const_volatile_mem_functor7</a> which wraps a const volatile method.  <a href="#ga3d174b01bf94dbda3aea58c25c2b3322">More...</a><br/></td></tr>
<tr class="separator:ga3d174b01bf94dbda3aea58c25c2b3322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9899534bc8eb78c227d895b396710091"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga9899534bc8eb78c227d895b396710091"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor7.html">bound_mem_functor7</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga9899534bc8eb78c227d895b396710091">mem_fun7</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>
<tr class="memdesc:ga9899534bc8eb78c227d895b396710091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor7.html" title="bound_mem_functor7 encapsulates a method with 7 arguments and an object instance. ...">sigc::bound_mem_functor7</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#ga9899534bc8eb78c227d895b396710091">More...</a><br/></td></tr>
<tr class="separator:ga9899534bc8eb78c227d895b396710091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f704e475da2aad1717e059c264c1436"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga1f704e475da2aad1717e059c264c1436"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__mem__functor7.html">bound_mem_functor7</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mem__fun.html#ga1f704e475da2aad1717e059c264c1436">mem_fun7</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>
<tr class="memdesc:ga1f704e475da2aad1717e059c264c1436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__mem__functor7.html" title="bound_mem_functor7 encapsulates a method with 7 arguments and an object instance. ...">sigc::bound_mem_functor7</a> which encapsulates a method and an object instance.  <a href="group__mem__fun.html#ga1f704e475da2aad1717e059c264c1436">More...</a><br/></td></tr>
<tr class="separator:ga1f704e475da2aad1717e059c264c1436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9899534bc8eb78c227d895b396710091"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga9899534bc8eb78c227d895b396710091"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor7.html">bound_const_mem_functor7</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga9899534bc8eb78c227d895b396710091">mem_fun7</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const)</td></tr>
<tr class="memdesc:ga9899534bc8eb78c227d895b396710091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor7.html" title="bound_const_mem_functor7 encapsulates a const method with 7 arguments and an object instance...">sigc::bound_const_mem_functor7</a> which encapsulates a method and an object instance.  <a href="#ga9899534bc8eb78c227d895b396710091">More...</a><br/></td></tr>
<tr class="separator:ga9899534bc8eb78c227d895b396710091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f704e475da2aad1717e059c264c1436"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga1f704e475da2aad1717e059c264c1436"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__mem__functor7.html">bound_const_mem_functor7</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga1f704e475da2aad1717e059c264c1436">mem_fun7</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const)</td></tr>
<tr class="memdesc:ga1f704e475da2aad1717e059c264c1436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor7.html" title="bound_const_mem_functor7 encapsulates a const method with 7 arguments and an object instance...">sigc::bound_const_mem_functor7</a> which encapsulates a method and an object instance.  <a href="#ga1f704e475da2aad1717e059c264c1436">More...</a><br/></td></tr>
<tr class="separator:ga1f704e475da2aad1717e059c264c1436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9899534bc8eb78c227d895b396710091"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga9899534bc8eb78c227d895b396710091"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html">bound_volatile_mem_functor7</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga9899534bc8eb78c227d895b396710091">mem_fun7</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) volatile)</td></tr>
<tr class="memdesc:ga9899534bc8eb78c227d895b396710091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html" title="bound_volatile_mem_functor7 encapsulates a volatile method with 7 arguments and an object instance...">sigc::bound_volatile_mem_functor7</a> which encapsulates a method and an object instance.  <a href="#ga9899534bc8eb78c227d895b396710091">More...</a><br/></td></tr>
<tr class="separator:ga9899534bc8eb78c227d895b396710091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f704e475da2aad1717e059c264c1436"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga1f704e475da2aad1717e059c264c1436"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html">bound_volatile_mem_functor7</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga1f704e475da2aad1717e059c264c1436">mem_fun7</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) volatile)</td></tr>
<tr class="memdesc:ga1f704e475da2aad1717e059c264c1436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html" title="bound_volatile_mem_functor7 encapsulates a volatile method with 7 arguments and an object instance...">sigc::bound_volatile_mem_functor7</a> which encapsulates a method and an object instance.  <a href="#ga1f704e475da2aad1717e059c264c1436">More...</a><br/></td></tr>
<tr class="separator:ga1f704e475da2aad1717e059c264c1436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9899534bc8eb78c227d895b396710091"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga9899534bc8eb78c227d895b396710091"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">bound_const_volatile_mem_functor7</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga9899534bc8eb78c227d895b396710091">mem_fun7</a> (T_obj* _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const volatile)</td></tr>
<tr class="memdesc:ga9899534bc8eb78c227d895b396710091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html" title="bound_const_volatile_mem_functor7 encapsulates a const volatile method with 7 arguments and an object...">sigc::bound_const_volatile_mem_functor7</a> which encapsulates a method and an object instance.  <a href="#ga9899534bc8eb78c227d895b396710091">More...</a><br/></td></tr>
<tr class="separator:ga9899534bc8eb78c227d895b396710091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f704e475da2aad1717e059c264c1436"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </td></tr>
<tr class="memitem:ga1f704e475da2aad1717e059c264c1436"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">bound_const_volatile_mem_functor7</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#ga1f704e475da2aad1717e059c264c1436">mem_fun7</a> (T_obj&amp; _A_obj, T_return(T_obj2::* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const volatile)</td></tr>
<tr class="memdesc:ga1f704e475da2aad1717e059c264c1436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html" title="bound_const_volatile_mem_functor7 encapsulates a const volatile method with 7 arguments and an object...">sigc::bound_const_volatile_mem_functor7</a> which encapsulates a method and an object instance.  <a href="#ga1f704e475da2aad1717e059c264c1436">More...</a><br/></td></tr>
<tr class="separator:ga1f704e475da2aad1717e059c264c1436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c80de72f656fb05e81fda622dddc863"><td class="memTemplParams" colspan="2">template&lt;class T_return &gt; </td></tr>
<tr class="memitem:ga9c80de72f656fb05e81fda622dddc863"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor0.html">pointer_functor0</a>&lt; T_return &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#ga9c80de72f656fb05e81fda622dddc863">ptr_fun</a> (T_return(* _A_func)())</td></tr>
<tr class="memdesc:ga9c80de72f656fb05e81fda622dddc863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor0.html" title="pointer_functor0 wraps existing non-member functions with 0 argument(s). ">sigc::pointer_functor0</a> which wraps an existing non-member function.  <a href="group__ptr__fun.html#ga9c80de72f656fb05e81fda622dddc863">More...</a><br/></td></tr>
<tr class="separator:ga9c80de72f656fb05e81fda622dddc863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b1c3b4ecb24056f5bd38fc6a87f9ad1"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return &gt; </td></tr>
<tr class="memitem:ga9b1c3b4ecb24056f5bd38fc6a87f9ad1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor1.html">pointer_functor1</a>&lt; T_arg1, <br class="typebreak"/>
T_return &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#ga9b1c3b4ecb24056f5bd38fc6a87f9ad1">ptr_fun</a> (T_return(* _A_func)(T_arg1))</td></tr>
<tr class="memdesc:ga9b1c3b4ecb24056f5bd38fc6a87f9ad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor1.html" title="pointer_functor1 wraps existing non-member functions with 1 argument(s). ">sigc::pointer_functor1</a> which wraps an existing non-member function.  <a href="group__ptr__fun.html#ga9b1c3b4ecb24056f5bd38fc6a87f9ad1">More...</a><br/></td></tr>
<tr class="separator:ga9b1c3b4ecb24056f5bd38fc6a87f9ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c0db14ab1a864b2bad70000325d94c8"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return &gt; </td></tr>
<tr class="memitem:ga9c0db14ab1a864b2bad70000325d94c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor2.html">pointer_functor2</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_return &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#ga9c0db14ab1a864b2bad70000325d94c8">ptr_fun</a> (T_return(* _A_func)(T_arg1, T_arg2))</td></tr>
<tr class="memdesc:ga9c0db14ab1a864b2bad70000325d94c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor2.html" title="pointer_functor2 wraps existing non-member functions with 2 argument(s). ">sigc::pointer_functor2</a> which wraps an existing non-member function.  <a href="group__ptr__fun.html#ga9c0db14ab1a864b2bad70000325d94c8">More...</a><br/></td></tr>
<tr class="separator:ga9c0db14ab1a864b2bad70000325d94c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cd2254135f3afcfc5ce34e73cf2f48b"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return &gt; </td></tr>
<tr class="memitem:ga1cd2254135f3afcfc5ce34e73cf2f48b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor3.html">pointer_functor3</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_return &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#ga1cd2254135f3afcfc5ce34e73cf2f48b">ptr_fun</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>
<tr class="memdesc:ga1cd2254135f3afcfc5ce34e73cf2f48b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor3.html" title="pointer_functor3 wraps existing non-member functions with 3 argument(s). ">sigc::pointer_functor3</a> which wraps an existing non-member function.  <a href="group__ptr__fun.html#ga1cd2254135f3afcfc5ce34e73cf2f48b">More...</a><br/></td></tr>
<tr class="separator:ga1cd2254135f3afcfc5ce34e73cf2f48b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa23ae1abf223560bcac001b86d3cc484"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return &gt; </td></tr>
<tr class="memitem:gaa23ae1abf223560bcac001b86d3cc484"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor4.html">pointer_functor4</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, <br class="typebreak"/>
T_return &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#gaa23ae1abf223560bcac001b86d3cc484">ptr_fun</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>
<tr class="memdesc:gaa23ae1abf223560bcac001b86d3cc484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor4.html" title="pointer_functor4 wraps existing non-member functions with 4 argument(s). ">sigc::pointer_functor4</a> which wraps an existing non-member function.  <a href="group__ptr__fun.html#gaa23ae1abf223560bcac001b86d3cc484">More...</a><br/></td></tr>
<tr class="separator:gaa23ae1abf223560bcac001b86d3cc484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd3087df10b981325953c93e914d451e"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return &gt; </td></tr>
<tr class="memitem:gafd3087df10b981325953c93e914d451e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor5.html">pointer_functor5</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_return &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#gafd3087df10b981325953c93e914d451e">ptr_fun</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>
<tr class="memdesc:gafd3087df10b981325953c93e914d451e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor5.html" title="pointer_functor5 wraps existing non-member functions with 5 argument(s). ">sigc::pointer_functor5</a> which wraps an existing non-member function.  <a href="group__ptr__fun.html#gafd3087df10b981325953c93e914d451e">More...</a><br/></td></tr>
<tr class="separator:gafd3087df10b981325953c93e914d451e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f4d43c3aace56cc5ce0f38886b9ace6"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return &gt; </td></tr>
<tr class="memitem:ga0f4d43c3aace56cc5ce0f38886b9ace6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor6.html">pointer_functor6</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_return &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#ga0f4d43c3aace56cc5ce0f38886b9ace6">ptr_fun</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>
<tr class="memdesc:ga0f4d43c3aace56cc5ce0f38886b9ace6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor6.html" title="pointer_functor6 wraps existing non-member functions with 6 argument(s). ">sigc::pointer_functor6</a> which wraps an existing non-member function.  <a href="group__ptr__fun.html#ga0f4d43c3aace56cc5ce0f38886b9ace6">More...</a><br/></td></tr>
<tr class="separator:ga0f4d43c3aace56cc5ce0f38886b9ace6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65221432dda1b020b73349627762da70"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return &gt; </td></tr>
<tr class="memitem:ga65221432dda1b020b73349627762da70"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor7.html">pointer_functor7</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7, T_return &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#ga65221432dda1b020b73349627762da70">ptr_fun</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>
<tr class="memdesc:ga65221432dda1b020b73349627762da70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor7.html" title="pointer_functor7 wraps existing non-member functions with 7 argument(s). ">sigc::pointer_functor7</a> which wraps an existing non-member function.  <a href="group__ptr__fun.html#ga65221432dda1b020b73349627762da70">More...</a><br/></td></tr>
<tr class="separator:ga65221432dda1b020b73349627762da70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad8dffc194a4e4dfa0935ce49d43cd5c"><td class="memTemplParams" colspan="2">template&lt;class T_return &gt; </td></tr>
<tr class="memitem:gaad8dffc194a4e4dfa0935ce49d43cd5c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor0.html">pointer_functor0</a>&lt; T_return &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#gaad8dffc194a4e4dfa0935ce49d43cd5c">ptr_fun0</a> (T_return(* _A_func)())</td></tr>
<tr class="memdesc:gaad8dffc194a4e4dfa0935ce49d43cd5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor0.html" title="pointer_functor0 wraps existing non-member functions with 0 argument(s). ">sigc::pointer_functor0</a> which wraps an existing non-member function.  <a href="group__ptr__fun.html#gaad8dffc194a4e4dfa0935ce49d43cd5c">More...</a><br/></td></tr>
<tr class="separator:gaad8dffc194a4e4dfa0935ce49d43cd5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b1b8e8f5555d6be4ba41be3fb82c94e"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return &gt; </td></tr>
<tr class="memitem:ga9b1b8e8f5555d6be4ba41be3fb82c94e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor1.html">pointer_functor1</a>&lt; T_arg1, <br class="typebreak"/>
T_return &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#ga9b1b8e8f5555d6be4ba41be3fb82c94e">ptr_fun1</a> (T_return(* _A_func)(T_arg1))</td></tr>
<tr class="memdesc:ga9b1b8e8f5555d6be4ba41be3fb82c94e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor1.html" title="pointer_functor1 wraps existing non-member functions with 1 argument(s). ">sigc::pointer_functor1</a> which wraps an existing non-member function.  <a href="group__ptr__fun.html#ga9b1b8e8f5555d6be4ba41be3fb82c94e">More...</a><br/></td></tr>
<tr class="separator:ga9b1b8e8f5555d6be4ba41be3fb82c94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0244165b83e41a30b2dfb9523afad446"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return &gt; </td></tr>
<tr class="memitem:ga0244165b83e41a30b2dfb9523afad446"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor2.html">pointer_functor2</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_return &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#ga0244165b83e41a30b2dfb9523afad446">ptr_fun2</a> (T_return(* _A_func)(T_arg1, T_arg2))</td></tr>
<tr class="memdesc:ga0244165b83e41a30b2dfb9523afad446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor2.html" title="pointer_functor2 wraps existing non-member functions with 2 argument(s). ">sigc::pointer_functor2</a> which wraps an existing non-member function.  <a href="group__ptr__fun.html#ga0244165b83e41a30b2dfb9523afad446">More...</a><br/></td></tr>
<tr class="separator:ga0244165b83e41a30b2dfb9523afad446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga749e83ea85926d5ad6994d775f98de8d"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return &gt; </td></tr>
<tr class="memitem:ga749e83ea85926d5ad6994d775f98de8d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor3.html">pointer_functor3</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_return &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#ga749e83ea85926d5ad6994d775f98de8d">ptr_fun3</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3))</td></tr>
<tr class="memdesc:ga749e83ea85926d5ad6994d775f98de8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor3.html" title="pointer_functor3 wraps existing non-member functions with 3 argument(s). ">sigc::pointer_functor3</a> which wraps an existing non-member function.  <a href="group__ptr__fun.html#ga749e83ea85926d5ad6994d775f98de8d">More...</a><br/></td></tr>
<tr class="separator:ga749e83ea85926d5ad6994d775f98de8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6fa01189c786e778d943a2ee60896a4"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return &gt; </td></tr>
<tr class="memitem:gac6fa01189c786e778d943a2ee60896a4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor4.html">pointer_functor4</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, <br class="typebreak"/>
T_return &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#gac6fa01189c786e778d943a2ee60896a4">ptr_fun4</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4))</td></tr>
<tr class="memdesc:gac6fa01189c786e778d943a2ee60896a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor4.html" title="pointer_functor4 wraps existing non-member functions with 4 argument(s). ">sigc::pointer_functor4</a> which wraps an existing non-member function.  <a href="group__ptr__fun.html#gac6fa01189c786e778d943a2ee60896a4">More...</a><br/></td></tr>
<tr class="separator:gac6fa01189c786e778d943a2ee60896a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37ae059caefef68e441d3dd7d5b11cce"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return &gt; </td></tr>
<tr class="memitem:ga37ae059caefef68e441d3dd7d5b11cce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor5.html">pointer_functor5</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_return &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#ga37ae059caefef68e441d3dd7d5b11cce">ptr_fun5</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5))</td></tr>
<tr class="memdesc:ga37ae059caefef68e441d3dd7d5b11cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor5.html" title="pointer_functor5 wraps existing non-member functions with 5 argument(s). ">sigc::pointer_functor5</a> which wraps an existing non-member function.  <a href="group__ptr__fun.html#ga37ae059caefef68e441d3dd7d5b11cce">More...</a><br/></td></tr>
<tr class="separator:ga37ae059caefef68e441d3dd7d5b11cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cdf17b7ec15b260f5147e1171dd5299"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return &gt; </td></tr>
<tr class="memitem:ga8cdf17b7ec15b260f5147e1171dd5299"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor6.html">pointer_functor6</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_return &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#ga8cdf17b7ec15b260f5147e1171dd5299">ptr_fun6</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6))</td></tr>
<tr class="memdesc:ga8cdf17b7ec15b260f5147e1171dd5299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor6.html" title="pointer_functor6 wraps existing non-member functions with 6 argument(s). ">sigc::pointer_functor6</a> which wraps an existing non-member function.  <a href="group__ptr__fun.html#ga8cdf17b7ec15b260f5147e1171dd5299">More...</a><br/></td></tr>
<tr class="separator:ga8cdf17b7ec15b260f5147e1171dd5299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82e53ab558dae814c16a09edb53617bb"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return &gt; </td></tr>
<tr class="memitem:ga82e53ab558dae814c16a09edb53617bb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1pointer__functor7.html">pointer_functor7</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7, T_return &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ptr__fun.html#ga82e53ab558dae814c16a09edb53617bb">ptr_fun7</a> (T_return(* _A_func)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7))</td></tr>
<tr class="memdesc:ga82e53ab558dae814c16a09edb53617bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a functor of type <a class="el" href="classsigc_1_1pointer__functor7.html" title="pointer_functor7 wraps existing non-member functions with 7 argument(s). ">sigc::pointer_functor7</a> which wraps an existing non-member function.  <a href="group__ptr__fun.html#ga82e53ab558dae814c16a09edb53617bb">More...</a><br/></td></tr>
<tr class="separator:ga82e53ab558dae814c16a09edb53617bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e982c74c057b5630246ba436524041"><td class="memTemplParams" colspan="2">template&lt;class T_type &gt; </td></tr>
<tr class="memitem:a48e982c74c057b5630246ba436524041"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1reference__wrapper.html">reference_wrapper</a>&lt; T_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#a48e982c74c057b5630246ba436524041">ref</a> (T_type&amp; v)</td></tr>
<tr class="memdesc:a48e982c74c057b5630246ba436524041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a reference wrapper.  <a href="#a48e982c74c057b5630246ba436524041">More...</a><br/></td></tr>
<tr class="separator:a48e982c74c057b5630246ba436524041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a670882bd3fa5890b464871ac515aaba9"><td class="memTemplParams" colspan="2">template&lt;class T_type &gt; </td></tr>
<tr class="memitem:a670882bd3fa5890b464871ac515aaba9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1const__reference__wrapper.html">const_reference_wrapper</a>&lt; T_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#a670882bd3fa5890b464871ac515aaba9">ref</a> (const T_type&amp; v)</td></tr>
<tr class="memdesc:a670882bd3fa5890b464871ac515aaba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a const reference wrapper.  <a href="#a670882bd3fa5890b464871ac515aaba9">More...</a><br/></td></tr>
<tr class="separator:a670882bd3fa5890b464871ac515aaba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b98eeb2a61b5b1f84dcd1d20fe666f1"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr class="memitem:ga8b98eeb2a61b5b1f84dcd1d20fe666f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1slot.html">slot</a>&lt; T_return, <br class="typebreak"/>
T_arg1, T_arg2, T_arg3, T_arg4, <br class="typebreak"/>
T_arg5, T_arg6, T_arg7 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga8b98eeb2a61b5b1f84dcd1d20fe666f1">retype</a> (const <a class="el" href="classsigc_1_1slot.html">slot</a>&lt; T_return, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga8b98eeb2a61b5b1f84dcd1d20fe666f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga8b98eeb2a61b5b1f84dcd1d20fe666f1">More...</a><br/></td></tr>
<tr class="separator:ga8b98eeb2a61b5b1f84dcd1d20fe666f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23978c94d9d3c934803898c3bf48ff7d"><td class="memTemplParams" colspan="2">template&lt;class T_return &gt; </td></tr>
<tr class="memitem:ga23978c94d9d3c934803898c3bf48ff7d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1pointer__functor0.html">pointer_functor0</a>&lt; T_return &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga23978c94d9d3c934803898c3bf48ff7d">retype</a> (const <a class="el" href="classsigc_1_1pointer__functor0.html">pointer_functor0</a>&lt; T_return &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga23978c94d9d3c934803898c3bf48ff7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga23978c94d9d3c934803898c3bf48ff7d">More...</a><br/></td></tr>
<tr class="separator:ga23978c94d9d3c934803898c3bf48ff7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75cc92c15faf06d5293ff34179f21899"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_return &gt; </td></tr>
<tr class="memitem:ga75cc92c15faf06d5293ff34179f21899"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1pointer__functor1.html">pointer_functor1</a>&lt; T_arg1, <br class="typebreak"/>
T_return &gt;, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga75cc92c15faf06d5293ff34179f21899">retype</a> (const <a class="el" href="classsigc_1_1pointer__functor1.html">pointer_functor1</a>&lt; T_arg1, T_return &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga75cc92c15faf06d5293ff34179f21899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga75cc92c15faf06d5293ff34179f21899">More...</a><br/></td></tr>
<tr class="separator:ga75cc92c15faf06d5293ff34179f21899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d67e207b3d753ab71b3801981cfeff3"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_return &gt; </td></tr>
<tr class="memitem:ga0d67e207b3d753ab71b3801981cfeff3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1pointer__functor2.html">pointer_functor2</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_return &gt;, T_arg1, <br class="typebreak"/>
T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga0d67e207b3d753ab71b3801981cfeff3">retype</a> (const <a class="el" href="classsigc_1_1pointer__functor2.html">pointer_functor2</a>&lt; T_arg1, T_arg2, T_return &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga0d67e207b3d753ab71b3801981cfeff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga0d67e207b3d753ab71b3801981cfeff3">More...</a><br/></td></tr>
<tr class="separator:ga0d67e207b3d753ab71b3801981cfeff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5dfa926e3bfc7b82e0d14e4d9c9ff32"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return &gt; </td></tr>
<tr class="memitem:gaa5dfa926e3bfc7b82e0d14e4d9c9ff32"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1pointer__functor3.html">pointer_functor3</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_return &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gaa5dfa926e3bfc7b82e0d14e4d9c9ff32">retype</a> (const <a class="el" href="classsigc_1_1pointer__functor3.html">pointer_functor3</a>&lt; T_arg1, T_arg2, T_arg3, T_return &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:gaa5dfa926e3bfc7b82e0d14e4d9c9ff32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#gaa5dfa926e3bfc7b82e0d14e4d9c9ff32">More...</a><br/></td></tr>
<tr class="separator:gaa5dfa926e3bfc7b82e0d14e4d9c9ff32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade02a3d76cf35465acfa39d4e03a40d5"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return &gt; </td></tr>
<tr class="memitem:gade02a3d76cf35465acfa39d4e03a40d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1pointer__functor4.html">pointer_functor4</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, <br class="typebreak"/>
T_return &gt;, T_arg1, T_arg2, <br class="typebreak"/>
T_arg3, T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gade02a3d76cf35465acfa39d4e03a40d5">retype</a> (const <a class="el" href="classsigc_1_1pointer__functor4.html">pointer_functor4</a>&lt; T_arg1, T_arg2, T_arg3, T_arg4, T_return &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:gade02a3d76cf35465acfa39d4e03a40d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#gade02a3d76cf35465acfa39d4e03a40d5">More...</a><br/></td></tr>
<tr class="separator:gade02a3d76cf35465acfa39d4e03a40d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45fa726d6497c6b0994444fd2569581c"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return &gt; </td></tr>
<tr class="memitem:ga45fa726d6497c6b0994444fd2569581c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1pointer__functor5.html">pointer_functor5</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_return &gt;, T_arg1, T_arg2, <br class="typebreak"/>
T_arg3, T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga45fa726d6497c6b0994444fd2569581c">retype</a> (const <a class="el" href="classsigc_1_1pointer__functor5.html">pointer_functor5</a>&lt; T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_return &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga45fa726d6497c6b0994444fd2569581c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga45fa726d6497c6b0994444fd2569581c">More...</a><br/></td></tr>
<tr class="separator:ga45fa726d6497c6b0994444fd2569581c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24e30de09c3784220829f52bb068b8c0"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return &gt; </td></tr>
<tr class="memitem:ga24e30de09c3784220829f52bb068b8c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1pointer__functor6.html">pointer_functor6</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_return &gt;, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga24e30de09c3784220829f52bb068b8c0">retype</a> (const <a class="el" href="classsigc_1_1pointer__functor6.html">pointer_functor6</a>&lt; T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_return &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga24e30de09c3784220829f52bb068b8c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga24e30de09c3784220829f52bb068b8c0">More...</a><br/></td></tr>
<tr class="separator:ga24e30de09c3784220829f52bb068b8c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09db0b458651a7fcd985e5dd4e50caa0"><td class="memTemplParams" colspan="2">template&lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return &gt; </td></tr>
<tr class="memitem:ga09db0b458651a7fcd985e5dd4e50caa0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1pointer__functor7.html">pointer_functor7</a>&lt; T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7, T_return &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga09db0b458651a7fcd985e5dd4e50caa0">retype</a> (const <a class="el" href="classsigc_1_1pointer__functor7.html">pointer_functor7</a>&lt; T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7, T_return &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga09db0b458651a7fcd985e5dd4e50caa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga09db0b458651a7fcd985e5dd4e50caa0">More...</a><br/></td></tr>
<tr class="separator:ga09db0b458651a7fcd985e5dd4e50caa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb08dd87f3ec392536b656b6b3e959a0"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gabb08dd87f3ec392536b656b6b3e959a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1mem__functor0.html">mem_functor0</a><br class="typebreak"/>
&lt; T_return, T_obj &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gabb08dd87f3ec392536b656b6b3e959a0">retype</a> (const <a class="el" href="classsigc_1_1mem__functor0.html">mem_functor0</a>&lt; T_return, T_obj &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:gabb08dd87f3ec392536b656b6b3e959a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#gabb08dd87f3ec392536b656b6b3e959a0">More...</a><br/></td></tr>
<tr class="separator:gabb08dd87f3ec392536b656b6b3e959a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a2600190453d4eb11c14f99973044bc"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 &gt; </td></tr>
<tr class="memitem:ga5a2600190453d4eb11c14f99973044bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1mem__functor1.html">mem_functor1</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1 &gt;<br class="typebreak"/>
, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga5a2600190453d4eb11c14f99973044bc">retype</a> (const <a class="el" href="classsigc_1_1mem__functor1.html">mem_functor1</a>&lt; T_return, T_obj, T_arg1 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga5a2600190453d4eb11c14f99973044bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga5a2600190453d4eb11c14f99973044bc">More...</a><br/></td></tr>
<tr class="separator:ga5a2600190453d4eb11c14f99973044bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7df338186f09b1c89c2840f6744362e9"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:ga7df338186f09b1c89c2840f6744362e9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1mem__functor2.html">mem_functor2</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2 &gt;, T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga7df338186f09b1c89c2840f6744362e9">retype</a> (const <a class="el" href="classsigc_1_1mem__functor2.html">mem_functor2</a>&lt; T_return, T_obj, T_arg1, T_arg2 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga7df338186f09b1c89c2840f6744362e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga7df338186f09b1c89c2840f6744362e9">More...</a><br/></td></tr>
<tr class="separator:ga7df338186f09b1c89c2840f6744362e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2d9d2e91b2f8d256e4ad8da1c3c59e0"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 &gt; </td></tr>
<tr class="memitem:gae2d9d2e91b2f8d256e4ad8da1c3c59e0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1mem__functor3.html">mem_functor3</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gae2d9d2e91b2f8d256e4ad8da1c3c59e0">retype</a> (const <a class="el" href="classsigc_1_1mem__functor3.html">mem_functor3</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:gae2d9d2e91b2f8d256e4ad8da1c3c59e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#gae2d9d2e91b2f8d256e4ad8da1c3c59e0">More...</a><br/></td></tr>
<tr class="separator:gae2d9d2e91b2f8d256e4ad8da1c3c59e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70e615639e07e90a997a378cf877b106"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </td></tr>
<tr class="memitem:ga70e615639e07e90a997a378cf877b106"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1mem__functor4.html">mem_functor4</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga70e615639e07e90a997a378cf877b106">retype</a> (const <a class="el" href="classsigc_1_1mem__functor4.html">mem_functor4</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga70e615639e07e90a997a378cf877b106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga70e615639e07e90a997a378cf877b106">More...</a><br/></td></tr>
<tr class="separator:ga70e615639e07e90a997a378cf877b106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad225dee1d71c68d0ee71f3f0fedcfc1b"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </td></tr>
<tr class="memitem:gad225dee1d71c68d0ee71f3f0fedcfc1b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1mem__functor5.html">mem_functor5</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gad225dee1d71c68d0ee71f3f0fedcfc1b">retype</a> (const <a class="el" href="classsigc_1_1mem__functor5.html">mem_functor5</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:gad225dee1d71c68d0ee71f3f0fedcfc1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#gad225dee1d71c68d0ee71f3f0fedcfc1b">More...</a><br/></td></tr>
<tr class="separator:gad225dee1d71c68d0ee71f3f0fedcfc1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c08fe50076854f15c923ab4183aed0f"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </td></tr>
<tr class="memitem:ga9c08fe50076854f15c923ab4183aed0f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1mem__functor6.html">mem_functor6</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6 &gt;, T_arg1, T_arg2, <br class="typebreak"/>
T_arg3, T_arg4, T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga9c08fe50076854f15c923ab4183aed0f">retype</a> (const <a class="el" href="classsigc_1_1mem__functor6.html">mem_functor6</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga9c08fe50076854f15c923ab4183aed0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga9c08fe50076854f15c923ab4183aed0f">More...</a><br/></td></tr>
<tr class="separator:ga9c08fe50076854f15c923ab4183aed0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fbd72b71a4ea4fafa487b5932acd797"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr class="memitem:ga3fbd72b71a4ea4fafa487b5932acd797"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a>&lt; <a class="el" href="classsigc_1_1mem__functor7.html">mem_functor7</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga3fbd72b71a4ea4fafa487b5932acd797">retype</a> (const <a class="el" href="classsigc_1_1mem__functor7.html">mem_functor7</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga3fbd72b71a4ea4fafa487b5932acd797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga3fbd72b71a4ea4fafa487b5932acd797">More...</a><br/></td></tr>
<tr class="separator:ga3fbd72b71a4ea4fafa487b5932acd797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0688ca8eb3ee82e191563ba7f81366b2"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga0688ca8eb3ee82e191563ba7f81366b2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1const__mem__functor0.html">const_mem_functor0</a>&lt; T_return, <br class="typebreak"/>
T_obj &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga0688ca8eb3ee82e191563ba7f81366b2">retype</a> (const <a class="el" href="classsigc_1_1const__mem__functor0.html">const_mem_functor0</a>&lt; T_return, T_obj &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga0688ca8eb3ee82e191563ba7f81366b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga0688ca8eb3ee82e191563ba7f81366b2">More...</a><br/></td></tr>
<tr class="separator:ga0688ca8eb3ee82e191563ba7f81366b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae035134414ed79a187a6b41a115a3759"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 &gt; </td></tr>
<tr class="memitem:gae035134414ed79a187a6b41a115a3759"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1const__mem__functor1.html">const_mem_functor1</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1 &gt;, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gae035134414ed79a187a6b41a115a3759">retype</a> (const <a class="el" href="classsigc_1_1const__mem__functor1.html">const_mem_functor1</a>&lt; T_return, T_obj, T_arg1 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:gae035134414ed79a187a6b41a115a3759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#gae035134414ed79a187a6b41a115a3759">More...</a><br/></td></tr>
<tr class="separator:gae035134414ed79a187a6b41a115a3759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e9ee582f601451f3aa7c3d37d03b952"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:ga8e9ee582f601451f3aa7c3d37d03b952"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1const__mem__functor2.html">const_mem_functor2</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2 &gt;<br class="typebreak"/>
, T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga8e9ee582f601451f3aa7c3d37d03b952">retype</a> (const <a class="el" href="classsigc_1_1const__mem__functor2.html">const_mem_functor2</a>&lt; T_return, T_obj, T_arg1, T_arg2 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga8e9ee582f601451f3aa7c3d37d03b952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga8e9ee582f601451f3aa7c3d37d03b952">More...</a><br/></td></tr>
<tr class="separator:ga8e9ee582f601451f3aa7c3d37d03b952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81e06b857f7a44b0589125e28535f87f"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 &gt; </td></tr>
<tr class="memitem:ga81e06b857f7a44b0589125e28535f87f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1const__mem__functor3.html">const_mem_functor3</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga81e06b857f7a44b0589125e28535f87f">retype</a> (const <a class="el" href="classsigc_1_1const__mem__functor3.html">const_mem_functor3</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga81e06b857f7a44b0589125e28535f87f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga81e06b857f7a44b0589125e28535f87f">More...</a><br/></td></tr>
<tr class="separator:ga81e06b857f7a44b0589125e28535f87f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga411bdd3476f80d627c50d47149862ec2"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </td></tr>
<tr class="memitem:ga411bdd3476f80d627c50d47149862ec2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1const__mem__functor4.html">const_mem_functor4</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4 &gt;, T_arg1, T_arg2, <br class="typebreak"/>
T_arg3, T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga411bdd3476f80d627c50d47149862ec2">retype</a> (const <a class="el" href="classsigc_1_1const__mem__functor4.html">const_mem_functor4</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga411bdd3476f80d627c50d47149862ec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga411bdd3476f80d627c50d47149862ec2">More...</a><br/></td></tr>
<tr class="separator:ga411bdd3476f80d627c50d47149862ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga995053759ee8ee89663f9625a4aaf596"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </td></tr>
<tr class="memitem:ga995053759ee8ee89663f9625a4aaf596"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1const__mem__functor5.html">const_mem_functor5</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5 &gt;, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga995053759ee8ee89663f9625a4aaf596">retype</a> (const <a class="el" href="classsigc_1_1const__mem__functor5.html">const_mem_functor5</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga995053759ee8ee89663f9625a4aaf596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga995053759ee8ee89663f9625a4aaf596">More...</a><br/></td></tr>
<tr class="separator:ga995053759ee8ee89663f9625a4aaf596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga851188153c54bb1eb8fee425f9796981"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </td></tr>
<tr class="memitem:ga851188153c54bb1eb8fee425f9796981"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1const__mem__functor6.html">const_mem_functor6</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga851188153c54bb1eb8fee425f9796981">retype</a> (const <a class="el" href="classsigc_1_1const__mem__functor6.html">const_mem_functor6</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga851188153c54bb1eb8fee425f9796981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga851188153c54bb1eb8fee425f9796981">More...</a><br/></td></tr>
<tr class="separator:ga851188153c54bb1eb8fee425f9796981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa951debcabd066f8c3479617aaa9689e"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr class="memitem:gaa951debcabd066f8c3479617aaa9689e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1const__mem__functor7.html">const_mem_functor7</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6, T_arg7 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gaa951debcabd066f8c3479617aaa9689e">retype</a> (const <a class="el" href="classsigc_1_1const__mem__functor7.html">const_mem_functor7</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:gaa951debcabd066f8c3479617aaa9689e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#gaa951debcabd066f8c3479617aaa9689e">More...</a><br/></td></tr>
<tr class="separator:gaa951debcabd066f8c3479617aaa9689e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53d620659c82cbb84da3812ac874f4b7"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga53d620659c82cbb84da3812ac874f4b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1volatile__mem__functor0.html">volatile_mem_functor0</a><br class="typebreak"/>
&lt; T_return, T_obj &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga53d620659c82cbb84da3812ac874f4b7">retype</a> (const <a class="el" href="classsigc_1_1volatile__mem__functor0.html">volatile_mem_functor0</a>&lt; T_return, T_obj &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga53d620659c82cbb84da3812ac874f4b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga53d620659c82cbb84da3812ac874f4b7">More...</a><br/></td></tr>
<tr class="separator:ga53d620659c82cbb84da3812ac874f4b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d7f05b930056183bc7537447c80e59b"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 &gt; </td></tr>
<tr class="memitem:ga6d7f05b930056183bc7537447c80e59b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1volatile__mem__functor1.html">volatile_mem_functor1</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1 &gt;<br class="typebreak"/>
, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga6d7f05b930056183bc7537447c80e59b">retype</a> (const <a class="el" href="classsigc_1_1volatile__mem__functor1.html">volatile_mem_functor1</a>&lt; T_return, T_obj, T_arg1 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga6d7f05b930056183bc7537447c80e59b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga6d7f05b930056183bc7537447c80e59b">More...</a><br/></td></tr>
<tr class="separator:ga6d7f05b930056183bc7537447c80e59b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b65e9a9794300c40b1577302e006fbd"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:ga5b65e9a9794300c40b1577302e006fbd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1volatile__mem__functor2.html">volatile_mem_functor2</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2 &gt;, T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga5b65e9a9794300c40b1577302e006fbd">retype</a> (const <a class="el" href="classsigc_1_1volatile__mem__functor2.html">volatile_mem_functor2</a>&lt; T_return, T_obj, T_arg1, T_arg2 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga5b65e9a9794300c40b1577302e006fbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga5b65e9a9794300c40b1577302e006fbd">More...</a><br/></td></tr>
<tr class="separator:ga5b65e9a9794300c40b1577302e006fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55236721b80a72f40453d1b939316635"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 &gt; </td></tr>
<tr class="memitem:ga55236721b80a72f40453d1b939316635"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1volatile__mem__functor3.html">volatile_mem_functor3</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga55236721b80a72f40453d1b939316635">retype</a> (const <a class="el" href="classsigc_1_1volatile__mem__functor3.html">volatile_mem_functor3</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga55236721b80a72f40453d1b939316635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga55236721b80a72f40453d1b939316635">More...</a><br/></td></tr>
<tr class="separator:ga55236721b80a72f40453d1b939316635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05d2c3c043bed420ba8ba6f40f42f692"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </td></tr>
<tr class="memitem:ga05d2c3c043bed420ba8ba6f40f42f692"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1volatile__mem__functor4.html">volatile_mem_functor4</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga05d2c3c043bed420ba8ba6f40f42f692">retype</a> (const <a class="el" href="classsigc_1_1volatile__mem__functor4.html">volatile_mem_functor4</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga05d2c3c043bed420ba8ba6f40f42f692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga05d2c3c043bed420ba8ba6f40f42f692">More...</a><br/></td></tr>
<tr class="separator:ga05d2c3c043bed420ba8ba6f40f42f692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42be2d2fbf03fbaba1ad7d8cbbb8bce4"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </td></tr>
<tr class="memitem:ga42be2d2fbf03fbaba1ad7d8cbbb8bce4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1volatile__mem__functor5.html">volatile_mem_functor5</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga42be2d2fbf03fbaba1ad7d8cbbb8bce4">retype</a> (const <a class="el" href="classsigc_1_1volatile__mem__functor5.html">volatile_mem_functor5</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga42be2d2fbf03fbaba1ad7d8cbbb8bce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga42be2d2fbf03fbaba1ad7d8cbbb8bce4">More...</a><br/></td></tr>
<tr class="separator:ga42be2d2fbf03fbaba1ad7d8cbbb8bce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga255fac4b456d69d033b327b1d533f054"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </td></tr>
<tr class="memitem:ga255fac4b456d69d033b327b1d533f054"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1volatile__mem__functor6.html">volatile_mem_functor6</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6 &gt;, T_arg1, T_arg2, <br class="typebreak"/>
T_arg3, T_arg4, T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga255fac4b456d69d033b327b1d533f054">retype</a> (const <a class="el" href="classsigc_1_1volatile__mem__functor6.html">volatile_mem_functor6</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga255fac4b456d69d033b327b1d533f054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga255fac4b456d69d033b327b1d533f054">More...</a><br/></td></tr>
<tr class="separator:ga255fac4b456d69d033b327b1d533f054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37a057f88e6ffbb8d4172d6446116796"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr class="memitem:ga37a057f88e6ffbb8d4172d6446116796"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1volatile__mem__functor7.html">volatile_mem_functor7</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga37a057f88e6ffbb8d4172d6446116796">retype</a> (const <a class="el" href="classsigc_1_1volatile__mem__functor7.html">volatile_mem_functor7</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga37a057f88e6ffbb8d4172d6446116796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga37a057f88e6ffbb8d4172d6446116796">More...</a><br/></td></tr>
<tr class="separator:ga37a057f88e6ffbb8d4172d6446116796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga312fca59eb8b4ca0e078b1cf7f407212"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga312fca59eb8b4ca0e078b1cf7f407212"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1const__volatile__mem__functor0.html">const_volatile_mem_functor0</a><br class="typebreak"/>
&lt; T_return, T_obj &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga312fca59eb8b4ca0e078b1cf7f407212">retype</a> (const <a class="el" href="classsigc_1_1const__volatile__mem__functor0.html">const_volatile_mem_functor0</a>&lt; T_return, T_obj &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga312fca59eb8b4ca0e078b1cf7f407212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga312fca59eb8b4ca0e078b1cf7f407212">More...</a><br/></td></tr>
<tr class="separator:ga312fca59eb8b4ca0e078b1cf7f407212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84f4247ab4cc559aed835ccd943fab70"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 &gt; </td></tr>
<tr class="memitem:ga84f4247ab4cc559aed835ccd943fab70"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1const__volatile__mem__functor1.html">const_volatile_mem_functor1</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1 &gt;<br class="typebreak"/>
, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga84f4247ab4cc559aed835ccd943fab70">retype</a> (const <a class="el" href="classsigc_1_1const__volatile__mem__functor1.html">const_volatile_mem_functor1</a>&lt; T_return, T_obj, T_arg1 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga84f4247ab4cc559aed835ccd943fab70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga84f4247ab4cc559aed835ccd943fab70">More...</a><br/></td></tr>
<tr class="separator:ga84f4247ab4cc559aed835ccd943fab70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga271911579dfbac317a53f62f0773e420"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:ga271911579dfbac317a53f62f0773e420"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1const__volatile__mem__functor2.html">const_volatile_mem_functor2</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2 &gt;, T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga271911579dfbac317a53f62f0773e420">retype</a> (const <a class="el" href="classsigc_1_1const__volatile__mem__functor2.html">const_volatile_mem_functor2</a>&lt; T_return, T_obj, T_arg1, T_arg2 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga271911579dfbac317a53f62f0773e420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga271911579dfbac317a53f62f0773e420">More...</a><br/></td></tr>
<tr class="separator:ga271911579dfbac317a53f62f0773e420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97b4f14b5a7991eba60b635871d6a7f9"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 &gt; </td></tr>
<tr class="memitem:ga97b4f14b5a7991eba60b635871d6a7f9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1const__volatile__mem__functor3.html">const_volatile_mem_functor3</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga97b4f14b5a7991eba60b635871d6a7f9">retype</a> (const <a class="el" href="classsigc_1_1const__volatile__mem__functor3.html">const_volatile_mem_functor3</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga97b4f14b5a7991eba60b635871d6a7f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga97b4f14b5a7991eba60b635871d6a7f9">More...</a><br/></td></tr>
<tr class="separator:ga97b4f14b5a7991eba60b635871d6a7f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e9179cc61db0069db209bc7632b3dee"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </td></tr>
<tr class="memitem:ga4e9179cc61db0069db209bc7632b3dee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1const__volatile__mem__functor4.html">const_volatile_mem_functor4</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga4e9179cc61db0069db209bc7632b3dee">retype</a> (const <a class="el" href="classsigc_1_1const__volatile__mem__functor4.html">const_volatile_mem_functor4</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga4e9179cc61db0069db209bc7632b3dee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga4e9179cc61db0069db209bc7632b3dee">More...</a><br/></td></tr>
<tr class="separator:ga4e9179cc61db0069db209bc7632b3dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga637af7b3e60f5657dcd62e350ec76675"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </td></tr>
<tr class="memitem:ga637af7b3e60f5657dcd62e350ec76675"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1const__volatile__mem__functor5.html">const_volatile_mem_functor5</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga637af7b3e60f5657dcd62e350ec76675">retype</a> (const <a class="el" href="classsigc_1_1const__volatile__mem__functor5.html">const_volatile_mem_functor5</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga637af7b3e60f5657dcd62e350ec76675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga637af7b3e60f5657dcd62e350ec76675">More...</a><br/></td></tr>
<tr class="separator:ga637af7b3e60f5657dcd62e350ec76675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17ceafe96cdf3bd37ccd401f413f8748"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </td></tr>
<tr class="memitem:ga17ceafe96cdf3bd37ccd401f413f8748"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1const__volatile__mem__functor6.html">const_volatile_mem_functor6</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6 &gt;, T_arg1, T_arg2, <br class="typebreak"/>
T_arg3, T_arg4, T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga17ceafe96cdf3bd37ccd401f413f8748">retype</a> (const <a class="el" href="classsigc_1_1const__volatile__mem__functor6.html">const_volatile_mem_functor6</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga17ceafe96cdf3bd37ccd401f413f8748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga17ceafe96cdf3bd37ccd401f413f8748">More...</a><br/></td></tr>
<tr class="separator:ga17ceafe96cdf3bd37ccd401f413f8748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75578233ce4f47c5f610569a5ffe84cc"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr class="memitem:ga75578233ce4f47c5f610569a5ffe84cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1const__volatile__mem__functor7.html">const_volatile_mem_functor7</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga75578233ce4f47c5f610569a5ffe84cc">retype</a> (const <a class="el" href="classsigc_1_1const__volatile__mem__functor7.html">const_volatile_mem_functor7</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga75578233ce4f47c5f610569a5ffe84cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga75578233ce4f47c5f610569a5ffe84cc">More...</a><br/></td></tr>
<tr class="separator:ga75578233ce4f47c5f610569a5ffe84cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebe9c150af92e230257bbbdb728e5a07"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gaebe9c150af92e230257bbbdb728e5a07"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__mem__functor0.html">bound_mem_functor0</a>&lt; T_return, <br class="typebreak"/>
T_obj &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gaebe9c150af92e230257bbbdb728e5a07">retype</a> (const <a class="el" href="classsigc_1_1bound__mem__functor0.html">bound_mem_functor0</a>&lt; T_return, T_obj &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:gaebe9c150af92e230257bbbdb728e5a07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#gaebe9c150af92e230257bbbdb728e5a07">More...</a><br/></td></tr>
<tr class="separator:gaebe9c150af92e230257bbbdb728e5a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga971017d74a880ee10555ebd32483d188"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 &gt; </td></tr>
<tr class="memitem:ga971017d74a880ee10555ebd32483d188"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__mem__functor1.html">bound_mem_functor1</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1 &gt;, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga971017d74a880ee10555ebd32483d188">retype</a> (const <a class="el" href="classsigc_1_1bound__mem__functor1.html">bound_mem_functor1</a>&lt; T_return, T_obj, T_arg1 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga971017d74a880ee10555ebd32483d188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga971017d74a880ee10555ebd32483d188">More...</a><br/></td></tr>
<tr class="separator:ga971017d74a880ee10555ebd32483d188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddf62506fc01f1cdfcadef27e47f9b59"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:gaddf62506fc01f1cdfcadef27e47f9b59"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__mem__functor2.html">bound_mem_functor2</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2 &gt;<br class="typebreak"/>
, T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gaddf62506fc01f1cdfcadef27e47f9b59">retype</a> (const <a class="el" href="classsigc_1_1bound__mem__functor2.html">bound_mem_functor2</a>&lt; T_return, T_obj, T_arg1, T_arg2 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:gaddf62506fc01f1cdfcadef27e47f9b59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#gaddf62506fc01f1cdfcadef27e47f9b59">More...</a><br/></td></tr>
<tr class="separator:gaddf62506fc01f1cdfcadef27e47f9b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad916eb17d984df3b7da9b7d3d041168a"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 &gt; </td></tr>
<tr class="memitem:gad916eb17d984df3b7da9b7d3d041168a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__mem__functor3.html">bound_mem_functor3</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gad916eb17d984df3b7da9b7d3d041168a">retype</a> (const <a class="el" href="classsigc_1_1bound__mem__functor3.html">bound_mem_functor3</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:gad916eb17d984df3b7da9b7d3d041168a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#gad916eb17d984df3b7da9b7d3d041168a">More...</a><br/></td></tr>
<tr class="separator:gad916eb17d984df3b7da9b7d3d041168a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8362fa71a99b71b843205e0482b281fc"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </td></tr>
<tr class="memitem:ga8362fa71a99b71b843205e0482b281fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__mem__functor4.html">bound_mem_functor4</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4 &gt;, T_arg1, T_arg2, <br class="typebreak"/>
T_arg3, T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga8362fa71a99b71b843205e0482b281fc">retype</a> (const <a class="el" href="classsigc_1_1bound__mem__functor4.html">bound_mem_functor4</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga8362fa71a99b71b843205e0482b281fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga8362fa71a99b71b843205e0482b281fc">More...</a><br/></td></tr>
<tr class="separator:ga8362fa71a99b71b843205e0482b281fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c139b3254f5020de44a73c7dd795819"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </td></tr>
<tr class="memitem:ga9c139b3254f5020de44a73c7dd795819"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__mem__functor5.html">bound_mem_functor5</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5 &gt;, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga9c139b3254f5020de44a73c7dd795819">retype</a> (const <a class="el" href="classsigc_1_1bound__mem__functor5.html">bound_mem_functor5</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga9c139b3254f5020de44a73c7dd795819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga9c139b3254f5020de44a73c7dd795819">More...</a><br/></td></tr>
<tr class="separator:ga9c139b3254f5020de44a73c7dd795819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12e152b4340f83bd1f6cec92771fa82a"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </td></tr>
<tr class="memitem:ga12e152b4340f83bd1f6cec92771fa82a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__mem__functor6.html">bound_mem_functor6</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga12e152b4340f83bd1f6cec92771fa82a">retype</a> (const <a class="el" href="classsigc_1_1bound__mem__functor6.html">bound_mem_functor6</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga12e152b4340f83bd1f6cec92771fa82a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga12e152b4340f83bd1f6cec92771fa82a">More...</a><br/></td></tr>
<tr class="separator:ga12e152b4340f83bd1f6cec92771fa82a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadda8029b543d9b657f01e6ba9a9ef8fd"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr class="memitem:gadda8029b543d9b657f01e6ba9a9ef8fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__mem__functor7.html">bound_mem_functor7</a>&lt; T_return, <br class="typebreak"/>
T_obj, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6, T_arg7 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5, T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gadda8029b543d9b657f01e6ba9a9ef8fd">retype</a> (const <a class="el" href="classsigc_1_1bound__mem__functor7.html">bound_mem_functor7</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:gadda8029b543d9b657f01e6ba9a9ef8fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#gadda8029b543d9b657f01e6ba9a9ef8fd">More...</a><br/></td></tr>
<tr class="separator:gadda8029b543d9b657f01e6ba9a9ef8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31061f134d93297fd0b4f2d56efafbe3"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:ga31061f134d93297fd0b4f2d56efafbe3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__const__mem__functor0.html">bound_const_mem_functor0</a><br class="typebreak"/>
&lt; T_return, T_obj &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga31061f134d93297fd0b4f2d56efafbe3">retype</a> (const <a class="el" href="classsigc_1_1bound__const__mem__functor0.html">bound_const_mem_functor0</a>&lt; T_return, T_obj &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga31061f134d93297fd0b4f2d56efafbe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga31061f134d93297fd0b4f2d56efafbe3">More...</a><br/></td></tr>
<tr class="separator:ga31061f134d93297fd0b4f2d56efafbe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63ead6c4883a6553446594e6027dc96c"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 &gt; </td></tr>
<tr class="memitem:ga63ead6c4883a6553446594e6027dc96c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__const__mem__functor1.html">bound_const_mem_functor1</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1 &gt;<br class="typebreak"/>
, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga63ead6c4883a6553446594e6027dc96c">retype</a> (const <a class="el" href="classsigc_1_1bound__const__mem__functor1.html">bound_const_mem_functor1</a>&lt; T_return, T_obj, T_arg1 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga63ead6c4883a6553446594e6027dc96c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga63ead6c4883a6553446594e6027dc96c">More...</a><br/></td></tr>
<tr class="separator:ga63ead6c4883a6553446594e6027dc96c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga415bd3f44f1785ce30452a4ca8e46dd0"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:ga415bd3f44f1785ce30452a4ca8e46dd0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__const__mem__functor2.html">bound_const_mem_functor2</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2 &gt;, T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga415bd3f44f1785ce30452a4ca8e46dd0">retype</a> (const <a class="el" href="classsigc_1_1bound__const__mem__functor2.html">bound_const_mem_functor2</a>&lt; T_return, T_obj, T_arg1, T_arg2 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga415bd3f44f1785ce30452a4ca8e46dd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga415bd3f44f1785ce30452a4ca8e46dd0">More...</a><br/></td></tr>
<tr class="separator:ga415bd3f44f1785ce30452a4ca8e46dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f86026b9959cdd62287b29407c71e97"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 &gt; </td></tr>
<tr class="memitem:ga6f86026b9959cdd62287b29407c71e97"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__const__mem__functor3.html">bound_const_mem_functor3</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga6f86026b9959cdd62287b29407c71e97">retype</a> (const <a class="el" href="classsigc_1_1bound__const__mem__functor3.html">bound_const_mem_functor3</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga6f86026b9959cdd62287b29407c71e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga6f86026b9959cdd62287b29407c71e97">More...</a><br/></td></tr>
<tr class="separator:ga6f86026b9959cdd62287b29407c71e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fbc58cc94f7f4a46c1557091974a278"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </td></tr>
<tr class="memitem:ga8fbc58cc94f7f4a46c1557091974a278"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__const__mem__functor4.html">bound_const_mem_functor4</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga8fbc58cc94f7f4a46c1557091974a278">retype</a> (const <a class="el" href="classsigc_1_1bound__const__mem__functor4.html">bound_const_mem_functor4</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga8fbc58cc94f7f4a46c1557091974a278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga8fbc58cc94f7f4a46c1557091974a278">More...</a><br/></td></tr>
<tr class="separator:ga8fbc58cc94f7f4a46c1557091974a278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d0d963fa703a6f85b8002c3a405c00a"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </td></tr>
<tr class="memitem:ga1d0d963fa703a6f85b8002c3a405c00a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__const__mem__functor5.html">bound_const_mem_functor5</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga1d0d963fa703a6f85b8002c3a405c00a">retype</a> (const <a class="el" href="classsigc_1_1bound__const__mem__functor5.html">bound_const_mem_functor5</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga1d0d963fa703a6f85b8002c3a405c00a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga1d0d963fa703a6f85b8002c3a405c00a">More...</a><br/></td></tr>
<tr class="separator:ga1d0d963fa703a6f85b8002c3a405c00a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39ba6af86d75de1535e4fa8af1e6081b"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </td></tr>
<tr class="memitem:ga39ba6af86d75de1535e4fa8af1e6081b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__const__mem__functor6.html">bound_const_mem_functor6</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6 &gt;, T_arg1, T_arg2, <br class="typebreak"/>
T_arg3, T_arg4, T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga39ba6af86d75de1535e4fa8af1e6081b">retype</a> (const <a class="el" href="classsigc_1_1bound__const__mem__functor6.html">bound_const_mem_functor6</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga39ba6af86d75de1535e4fa8af1e6081b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga39ba6af86d75de1535e4fa8af1e6081b">More...</a><br/></td></tr>
<tr class="separator:ga39ba6af86d75de1535e4fa8af1e6081b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02a44f2ea2386f8e4fa41cb582c2008d"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr class="memitem:ga02a44f2ea2386f8e4fa41cb582c2008d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__const__mem__functor7.html">bound_const_mem_functor7</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga02a44f2ea2386f8e4fa41cb582c2008d">retype</a> (const <a class="el" href="classsigc_1_1bound__const__mem__functor7.html">bound_const_mem_functor7</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga02a44f2ea2386f8e4fa41cb582c2008d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga02a44f2ea2386f8e4fa41cb582c2008d">More...</a><br/></td></tr>
<tr class="separator:ga02a44f2ea2386f8e4fa41cb582c2008d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc01bb77132048902ec8965d012edcd3"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gadc01bb77132048902ec8965d012edcd3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html">bound_volatile_mem_functor0</a><br class="typebreak"/>
&lt; T_return, T_obj &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gadc01bb77132048902ec8965d012edcd3">retype</a> (const <a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html">bound_volatile_mem_functor0</a>&lt; T_return, T_obj &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:gadc01bb77132048902ec8965d012edcd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#gadc01bb77132048902ec8965d012edcd3">More...</a><br/></td></tr>
<tr class="separator:gadc01bb77132048902ec8965d012edcd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45b921820c277072b6f7e856ddbcfca1"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 &gt; </td></tr>
<tr class="memitem:ga45b921820c277072b6f7e856ddbcfca1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html">bound_volatile_mem_functor1</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1 &gt;<br class="typebreak"/>
, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga45b921820c277072b6f7e856ddbcfca1">retype</a> (const <a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html">bound_volatile_mem_functor1</a>&lt; T_return, T_obj, T_arg1 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga45b921820c277072b6f7e856ddbcfca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga45b921820c277072b6f7e856ddbcfca1">More...</a><br/></td></tr>
<tr class="separator:ga45b921820c277072b6f7e856ddbcfca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf420d79b4077b848ef1aef4b68810d6e"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:gaf420d79b4077b848ef1aef4b68810d6e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html">bound_volatile_mem_functor2</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2 &gt;, T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gaf420d79b4077b848ef1aef4b68810d6e">retype</a> (const <a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html">bound_volatile_mem_functor2</a>&lt; T_return, T_obj, T_arg1, T_arg2 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:gaf420d79b4077b848ef1aef4b68810d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#gaf420d79b4077b848ef1aef4b68810d6e">More...</a><br/></td></tr>
<tr class="separator:gaf420d79b4077b848ef1aef4b68810d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga899ae79da0e918ad9fc8f2c8e8066218"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 &gt; </td></tr>
<tr class="memitem:ga899ae79da0e918ad9fc8f2c8e8066218"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html">bound_volatile_mem_functor3</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga899ae79da0e918ad9fc8f2c8e8066218">retype</a> (const <a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html">bound_volatile_mem_functor3</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga899ae79da0e918ad9fc8f2c8e8066218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga899ae79da0e918ad9fc8f2c8e8066218">More...</a><br/></td></tr>
<tr class="separator:ga899ae79da0e918ad9fc8f2c8e8066218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8540037bfd4da57495b60dd9487c6d0b"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </td></tr>
<tr class="memitem:ga8540037bfd4da57495b60dd9487c6d0b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html">bound_volatile_mem_functor4</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga8540037bfd4da57495b60dd9487c6d0b">retype</a> (const <a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html">bound_volatile_mem_functor4</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga8540037bfd4da57495b60dd9487c6d0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga8540037bfd4da57495b60dd9487c6d0b">More...</a><br/></td></tr>
<tr class="separator:ga8540037bfd4da57495b60dd9487c6d0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31ace8220cbb70b8e7f545ee4c1b6610"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </td></tr>
<tr class="memitem:ga31ace8220cbb70b8e7f545ee4c1b6610"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html">bound_volatile_mem_functor5</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga31ace8220cbb70b8e7f545ee4c1b6610">retype</a> (const <a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html">bound_volatile_mem_functor5</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga31ace8220cbb70b8e7f545ee4c1b6610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga31ace8220cbb70b8e7f545ee4c1b6610">More...</a><br/></td></tr>
<tr class="separator:ga31ace8220cbb70b8e7f545ee4c1b6610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f45f05c95abc9d20ae9d39589f5d72e"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </td></tr>
<tr class="memitem:ga9f45f05c95abc9d20ae9d39589f5d72e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html">bound_volatile_mem_functor6</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6 &gt;, T_arg1, T_arg2, <br class="typebreak"/>
T_arg3, T_arg4, T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga9f45f05c95abc9d20ae9d39589f5d72e">retype</a> (const <a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html">bound_volatile_mem_functor6</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga9f45f05c95abc9d20ae9d39589f5d72e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga9f45f05c95abc9d20ae9d39589f5d72e">More...</a><br/></td></tr>
<tr class="separator:ga9f45f05c95abc9d20ae9d39589f5d72e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17e8761db2fafa2d3a92d19d8ce47511"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr class="memitem:ga17e8761db2fafa2d3a92d19d8ce47511"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html">bound_volatile_mem_functor7</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga17e8761db2fafa2d3a92d19d8ce47511">retype</a> (const <a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html">bound_volatile_mem_functor7</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga17e8761db2fafa2d3a92d19d8ce47511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga17e8761db2fafa2d3a92d19d8ce47511">More...</a><br/></td></tr>
<tr class="separator:ga17e8761db2fafa2d3a92d19d8ce47511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade9ed42b368ea6eee6d42c8116cd28dd"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj &gt; </td></tr>
<tr class="memitem:gade9ed42b368ea6eee6d42c8116cd28dd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">bound_const_volatile_mem_functor0</a><br class="typebreak"/>
&lt; T_return, T_obj &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gade9ed42b368ea6eee6d42c8116cd28dd">retype</a> (const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">bound_const_volatile_mem_functor0</a>&lt; T_return, T_obj &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:gade9ed42b368ea6eee6d42c8116cd28dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#gade9ed42b368ea6eee6d42c8116cd28dd">More...</a><br/></td></tr>
<tr class="separator:gade9ed42b368ea6eee6d42c8116cd28dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab22de279058fd53d5ef720ad3932b56"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 &gt; </td></tr>
<tr class="memitem:gaab22de279058fd53d5ef720ad3932b56"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">bound_const_volatile_mem_functor1</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1 &gt;<br class="typebreak"/>
, T_arg1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gaab22de279058fd53d5ef720ad3932b56">retype</a> (const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">bound_const_volatile_mem_functor1</a>&lt; T_return, T_obj, T_arg1 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:gaab22de279058fd53d5ef720ad3932b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#gaab22de279058fd53d5ef720ad3932b56">More...</a><br/></td></tr>
<tr class="separator:gaab22de279058fd53d5ef720ad3932b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42f7c6ae10273b6577909f89bd76dc1f"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 &gt; </td></tr>
<tr class="memitem:ga42f7c6ae10273b6577909f89bd76dc1f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">bound_const_volatile_mem_functor2</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2 &gt;, T_arg1, T_arg2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga42f7c6ae10273b6577909f89bd76dc1f">retype</a> (const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">bound_const_volatile_mem_functor2</a>&lt; T_return, T_obj, T_arg1, T_arg2 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga42f7c6ae10273b6577909f89bd76dc1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga42f7c6ae10273b6577909f89bd76dc1f">More...</a><br/></td></tr>
<tr class="separator:ga42f7c6ae10273b6577909f89bd76dc1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b2477c6ed3347fae35c66f25977f9dc"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 &gt; </td></tr>
<tr class="memitem:ga1b2477c6ed3347fae35c66f25977f9dc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">bound_const_volatile_mem_functor3</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga1b2477c6ed3347fae35c66f25977f9dc">retype</a> (const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">bound_const_volatile_mem_functor3</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga1b2477c6ed3347fae35c66f25977f9dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga1b2477c6ed3347fae35c66f25977f9dc">More...</a><br/></td></tr>
<tr class="separator:ga1b2477c6ed3347fae35c66f25977f9dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad73b9445fab1544d7550db964426520d"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 &gt; </td></tr>
<tr class="memitem:gad73b9445fab1544d7550db964426520d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">bound_const_volatile_mem_functor4</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gad73b9445fab1544d7550db964426520d">retype</a> (const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">bound_const_volatile_mem_functor4</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:gad73b9445fab1544d7550db964426520d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#gad73b9445fab1544d7550db964426520d">More...</a><br/></td></tr>
<tr class="separator:gad73b9445fab1544d7550db964426520d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbb4a1e1c3447205bf507d6912847015"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 &gt; </td></tr>
<tr class="memitem:gacbb4a1e1c3447205bf507d6912847015"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">bound_const_volatile_mem_functor5</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5 &gt;<br class="typebreak"/>
, T_arg1, T_arg2, T_arg3, <br class="typebreak"/>
T_arg4, T_arg5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gacbb4a1e1c3447205bf507d6912847015">retype</a> (const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">bound_const_volatile_mem_functor5</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:gacbb4a1e1c3447205bf507d6912847015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#gacbb4a1e1c3447205bf507d6912847015">More...</a><br/></td></tr>
<tr class="separator:gacbb4a1e1c3447205bf507d6912847015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace1ef4f9ca35373adaad3c29db2b918f"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 &gt; </td></tr>
<tr class="memitem:gace1ef4f9ca35373adaad3c29db2b918f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">bound_const_volatile_mem_functor6</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6 &gt;, T_arg1, T_arg2, <br class="typebreak"/>
T_arg3, T_arg4, T_arg5, T_arg6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#gace1ef4f9ca35373adaad3c29db2b918f">retype</a> (const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">bound_const_volatile_mem_functor6</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:gace1ef4f9ca35373adaad3c29db2b918f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#gace1ef4f9ca35373adaad3c29db2b918f">More...</a><br/></td></tr>
<tr class="separator:gace1ef4f9ca35373adaad3c29db2b918f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ec0f19b59050f8f01c8969835b3c742"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_obj , class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 &gt; </td></tr>
<tr class="memitem:ga1ec0f19b59050f8f01c8969835b3c742"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__functor.html">retype_functor</a><br class="typebreak"/>
&lt; <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">bound_const_volatile_mem_functor7</a><br class="typebreak"/>
&lt; T_return, T_obj, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;, T_arg1, <br class="typebreak"/>
T_arg2, T_arg3, T_arg4, T_arg5, <br class="typebreak"/>
T_arg6, T_arg7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga1ec0f19b59050f8f01c8969835b3c742">retype</a> (const <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">bound_const_volatile_mem_functor7</a>&lt; T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7 &gt;&amp; _A_functor)</td></tr>
<tr class="memdesc:ga1ec0f19b59050f8f01c8969835b3c742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__functor.html" title="Adaptor that performs C-style casts on the parameters passed on to the functor. ">sigc::retype_functor</a> which performs C-style casts on the parameters passed on to the functor.  <a href="group__retype.html#ga1ec0f19b59050f8f01c8969835b3c742">More...</a><br/></td></tr>
<tr class="separator:ga1ec0f19b59050f8f01c8969835b3c742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23a8cdbc12c57fbef0866b5c51d71588"><td class="memTemplParams" colspan="2">template&lt;class T_return , class T_functor &gt; </td></tr>
<tr class="memitem:ga23a8cdbc12c57fbef0866b5c51d71588"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1retype__return__functor.html">retype_return_functor</a><br class="typebreak"/>
&lt; T_return, T_functor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__retype.html#ga23a8cdbc12c57fbef0866b5c51d71588">retype_return</a> (const T_functor&amp; _A_functor)</td></tr>
<tr class="memdesc:ga23a8cdbc12c57fbef0866b5c51d71588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="structsigc_1_1retype__return__functor.html" title="Adaptor that performs a C-style cast on the return value of a functor. ">sigc::retype_return_functor</a> which performs a C-style cast on the return value of the passed functor.  <a href="group__retype.html#ga23a8cdbc12c57fbef0866b5c51d71588">More...</a><br/></td></tr>
<tr class="separator:ga23a8cdbc12c57fbef0866b5c51d71588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fd1ab36d123ff83dd4cd8dc58bb28e2"><td class="memTemplParams" colspan="2">template&lt;typename T_functor , typename T_obj1 &gt; </td></tr>
<tr class="memitem:ga8fd1ab36d123ff83dd4cd8dc58bb28e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1track__obj__functor1.html">track_obj_functor1</a>&lt; T_functor, <br class="typebreak"/>
T_obj1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__track__obj.html#ga8fd1ab36d123ff83dd4cd8dc58bb28e2">track_obj</a> (const T_functor&amp; _A_func, const T_obj1&amp; _A_obj1)</td></tr>
<tr class="memdesc:ga8fd1ab36d123ff83dd4cd8dc58bb28e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="classsigc_1_1track__obj__functor1.html" title="track_obj_functor1 wraps a functor and stores a reference to a trackable object. ">sigc::track_obj_functor1</a> which wraps a functor.  <a href="group__track__obj.html#ga8fd1ab36d123ff83dd4cd8dc58bb28e2">More...</a><br/></td></tr>
<tr class="separator:ga8fd1ab36d123ff83dd4cd8dc58bb28e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60842510c2387ec49c43149d94fb1b72"><td class="memTemplParams" colspan="2">template&lt;typename T_functor , typename T_obj1 , typename T_obj2 &gt; </td></tr>
<tr class="memitem:ga60842510c2387ec49c43149d94fb1b72"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1track__obj__functor2.html">track_obj_functor2</a>&lt; T_functor, <br class="typebreak"/>
T_obj1, T_obj2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__track__obj.html#ga60842510c2387ec49c43149d94fb1b72">track_obj</a> (const T_functor&amp; _A_func, const T_obj1&amp; _A_obj1, const T_obj2&amp; _A_obj2)</td></tr>
<tr class="memdesc:ga60842510c2387ec49c43149d94fb1b72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="classsigc_1_1track__obj__functor2.html" title="track_obj_functor2 wraps a functor and stores 2 references to trackable objects. ">sigc::track_obj_functor2</a> which wraps a functor.  <a href="group__track__obj.html#ga60842510c2387ec49c43149d94fb1b72">More...</a><br/></td></tr>
<tr class="separator:ga60842510c2387ec49c43149d94fb1b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52b11304cb05441237a8dcc651cb724e"><td class="memTemplParams" colspan="2">template&lt;typename T_functor , typename T_obj1 , typename T_obj2 , typename T_obj3 &gt; </td></tr>
<tr class="memitem:ga52b11304cb05441237a8dcc651cb724e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1track__obj__functor3.html">track_obj_functor3</a>&lt; T_functor, <br class="typebreak"/>
T_obj1, T_obj2, T_obj3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__track__obj.html#ga52b11304cb05441237a8dcc651cb724e">track_obj</a> (const T_functor&amp; _A_func, const T_obj1&amp; _A_obj1, const T_obj2&amp; _A_obj2, const T_obj3&amp; _A_obj3)</td></tr>
<tr class="memdesc:ga52b11304cb05441237a8dcc651cb724e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="classsigc_1_1track__obj__functor3.html" title="track_obj_functor3 wraps a functor and stores 3 references to trackable objects. ">sigc::track_obj_functor3</a> which wraps a functor.  <a href="group__track__obj.html#ga52b11304cb05441237a8dcc651cb724e">More...</a><br/></td></tr>
<tr class="separator:ga52b11304cb05441237a8dcc651cb724e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea44f2388c18ca8508818ff6b7756216"><td class="memTemplParams" colspan="2">template&lt;typename T_functor , typename T_obj1 , typename T_obj2 , typename T_obj3 , typename T_obj4 &gt; </td></tr>
<tr class="memitem:gaea44f2388c18ca8508818ff6b7756216"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1track__obj__functor4.html">track_obj_functor4</a>&lt; T_functor, <br class="typebreak"/>
T_obj1, T_obj2, T_obj3, T_obj4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__track__obj.html#gaea44f2388c18ca8508818ff6b7756216">track_obj</a> (const T_functor&amp; _A_func, const T_obj1&amp; _A_obj1, const T_obj2&amp; _A_obj2, const T_obj3&amp; _A_obj3, const T_obj4&amp; _A_obj4)</td></tr>
<tr class="memdesc:gaea44f2388c18ca8508818ff6b7756216"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="classsigc_1_1track__obj__functor4.html" title="track_obj_functor4 wraps a functor and stores 4 references to trackable objects. ">sigc::track_obj_functor4</a> which wraps a functor.  <a href="group__track__obj.html#gaea44f2388c18ca8508818ff6b7756216">More...</a><br/></td></tr>
<tr class="separator:gaea44f2388c18ca8508818ff6b7756216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga337dc48ba1e394f572d5d914b83f57a0"><td class="memTemplParams" colspan="2">template&lt;typename T_functor , typename T_obj1 , typename T_obj2 , typename T_obj3 , typename T_obj4 , typename T_obj5 &gt; </td></tr>
<tr class="memitem:ga337dc48ba1e394f572d5d914b83f57a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1track__obj__functor5.html">track_obj_functor5</a>&lt; T_functor, <br class="typebreak"/>
T_obj1, T_obj2, T_obj3, T_obj4, <br class="typebreak"/>
T_obj5 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__track__obj.html#ga337dc48ba1e394f572d5d914b83f57a0">track_obj</a> (const T_functor&amp; _A_func, const T_obj1&amp; _A_obj1, const T_obj2&amp; _A_obj2, const T_obj3&amp; _A_obj3, const T_obj4&amp; _A_obj4, const T_obj5&amp; _A_obj5)</td></tr>
<tr class="memdesc:ga337dc48ba1e394f572d5d914b83f57a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="classsigc_1_1track__obj__functor5.html" title="track_obj_functor5 wraps a functor and stores 5 references to trackable objects. ">sigc::track_obj_functor5</a> which wraps a functor.  <a href="group__track__obj.html#ga337dc48ba1e394f572d5d914b83f57a0">More...</a><br/></td></tr>
<tr class="separator:ga337dc48ba1e394f572d5d914b83f57a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0304ca1269ed352fcc1c81324062302e"><td class="memTemplParams" colspan="2">template&lt;typename T_functor , typename T_obj1 , typename T_obj2 , typename T_obj3 , typename T_obj4 , typename T_obj5 , typename T_obj6 &gt; </td></tr>
<tr class="memitem:ga0304ca1269ed352fcc1c81324062302e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1track__obj__functor6.html">track_obj_functor6</a>&lt; T_functor, <br class="typebreak"/>
T_obj1, T_obj2, T_obj3, T_obj4, <br class="typebreak"/>
T_obj5, T_obj6 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__track__obj.html#ga0304ca1269ed352fcc1c81324062302e">track_obj</a> (const T_functor&amp; _A_func, const T_obj1&amp; _A_obj1, const T_obj2&amp; _A_obj2, const T_obj3&amp; _A_obj3, const T_obj4&amp; _A_obj4, const T_obj5&amp; _A_obj5, const T_obj6&amp; _A_obj6)</td></tr>
<tr class="memdesc:ga0304ca1269ed352fcc1c81324062302e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="classsigc_1_1track__obj__functor6.html" title="track_obj_functor6 wraps a functor and stores 6 references to trackable objects. ">sigc::track_obj_functor6</a> which wraps a functor.  <a href="group__track__obj.html#ga0304ca1269ed352fcc1c81324062302e">More...</a><br/></td></tr>
<tr class="separator:ga0304ca1269ed352fcc1c81324062302e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ea3e9f52643d7ab1bcfa4f419e7d38f"><td class="memTemplParams" colspan="2">template&lt;typename T_functor , typename T_obj1 , typename T_obj2 , typename T_obj3 , typename T_obj4 , typename T_obj5 , typename T_obj6 , typename T_obj7 &gt; </td></tr>
<tr class="memitem:ga5ea3e9f52643d7ab1bcfa4f419e7d38f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsigc_1_1track__obj__functor7.html">track_obj_functor7</a>&lt; T_functor, <br class="typebreak"/>
T_obj1, T_obj2, T_obj3, T_obj4, <br class="typebreak"/>
T_obj5, T_obj6, T_obj7 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__track__obj.html#ga5ea3e9f52643d7ab1bcfa4f419e7d38f">track_obj</a> (const T_functor&amp; _A_func, const T_obj1&amp; _A_obj1, const T_obj2&amp; _A_obj2, const T_obj3&amp; _A_obj3, const T_obj4&amp; _A_obj4, const T_obj5&amp; _A_obj5, const T_obj6&amp; _A_obj6, const T_obj7&amp; _A_obj7)</td></tr>
<tr class="memdesc:ga5ea3e9f52643d7ab1bcfa4f419e7d38f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an adaptor of type <a class="el" href="classsigc_1_1track__obj__functor7.html" title="track_obj_functor7 wraps a functor and stores 7 references to trackable objects. ">sigc::track_obj_functor7</a> which wraps a functor.  <a href="group__track__obj.html#ga5ea3e9f52643d7ab1bcfa4f419e7d38f">More...</a><br/></td></tr>
<tr class="separator:ga5ea3e9f52643d7ab1bcfa4f419e7d38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5529822bdaf60f07456633e0f40282"><td class="memTemplParams" colspan="2">template&lt;class T_type &gt; </td></tr>
<tr class="memitem:a3b5529822bdaf60f07456633e0f40282"><td class="memTemplItemLeft" align="right" valign="top">T_type&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#a3b5529822bdaf60f07456633e0f40282">unwrap</a> (const <a class="el" href="structsigc_1_1reference__wrapper.html">reference_wrapper</a>&lt; T_type &gt;&amp; v)</td></tr>
<tr class="separator:a3b5529822bdaf60f07456633e0f40282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f758c77e8743093f938d0c5dbf06778"><td class="memTemplParams" colspan="2">template&lt;class T_type &gt; </td></tr>
<tr class="memitem:a2f758c77e8743093f938d0c5dbf06778"><td class="memTemplItemLeft" align="right" valign="top">const T_type&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesigc.html#a2f758c77e8743093f938d0c5dbf06778">unwrap</a> (const <a class="el" href="structsigc_1_1const__reference__wrapper.html">const_reference_wrapper</a>&lt; T_type &gt;&amp; v)</td></tr>
<tr class="separator:a2f758c77e8743093f938d0c5dbf06778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fbbd890bbed369b5a77ef375a34ab47"><td class="memTemplParams" colspan="2">template&lt;class T_type &gt; </td></tr>
<tr class="memitem:ga5fbbd890bbed369b5a77ef375a34ab47"><td class="memTemplItemLeft" align="right" valign="top">T_type&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lambdas.html#ga5fbbd890bbed369b5a77ef375a34ab47">unwrap_lambda_value</a> (T_type&amp; a)</td></tr>
<tr class="memdesc:ga5fbbd890bbed369b5a77ef375a34ab47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the object stored inside a lambda object.  <a href="group__lambdas.html#ga5fbbd890bbed369b5a77ef375a34ab47">More...</a><br/></td></tr>
<tr class="separator:ga5fbbd890bbed369b5a77ef375a34ab47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23fcae89c45fa2f28ed2ed421b2249ca"><td class="memTemplParams" colspan="2">template&lt;class T_type &gt; </td></tr>
<tr class="memitem:ga23fcae89c45fa2f28ed2ed421b2249ca"><td class="memTemplItemLeft" align="right" valign="top">const T_type&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lambdas.html#ga23fcae89c45fa2f28ed2ed421b2249ca">unwrap_lambda_value</a> (const T_type&amp; a)</td></tr>
<tr class="memdesc:ga23fcae89c45fa2f28ed2ed421b2249ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the object stored inside a lambda object.  <a href="group__lambdas.html#ga23fcae89c45fa2f28ed2ed421b2249ca">More...</a><br/></td></tr>
<tr class="separator:ga23fcae89c45fa2f28ed2ed421b2249ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga075ab6d364e385be8ff683fb6c24151f"><td class="memTemplParams" colspan="2">template&lt;class T_type &gt; </td></tr>
<tr class="memitem:ga075ab6d364e385be8ff683fb6c24151f"><td class="memTemplItemLeft" align="right" valign="top">const T_type&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lambdas.html#ga075ab6d364e385be8ff683fb6c24151f">unwrap_lambda_value</a> (const <a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_type &gt;&amp; a)</td></tr>
<tr class="memdesc:ga075ab6d364e385be8ff683fb6c24151f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the object stored inside a lambda object.  <a href="group__lambdas.html#ga075ab6d364e385be8ff683fb6c24151f">More...</a><br/></td></tr>
<tr class="separator:ga075ab6d364e385be8ff683fb6c24151f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e560e6113af0c1e9f462471c1d502d4"><td class="memTemplParams" colspan="2">template&lt;class T_type &gt; </td></tr>
<tr class="memitem:ga8e560e6113af0c1e9f462471c1d502d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; T_type&amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lambdas.html#ga8e560e6113af0c1e9f462471c1d502d4">var</a> (T_type&amp; v)</td></tr>
<tr class="memdesc:ga8e560e6113af0c1e9f462471c1d502d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a reference into a lambda object.  <a href="group__lambdas.html#ga8e560e6113af0c1e9f462471c1d502d4">More...</a><br/></td></tr>
<tr class="separator:ga8e560e6113af0c1e9f462471c1d502d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c51a04bb54990fe3d508fa06e574249"><td class="memTemplParams" colspan="2">template&lt;class T_type &gt; </td></tr>
<tr class="memitem:ga5c51a04bb54990fe3d508fa06e574249"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsigc_1_1lambda.html">lambda</a>&lt; const T_type&amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__lambdas.html#ga5c51a04bb54990fe3d508fa06e574249">var</a> (const T_type&amp; v)</td></tr>
<tr class="memdesc:ga5c51a04bb54990fe3d508fa06e574249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a constant reference into a lambda object.  <a href="group__lambdas.html#ga5c51a04bb54990fe3d508fa06e574249">More...</a><br/></td></tr>
<tr class="separator:ga5c51a04bb54990fe3d508fa06e574249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64cb7832acc1e58efb5ffe0b4f5e9404"><td class="memTemplParams" colspan="2">template&lt;class T_action , class T_functor &gt; </td></tr>
<tr class="memitem:ga64cb7832acc1e58efb5ffe0b4f5e9404"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sigcfunctors.html#ga64cb7832acc1e58efb5ffe0b4f5e9404">visit_each</a> (const T_action&amp; _A_action, const T_functor&amp; _A_functor)</td></tr>
<tr class="memdesc:ga64cb7832acc1e58efb5ffe0b4f5e9404"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs a functor on each of the targets of a functor.  <a href="group__sigcfunctors.html#ga64cb7832acc1e58efb5ffe0b4f5e9404">More...</a><br/></td></tr>
<tr class="separator:ga64cb7832acc1e58efb5ffe0b4f5e9404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada222d975b87d64cfa7a7f29244ae587"><td class="memTemplParams" colspan="2">template&lt;class T_type , class T_action , class T_functor &gt; </td></tr>
<tr class="memitem:gada222d975b87d64cfa7a7f29244ae587"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sigcfunctors.html#gada222d975b87d64cfa7a7f29244ae587">visit_each_type</a> (const T_action&amp; _A_action, const T_functor&amp; _A_functor)</td></tr>
<tr class="memdesc:gada222d975b87d64cfa7a7f29244ae587"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs a functor on each of the targets of a functor limited to a restricted type.  <a href="group__sigcfunctors.html#gada222d975b87d64cfa7a7f29244ae587">More...</a><br/></td></tr>
<tr class="separator:gada222d975b87d64cfa7a7f29244ae587"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The libsigc++ namespace. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a0ae3b8a1ba26920cee4d7d9df2c39ed9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_functor , class T_catcher &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1exception__catch__functor.html">exception_catch_functor</a>&lt;T_functor, T_catcher&gt; sigc::exception_catch </td>
          <td>(</td>
          <td class="paramtype">const T_functor &amp;&#160;</td>
          <td class="paramname"><em>_A_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_catcher &amp;&#160;</td>
          <td class="paramname"><em>_A_catcher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gadf6b6d22c503b439019f0a2e77352419"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1const__mem__functor0.html">const_mem_functor0</a>&lt;T_return, T_obj&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)() const&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor0.html" title="const_mem_functor0 wraps const methods with 0 argument(s). ">sigc::const_mem_functor0</a> which wraps a const method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gab661fef0f04e2e439912eee6989e9657"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1const__mem__functor1.html">const_mem_functor1</a>&lt;T_return, T_obj, T_arg1&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1) const&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor1.html" title="const_mem_functor1 wraps const methods with 1 argument(s). ">sigc::const_mem_functor1</a> which wraps a const method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4bcfe2d4b91ff49bc8bf27af5a5f3bc5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1const__mem__functor2.html">const_mem_functor2</a>&lt;T_return, T_obj, T_arg1, T_arg2&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2) const&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor2.html" title="const_mem_functor2 wraps const methods with 2 argument(s). ">sigc::const_mem_functor2</a> which wraps a const method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa3778234963fa65d4f638856d91109d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1const__mem__functor3.html">const_mem_functor3</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3) const&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor3.html" title="const_mem_functor3 wraps const methods with 3 argument(s). ">sigc::const_mem_functor3</a> which wraps a const method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gadadd40aba6dadd0edbaac609dfae3938"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1const__mem__functor4.html">const_mem_functor4</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4) const&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor4.html" title="const_mem_functor4 wraps const methods with 4 argument(s). ">sigc::const_mem_functor4</a> which wraps a const method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa01df6c622d59cfd2d0d8aa3c04c36d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1const__mem__functor5.html">const_mem_functor5</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor5.html" title="const_mem_functor5 wraps const methods with 5 argument(s). ">sigc::const_mem_functor5</a> which wraps a const method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9030b647c35e06c68342fee34e8fd320"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1const__mem__functor6.html">const_mem_functor6</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor6.html" title="const_mem_functor6 wraps const methods with 6 argument(s). ">sigc::const_mem_functor6</a> which wraps a const method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga54e4bf947e8c93c56931b8e8f7ed0d2e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1const__mem__functor7.html">const_mem_functor7</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor7.html" title="const_mem_functor7 wraps const methods with 7 argument(s). ">sigc::const_mem_functor7</a> which wraps a const method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gadf6b6d22c503b439019f0a2e77352419"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1volatile__mem__functor0.html">volatile_mem_functor0</a>&lt;T_return, T_obj&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)() volatile&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor0.html" title="volatile_mem_functor0 wraps volatile methods with 0 argument(s). ">sigc::volatile_mem_functor0</a> which wraps a volatile method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gab661fef0f04e2e439912eee6989e9657"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1volatile__mem__functor1.html">volatile_mem_functor1</a>&lt;T_return, T_obj, T_arg1&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1) volatile&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor1.html" title="volatile_mem_functor1 wraps volatile methods with 1 argument(s). ">sigc::volatile_mem_functor1</a> which wraps a volatile method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4bcfe2d4b91ff49bc8bf27af5a5f3bc5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1volatile__mem__functor2.html">volatile_mem_functor2</a>&lt;T_return, T_obj, T_arg1, T_arg2&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2) volatile&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor2.html" title="volatile_mem_functor2 wraps volatile methods with 2 argument(s). ">sigc::volatile_mem_functor2</a> which wraps a volatile method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa3778234963fa65d4f638856d91109d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1volatile__mem__functor3.html">volatile_mem_functor3</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3) volatile&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor3.html" title="volatile_mem_functor3 wraps volatile methods with 3 argument(s). ">sigc::volatile_mem_functor3</a> which wraps a volatile method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gadadd40aba6dadd0edbaac609dfae3938"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1volatile__mem__functor4.html">volatile_mem_functor4</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4) volatile&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor4.html" title="volatile_mem_functor4 wraps volatile methods with 4 argument(s). ">sigc::volatile_mem_functor4</a> which wraps a volatile method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa01df6c622d59cfd2d0d8aa3c04c36d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1volatile__mem__functor5.html">volatile_mem_functor5</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) volatile&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor5.html" title="volatile_mem_functor5 wraps volatile methods with 5 argument(s). ">sigc::volatile_mem_functor5</a> which wraps a volatile method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9030b647c35e06c68342fee34e8fd320"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1volatile__mem__functor6.html">volatile_mem_functor6</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) volatile&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor6.html" title="volatile_mem_functor6 wraps volatile methods with 6 argument(s). ">sigc::volatile_mem_functor6</a> which wraps a volatile method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga54e4bf947e8c93c56931b8e8f7ed0d2e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1volatile__mem__functor7.html">volatile_mem_functor7</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) volatile&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor7.html" title="volatile_mem_functor7 wraps volatile methods with 7 argument(s). ">sigc::volatile_mem_functor7</a> which wraps a volatile method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gadf6b6d22c503b439019f0a2e77352419"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1const__volatile__mem__functor0.html">const_volatile_mem_functor0</a>&lt;T_return, T_obj&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)() const volatile&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor0.html" title="const_volatile_mem_functor0 wraps const volatile methods with 0 argument(s). ">sigc::const_volatile_mem_functor0</a> which wraps a const volatile method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gab661fef0f04e2e439912eee6989e9657"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1const__volatile__mem__functor1.html">const_volatile_mem_functor1</a>&lt;T_return, T_obj, T_arg1&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1) const volatile&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor1.html" title="const_volatile_mem_functor1 wraps const volatile methods with 1 argument(s). ">sigc::const_volatile_mem_functor1</a> which wraps a const volatile method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4bcfe2d4b91ff49bc8bf27af5a5f3bc5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1const__volatile__mem__functor2.html">const_volatile_mem_functor2</a>&lt;T_return, T_obj, T_arg1, T_arg2&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2) const volatile&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor2.html" title="const_volatile_mem_functor2 wraps const volatile methods with 2 argument(s). ">sigc::const_volatile_mem_functor2</a> which wraps a const volatile method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa3778234963fa65d4f638856d91109d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1const__volatile__mem__functor3.html">const_volatile_mem_functor3</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3) const volatile&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor3.html" title="const_volatile_mem_functor3 wraps const volatile methods with 3 argument(s). ">sigc::const_volatile_mem_functor3</a> which wraps a const volatile method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gadadd40aba6dadd0edbaac609dfae3938"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1const__volatile__mem__functor4.html">const_volatile_mem_functor4</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4) const volatile&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor4.html" title="const_volatile_mem_functor4 wraps const volatile methods with 4 argument(s). ">sigc::const_volatile_mem_functor4</a> which wraps a const volatile method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa01df6c622d59cfd2d0d8aa3c04c36d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1const__volatile__mem__functor5.html">const_volatile_mem_functor5</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const volatile&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor5.html" title="const_volatile_mem_functor5 wraps const volatile methods with 5 argument(s). ">sigc::const_volatile_mem_functor5</a> which wraps a const volatile method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9030b647c35e06c68342fee34e8fd320"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1const__volatile__mem__functor6.html">const_volatile_mem_functor6</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const volatile&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor6.html" title="const_volatile_mem_functor6 wraps const volatile methods with 6 argument(s). ">sigc::const_volatile_mem_functor6</a> which wraps a const volatile method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga54e4bf947e8c93c56931b8e8f7ed0d2e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1const__volatile__mem__functor7.html">const_volatile_mem_functor7</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const volatile&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor7.html" title="const_volatile_mem_functor7 wraps const volatile methods with 7 argument(s). ">sigc::const_volatile_mem_functor7</a> which wraps a const volatile method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7f57ec0156d33b4aa98e259d2e2062db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__mem__functor0.html">bound_const_mem_functor0</a>&lt;T_return, T_obj&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)() const&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor0.html" title="bound_const_mem_functor0 encapsulates a const method with 0 arguments and an object instance...">sigc::bound_const_mem_functor0</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaeef6e55681664df29b31edec51ea034d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__mem__functor0.html">bound_const_mem_functor0</a>&lt;T_return, T_obj&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)() const&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor0.html" title="bound_const_mem_functor0 encapsulates a const method with 0 arguments and an object instance...">sigc::bound_const_mem_functor0</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0df7af9f32990cc624c4bb60782b4f78"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__mem__functor1.html">bound_const_mem_functor1</a>&lt;T_return, T_obj, T_arg1&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1) const&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor1.html" title="bound_const_mem_functor1 encapsulates a const method with 1 arguments and an object instance...">sigc::bound_const_mem_functor1</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7de39a04dfc6d37b2d12a25cdccfbe95"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__mem__functor1.html">bound_const_mem_functor1</a>&lt;T_return, T_obj, T_arg1&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1) const&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor1.html" title="bound_const_mem_functor1 encapsulates a const method with 1 arguments and an object instance...">sigc::bound_const_mem_functor1</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga118b2610268701be95cdc6fddb7bab3b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__mem__functor2.html">bound_const_mem_functor2</a>&lt;T_return, T_obj, T_arg1, T_arg2&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2) const&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor2.html" title="bound_const_mem_functor2 encapsulates a const method with 2 arguments and an object instance...">sigc::bound_const_mem_functor2</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gab1add5c927b51b935b4f2d40558079fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__mem__functor2.html">bound_const_mem_functor2</a>&lt;T_return, T_obj, T_arg1, T_arg2&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2) const&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor2.html" title="bound_const_mem_functor2 encapsulates a const method with 2 arguments and an object instance...">sigc::bound_const_mem_functor2</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaeb6bd4518e0f0c524dba13a6cbb2e319"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__mem__functor3.html">bound_const_mem_functor3</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3) const&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor3.html" title="bound_const_mem_functor3 encapsulates a const method with 3 arguments and an object instance...">sigc::bound_const_mem_functor3</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1f1aa3b60c0d2d8b2470bba0b2b36023"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__mem__functor3.html">bound_const_mem_functor3</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3) const&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor3.html" title="bound_const_mem_functor3 encapsulates a const method with 3 arguments and an object instance...">sigc::bound_const_mem_functor3</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga02c906c95895c58e39ee301bb1577994"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__mem__functor4.html">bound_const_mem_functor4</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4) const&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor4.html" title="bound_const_mem_functor4 encapsulates a const method with 4 arguments and an object instance...">sigc::bound_const_mem_functor4</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga481ef34d8423d26e8ff0a1916cd295d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__mem__functor4.html">bound_const_mem_functor4</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4) const&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor4.html" title="bound_const_mem_functor4 encapsulates a const method with 4 arguments and an object instance...">sigc::bound_const_mem_functor4</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gab138ae1a340be983166b69872826b37d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__mem__functor5.html">bound_const_mem_functor5</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor5.html" title="bound_const_mem_functor5 encapsulates a const method with 5 arguments and an object instance...">sigc::bound_const_mem_functor5</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga09fb13b1684ec7c092ffef695dbb261a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__mem__functor5.html">bound_const_mem_functor5</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor5.html" title="bound_const_mem_functor5 encapsulates a const method with 5 arguments and an object instance...">sigc::bound_const_mem_functor5</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3e3841c4844715d2f2d832ed506f028f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__mem__functor6.html">bound_const_mem_functor6</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor6.html" title="bound_const_mem_functor6 encapsulates a const method with 6 arguments and an object instance...">sigc::bound_const_mem_functor6</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0d9b992d69123a524b6c70c458ad0d40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__mem__functor6.html">bound_const_mem_functor6</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor6.html" title="bound_const_mem_functor6 encapsulates a const method with 6 arguments and an object instance...">sigc::bound_const_mem_functor6</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaea5a2ace2699b8d1ffe93585e335548d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__mem__functor7.html">bound_const_mem_functor7</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor7.html" title="bound_const_mem_functor7 encapsulates a const method with 7 arguments and an object instance...">sigc::bound_const_mem_functor7</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5dcdaf235baa50049e6088d246853037"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__mem__functor7.html">bound_const_mem_functor7</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor7.html" title="bound_const_mem_functor7 encapsulates a const method with 7 arguments and an object instance...">sigc::bound_const_mem_functor7</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7f57ec0156d33b4aa98e259d2e2062db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html">bound_volatile_mem_functor0</a>&lt;T_return, T_obj&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)() volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html" title="bound_volatile_mem_functor0 encapsulates a volatile method with 0 arguments and an object instance...">sigc::bound_volatile_mem_functor0</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaeef6e55681664df29b31edec51ea034d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html">bound_volatile_mem_functor0</a>&lt;T_return, T_obj&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)() volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html" title="bound_volatile_mem_functor0 encapsulates a volatile method with 0 arguments and an object instance...">sigc::bound_volatile_mem_functor0</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0df7af9f32990cc624c4bb60782b4f78"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html">bound_volatile_mem_functor1</a>&lt;T_return, T_obj, T_arg1&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1) volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html" title="bound_volatile_mem_functor1 encapsulates a volatile method with 1 arguments and an object instance...">sigc::bound_volatile_mem_functor1</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7de39a04dfc6d37b2d12a25cdccfbe95"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html">bound_volatile_mem_functor1</a>&lt;T_return, T_obj, T_arg1&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1) volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html" title="bound_volatile_mem_functor1 encapsulates a volatile method with 1 arguments and an object instance...">sigc::bound_volatile_mem_functor1</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga118b2610268701be95cdc6fddb7bab3b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html">bound_volatile_mem_functor2</a>&lt;T_return, T_obj, T_arg1, T_arg2&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2) volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html" title="bound_volatile_mem_functor2 encapsulates a volatile method with 2 arguments and an object instance...">sigc::bound_volatile_mem_functor2</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gab1add5c927b51b935b4f2d40558079fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html">bound_volatile_mem_functor2</a>&lt;T_return, T_obj, T_arg1, T_arg2&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2) volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html" title="bound_volatile_mem_functor2 encapsulates a volatile method with 2 arguments and an object instance...">sigc::bound_volatile_mem_functor2</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaeb6bd4518e0f0c524dba13a6cbb2e319"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html">bound_volatile_mem_functor3</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3) volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html" title="bound_volatile_mem_functor3 encapsulates a volatile method with 3 arguments and an object instance...">sigc::bound_volatile_mem_functor3</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1f1aa3b60c0d2d8b2470bba0b2b36023"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html">bound_volatile_mem_functor3</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3) volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html" title="bound_volatile_mem_functor3 encapsulates a volatile method with 3 arguments and an object instance...">sigc::bound_volatile_mem_functor3</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga02c906c95895c58e39ee301bb1577994"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html">bound_volatile_mem_functor4</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4) volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html" title="bound_volatile_mem_functor4 encapsulates a volatile method with 4 arguments and an object instance...">sigc::bound_volatile_mem_functor4</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga481ef34d8423d26e8ff0a1916cd295d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html">bound_volatile_mem_functor4</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4) volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html" title="bound_volatile_mem_functor4 encapsulates a volatile method with 4 arguments and an object instance...">sigc::bound_volatile_mem_functor4</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gab138ae1a340be983166b69872826b37d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html">bound_volatile_mem_functor5</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html" title="bound_volatile_mem_functor5 encapsulates a volatile method with 5 arguments and an object instance...">sigc::bound_volatile_mem_functor5</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga09fb13b1684ec7c092ffef695dbb261a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html">bound_volatile_mem_functor5</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html" title="bound_volatile_mem_functor5 encapsulates a volatile method with 5 arguments and an object instance...">sigc::bound_volatile_mem_functor5</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3e3841c4844715d2f2d832ed506f028f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html">bound_volatile_mem_functor6</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html" title="bound_volatile_mem_functor6 encapsulates a volatile method with 6 arguments and an object instance...">sigc::bound_volatile_mem_functor6</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0d9b992d69123a524b6c70c458ad0d40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html">bound_volatile_mem_functor6</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html" title="bound_volatile_mem_functor6 encapsulates a volatile method with 6 arguments and an object instance...">sigc::bound_volatile_mem_functor6</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaea5a2ace2699b8d1ffe93585e335548d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html">bound_volatile_mem_functor7</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html" title="bound_volatile_mem_functor7 encapsulates a volatile method with 7 arguments and an object instance...">sigc::bound_volatile_mem_functor7</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5dcdaf235baa50049e6088d246853037"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html">bound_volatile_mem_functor7</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html" title="bound_volatile_mem_functor7 encapsulates a volatile method with 7 arguments and an object instance...">sigc::bound_volatile_mem_functor7</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7f57ec0156d33b4aa98e259d2e2062db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">bound_const_volatile_mem_functor0</a>&lt;T_return, T_obj&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)() const volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html" title="bound_const_volatile_mem_functor0 encapsulates a const volatile method with 0 arguments and an object...">sigc::bound_const_volatile_mem_functor0</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaeef6e55681664df29b31edec51ea034d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">bound_const_volatile_mem_functor0</a>&lt;T_return, T_obj&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)() const volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html" title="bound_const_volatile_mem_functor0 encapsulates a const volatile method with 0 arguments and an object...">sigc::bound_const_volatile_mem_functor0</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0df7af9f32990cc624c4bb60782b4f78"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">bound_const_volatile_mem_functor1</a>&lt;T_return, T_obj, T_arg1&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1) const volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html" title="bound_const_volatile_mem_functor1 encapsulates a const volatile method with 1 arguments and an object...">sigc::bound_const_volatile_mem_functor1</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7de39a04dfc6d37b2d12a25cdccfbe95"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">bound_const_volatile_mem_functor1</a>&lt;T_return, T_obj, T_arg1&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1) const volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html" title="bound_const_volatile_mem_functor1 encapsulates a const volatile method with 1 arguments and an object...">sigc::bound_const_volatile_mem_functor1</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga118b2610268701be95cdc6fddb7bab3b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">bound_const_volatile_mem_functor2</a>&lt;T_return, T_obj, T_arg1, T_arg2&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2) const volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html" title="bound_const_volatile_mem_functor2 encapsulates a const volatile method with 2 arguments and an object...">sigc::bound_const_volatile_mem_functor2</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gab1add5c927b51b935b4f2d40558079fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">bound_const_volatile_mem_functor2</a>&lt;T_return, T_obj, T_arg1, T_arg2&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2) const volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html" title="bound_const_volatile_mem_functor2 encapsulates a const volatile method with 2 arguments and an object...">sigc::bound_const_volatile_mem_functor2</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaeb6bd4518e0f0c524dba13a6cbb2e319"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">bound_const_volatile_mem_functor3</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3) const volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html" title="bound_const_volatile_mem_functor3 encapsulates a const volatile method with 3 arguments and an object...">sigc::bound_const_volatile_mem_functor3</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1f1aa3b60c0d2d8b2470bba0b2b36023"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">bound_const_volatile_mem_functor3</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3) const volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html" title="bound_const_volatile_mem_functor3 encapsulates a const volatile method with 3 arguments and an object...">sigc::bound_const_volatile_mem_functor3</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga02c906c95895c58e39ee301bb1577994"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">bound_const_volatile_mem_functor4</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4) const volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html" title="bound_const_volatile_mem_functor4 encapsulates a const volatile method with 4 arguments and an object...">sigc::bound_const_volatile_mem_functor4</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga481ef34d8423d26e8ff0a1916cd295d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">bound_const_volatile_mem_functor4</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4) const volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html" title="bound_const_volatile_mem_functor4 encapsulates a const volatile method with 4 arguments and an object...">sigc::bound_const_volatile_mem_functor4</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gab138ae1a340be983166b69872826b37d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">bound_const_volatile_mem_functor5</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html" title="bound_const_volatile_mem_functor5 encapsulates a const volatile method with 5 arguments and an object...">sigc::bound_const_volatile_mem_functor5</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga09fb13b1684ec7c092ffef695dbb261a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">bound_const_volatile_mem_functor5</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html" title="bound_const_volatile_mem_functor5 encapsulates a const volatile method with 5 arguments and an object...">sigc::bound_const_volatile_mem_functor5</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3e3841c4844715d2f2d832ed506f028f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">bound_const_volatile_mem_functor6</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html" title="bound_const_volatile_mem_functor6 encapsulates a const volatile method with 6 arguments and an object...">sigc::bound_const_volatile_mem_functor6</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0d9b992d69123a524b6c70c458ad0d40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">bound_const_volatile_mem_functor6</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html" title="bound_const_volatile_mem_functor6 encapsulates a const volatile method with 6 arguments and an object...">sigc::bound_const_volatile_mem_functor6</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaea5a2ace2699b8d1ffe93585e335548d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">bound_const_volatile_mem_functor7</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html" title="bound_const_volatile_mem_functor7 encapsulates a const volatile method with 7 arguments and an object...">sigc::bound_const_volatile_mem_functor7</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5dcdaf235baa50049e6088d246853037"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">bound_const_volatile_mem_functor7</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt; sigc::mem_fun </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html" title="bound_const_volatile_mem_functor7 encapsulates a const volatile method with 7 arguments and an object...">sigc::bound_const_volatile_mem_functor7</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga765b35689a909fbc2a627be8256c5b1f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1const__mem__functor0.html">const_mem_functor0</a>&lt;T_return, T_obj&gt; sigc::mem_fun0 </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)() const&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor0.html" title="const_mem_functor0 wraps const methods with 0 argument(s). ">sigc::const_mem_functor0</a> which wraps a const method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga765b35689a909fbc2a627be8256c5b1f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1volatile__mem__functor0.html">volatile_mem_functor0</a>&lt;T_return, T_obj&gt; sigc::mem_fun0 </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)() volatile&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor0.html" title="volatile_mem_functor0 wraps volatile methods with 0 argument(s). ">sigc::volatile_mem_functor0</a> which wraps a volatile method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga765b35689a909fbc2a627be8256c5b1f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1const__volatile__mem__functor0.html">const_volatile_mem_functor0</a>&lt;T_return, T_obj&gt; sigc::mem_fun0 </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)() const volatile&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor0.html" title="const_volatile_mem_functor0 wraps const volatile methods with 0 argument(s). ">sigc::const_volatile_mem_functor0</a> which wraps a const volatile method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gae03d0b73b85e85d2ad8bc43b19b855e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__mem__functor0.html">bound_const_mem_functor0</a>&lt;T_return, T_obj&gt; sigc::mem_fun0 </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)() const&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor0.html" title="bound_const_mem_functor0 encapsulates a const method with 0 arguments and an object instance...">sigc::bound_const_mem_functor0</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf71277763f14050e2d270fcf3ea41dc9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__mem__functor0.html">bound_const_mem_functor0</a>&lt;T_return, T_obj&gt; sigc::mem_fun0 </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)() const&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor0.html" title="bound_const_mem_functor0 encapsulates a const method with 0 arguments and an object instance...">sigc::bound_const_mem_functor0</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gae03d0b73b85e85d2ad8bc43b19b855e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html">bound_volatile_mem_functor0</a>&lt;T_return, T_obj&gt; sigc::mem_fun0 </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)() volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html" title="bound_volatile_mem_functor0 encapsulates a volatile method with 0 arguments and an object instance...">sigc::bound_volatile_mem_functor0</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf71277763f14050e2d270fcf3ea41dc9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html">bound_volatile_mem_functor0</a>&lt;T_return, T_obj&gt; sigc::mem_fun0 </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)() volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor0.html" title="bound_volatile_mem_functor0 encapsulates a volatile method with 0 arguments and an object instance...">sigc::bound_volatile_mem_functor0</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gae03d0b73b85e85d2ad8bc43b19b855e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">bound_const_volatile_mem_functor0</a>&lt;T_return, T_obj&gt; sigc::mem_fun0 </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)() const volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html" title="bound_const_volatile_mem_functor0 encapsulates a const volatile method with 0 arguments and an object...">sigc::bound_const_volatile_mem_functor0</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf71277763f14050e2d270fcf3ea41dc9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html">bound_const_volatile_mem_functor0</a>&lt;T_return, T_obj&gt; sigc::mem_fun0 </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)() const volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor0.html" title="bound_const_volatile_mem_functor0 encapsulates a const volatile method with 0 arguments and an object...">sigc::bound_const_volatile_mem_functor0</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gae0bebf0d8a2d36d93746c23d9eea668d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1const__mem__functor1.html">const_mem_functor1</a>&lt;T_return, T_obj, T_arg1&gt; sigc::mem_fun1 </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1) const&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor1.html" title="const_mem_functor1 wraps const methods with 1 argument(s). ">sigc::const_mem_functor1</a> which wraps a const method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gae0bebf0d8a2d36d93746c23d9eea668d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1volatile__mem__functor1.html">volatile_mem_functor1</a>&lt;T_return, T_obj, T_arg1&gt; sigc::mem_fun1 </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1) volatile&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor1.html" title="volatile_mem_functor1 wraps volatile methods with 1 argument(s). ">sigc::volatile_mem_functor1</a> which wraps a volatile method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gae0bebf0d8a2d36d93746c23d9eea668d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1const__volatile__mem__functor1.html">const_volatile_mem_functor1</a>&lt;T_return, T_obj, T_arg1&gt; sigc::mem_fun1 </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1) const volatile&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor1.html" title="const_volatile_mem_functor1 wraps const volatile methods with 1 argument(s). ">sigc::const_volatile_mem_functor1</a> which wraps a const volatile method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3dd8d2ed97310dbf4fa394999f0be7b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__mem__functor1.html">bound_const_mem_functor1</a>&lt;T_return, T_obj, T_arg1&gt; sigc::mem_fun1 </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1) const&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor1.html" title="bound_const_mem_functor1 encapsulates a const method with 1 arguments and an object instance...">sigc::bound_const_mem_functor1</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaade596a4dacfd1429039525bb9f399d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__mem__functor1.html">bound_const_mem_functor1</a>&lt;T_return, T_obj, T_arg1&gt; sigc::mem_fun1 </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1) const&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor1.html" title="bound_const_mem_functor1 encapsulates a const method with 1 arguments and an object instance...">sigc::bound_const_mem_functor1</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3dd8d2ed97310dbf4fa394999f0be7b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html">bound_volatile_mem_functor1</a>&lt;T_return, T_obj, T_arg1&gt; sigc::mem_fun1 </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1) volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html" title="bound_volatile_mem_functor1 encapsulates a volatile method with 1 arguments and an object instance...">sigc::bound_volatile_mem_functor1</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaade596a4dacfd1429039525bb9f399d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html">bound_volatile_mem_functor1</a>&lt;T_return, T_obj, T_arg1&gt; sigc::mem_fun1 </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1) volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor1.html" title="bound_volatile_mem_functor1 encapsulates a volatile method with 1 arguments and an object instance...">sigc::bound_volatile_mem_functor1</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3dd8d2ed97310dbf4fa394999f0be7b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">bound_const_volatile_mem_functor1</a>&lt;T_return, T_obj, T_arg1&gt; sigc::mem_fun1 </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1) const volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html" title="bound_const_volatile_mem_functor1 encapsulates a const volatile method with 1 arguments and an object...">sigc::bound_const_volatile_mem_functor1</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaade596a4dacfd1429039525bb9f399d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html">bound_const_volatile_mem_functor1</a>&lt;T_return, T_obj, T_arg1&gt; sigc::mem_fun1 </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1) const volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor1.html" title="bound_const_volatile_mem_functor1 encapsulates a const volatile method with 1 arguments and an object...">sigc::bound_const_volatile_mem_functor1</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gab76f41aeada332b353b6fe2e96008831"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1const__mem__functor2.html">const_mem_functor2</a>&lt;T_return, T_obj, T_arg1, T_arg2&gt; sigc::mem_fun2 </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2) const&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor2.html" title="const_mem_functor2 wraps const methods with 2 argument(s). ">sigc::const_mem_functor2</a> which wraps a const method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gab76f41aeada332b353b6fe2e96008831"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1volatile__mem__functor2.html">volatile_mem_functor2</a>&lt;T_return, T_obj, T_arg1, T_arg2&gt; sigc::mem_fun2 </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2) volatile&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor2.html" title="volatile_mem_functor2 wraps volatile methods with 2 argument(s). ">sigc::volatile_mem_functor2</a> which wraps a volatile method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gab76f41aeada332b353b6fe2e96008831"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1const__volatile__mem__functor2.html">const_volatile_mem_functor2</a>&lt;T_return, T_obj, T_arg1, T_arg2&gt; sigc::mem_fun2 </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2) const volatile&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor2.html" title="const_volatile_mem_functor2 wraps const volatile methods with 2 argument(s). ">sigc::const_volatile_mem_functor2</a> which wraps a const volatile method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga184da4166c8b5409dc4b98d7bc16dff8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__mem__functor2.html">bound_const_mem_functor2</a>&lt;T_return, T_obj, T_arg1, T_arg2&gt; sigc::mem_fun2 </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2) const&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor2.html" title="bound_const_mem_functor2 encapsulates a const method with 2 arguments and an object instance...">sigc::bound_const_mem_functor2</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaee7652f1a0625df50af50e28b5e2423e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__mem__functor2.html">bound_const_mem_functor2</a>&lt;T_return, T_obj, T_arg1, T_arg2&gt; sigc::mem_fun2 </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2) const&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor2.html" title="bound_const_mem_functor2 encapsulates a const method with 2 arguments and an object instance...">sigc::bound_const_mem_functor2</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga184da4166c8b5409dc4b98d7bc16dff8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html">bound_volatile_mem_functor2</a>&lt;T_return, T_obj, T_arg1, T_arg2&gt; sigc::mem_fun2 </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2) volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html" title="bound_volatile_mem_functor2 encapsulates a volatile method with 2 arguments and an object instance...">sigc::bound_volatile_mem_functor2</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaee7652f1a0625df50af50e28b5e2423e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html">bound_volatile_mem_functor2</a>&lt;T_return, T_obj, T_arg1, T_arg2&gt; sigc::mem_fun2 </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2) volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor2.html" title="bound_volatile_mem_functor2 encapsulates a volatile method with 2 arguments and an object instance...">sigc::bound_volatile_mem_functor2</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga184da4166c8b5409dc4b98d7bc16dff8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">bound_const_volatile_mem_functor2</a>&lt;T_return, T_obj, T_arg1, T_arg2&gt; sigc::mem_fun2 </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2) const volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html" title="bound_const_volatile_mem_functor2 encapsulates a const volatile method with 2 arguments and an object...">sigc::bound_const_volatile_mem_functor2</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaee7652f1a0625df50af50e28b5e2423e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html">bound_const_volatile_mem_functor2</a>&lt;T_return, T_obj, T_arg1, T_arg2&gt; sigc::mem_fun2 </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2) const volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor2.html" title="bound_const_volatile_mem_functor2 encapsulates a const volatile method with 2 arguments and an object...">sigc::bound_const_volatile_mem_functor2</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2379e0d689fe4a99c7c669fc29817457"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1const__mem__functor3.html">const_mem_functor3</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt; sigc::mem_fun3 </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3) const&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor3.html" title="const_mem_functor3 wraps const methods with 3 argument(s). ">sigc::const_mem_functor3</a> which wraps a const method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2379e0d689fe4a99c7c669fc29817457"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1volatile__mem__functor3.html">volatile_mem_functor3</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt; sigc::mem_fun3 </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3) volatile&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor3.html" title="volatile_mem_functor3 wraps volatile methods with 3 argument(s). ">sigc::volatile_mem_functor3</a> which wraps a volatile method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2379e0d689fe4a99c7c669fc29817457"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1const__volatile__mem__functor3.html">const_volatile_mem_functor3</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt; sigc::mem_fun3 </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3) const volatile&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor3.html" title="const_volatile_mem_functor3 wraps const volatile methods with 3 argument(s). ">sigc::const_volatile_mem_functor3</a> which wraps a const volatile method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4f2fdbf02e8cac9492326a4a8ffdd012"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__mem__functor3.html">bound_const_mem_functor3</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt; sigc::mem_fun3 </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3) const&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor3.html" title="bound_const_mem_functor3 encapsulates a const method with 3 arguments and an object instance...">sigc::bound_const_mem_functor3</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga14e07df139b5cb6897e671c50fc33cde"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__mem__functor3.html">bound_const_mem_functor3</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt; sigc::mem_fun3 </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3) const&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor3.html" title="bound_const_mem_functor3 encapsulates a const method with 3 arguments and an object instance...">sigc::bound_const_mem_functor3</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4f2fdbf02e8cac9492326a4a8ffdd012"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html">bound_volatile_mem_functor3</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt; sigc::mem_fun3 </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3) volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html" title="bound_volatile_mem_functor3 encapsulates a volatile method with 3 arguments and an object instance...">sigc::bound_volatile_mem_functor3</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga14e07df139b5cb6897e671c50fc33cde"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html">bound_volatile_mem_functor3</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt; sigc::mem_fun3 </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3) volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor3.html" title="bound_volatile_mem_functor3 encapsulates a volatile method with 3 arguments and an object instance...">sigc::bound_volatile_mem_functor3</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4f2fdbf02e8cac9492326a4a8ffdd012"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">bound_const_volatile_mem_functor3</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt; sigc::mem_fun3 </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3) const volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html" title="bound_const_volatile_mem_functor3 encapsulates a const volatile method with 3 arguments and an object...">sigc::bound_const_volatile_mem_functor3</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga14e07df139b5cb6897e671c50fc33cde"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html">bound_const_volatile_mem_functor3</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3&gt; sigc::mem_fun3 </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3) const volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor3.html" title="bound_const_volatile_mem_functor3 encapsulates a const volatile method with 3 arguments and an object...">sigc::bound_const_volatile_mem_functor3</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1bedd04f76ad3e21f614912562e95d83"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1const__mem__functor4.html">const_mem_functor4</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt; sigc::mem_fun4 </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4) const&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor4.html" title="const_mem_functor4 wraps const methods with 4 argument(s). ">sigc::const_mem_functor4</a> which wraps a const method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1bedd04f76ad3e21f614912562e95d83"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1volatile__mem__functor4.html">volatile_mem_functor4</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt; sigc::mem_fun4 </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4) volatile&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor4.html" title="volatile_mem_functor4 wraps volatile methods with 4 argument(s). ">sigc::volatile_mem_functor4</a> which wraps a volatile method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1bedd04f76ad3e21f614912562e95d83"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1const__volatile__mem__functor4.html">const_volatile_mem_functor4</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt; sigc::mem_fun4 </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4) const volatile&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor4.html" title="const_volatile_mem_functor4 wraps const volatile methods with 4 argument(s). ">sigc::const_volatile_mem_functor4</a> which wraps a const volatile method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga94a2525ef116e16598b81b853544a170"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__mem__functor4.html">bound_const_mem_functor4</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt; sigc::mem_fun4 </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4) const&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor4.html" title="bound_const_mem_functor4 encapsulates a const method with 4 arguments and an object instance...">sigc::bound_const_mem_functor4</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga86da5637e2735480d525ffa930e7e21a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__mem__functor4.html">bound_const_mem_functor4</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt; sigc::mem_fun4 </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4) const&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor4.html" title="bound_const_mem_functor4 encapsulates a const method with 4 arguments and an object instance...">sigc::bound_const_mem_functor4</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga94a2525ef116e16598b81b853544a170"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html">bound_volatile_mem_functor4</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt; sigc::mem_fun4 </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4) volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html" title="bound_volatile_mem_functor4 encapsulates a volatile method with 4 arguments and an object instance...">sigc::bound_volatile_mem_functor4</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga86da5637e2735480d525ffa930e7e21a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html">bound_volatile_mem_functor4</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt; sigc::mem_fun4 </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4) volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor4.html" title="bound_volatile_mem_functor4 encapsulates a volatile method with 4 arguments and an object instance...">sigc::bound_volatile_mem_functor4</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga94a2525ef116e16598b81b853544a170"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">bound_const_volatile_mem_functor4</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt; sigc::mem_fun4 </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4) const volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html" title="bound_const_volatile_mem_functor4 encapsulates a const volatile method with 4 arguments and an object...">sigc::bound_const_volatile_mem_functor4</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga86da5637e2735480d525ffa930e7e21a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html">bound_const_volatile_mem_functor4</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4&gt; sigc::mem_fun4 </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4) const volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor4.html" title="bound_const_volatile_mem_functor4 encapsulates a const volatile method with 4 arguments and an object...">sigc::bound_const_volatile_mem_functor4</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3ef4bb904a751d29e2b6803ef81f72fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1const__mem__functor5.html">const_mem_functor5</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt; sigc::mem_fun5 </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor5.html" title="const_mem_functor5 wraps const methods with 5 argument(s). ">sigc::const_mem_functor5</a> which wraps a const method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3ef4bb904a751d29e2b6803ef81f72fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1volatile__mem__functor5.html">volatile_mem_functor5</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt; sigc::mem_fun5 </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) volatile&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor5.html" title="volatile_mem_functor5 wraps volatile methods with 5 argument(s). ">sigc::volatile_mem_functor5</a> which wraps a volatile method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3ef4bb904a751d29e2b6803ef81f72fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1const__volatile__mem__functor5.html">const_volatile_mem_functor5</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt; sigc::mem_fun5 </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const volatile&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor5.html" title="const_volatile_mem_functor5 wraps const volatile methods with 5 argument(s). ">sigc::const_volatile_mem_functor5</a> which wraps a const volatile method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf060fe3a2be4ff7c0f50aef54b4dc8bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__mem__functor5.html">bound_const_mem_functor5</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt; sigc::mem_fun5 </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor5.html" title="bound_const_mem_functor5 encapsulates a const method with 5 arguments and an object instance...">sigc::bound_const_mem_functor5</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5c2ca9cef8c857935a59133a73ef61f2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__mem__functor5.html">bound_const_mem_functor5</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt; sigc::mem_fun5 </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor5.html" title="bound_const_mem_functor5 encapsulates a const method with 5 arguments and an object instance...">sigc::bound_const_mem_functor5</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf060fe3a2be4ff7c0f50aef54b4dc8bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html">bound_volatile_mem_functor5</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt; sigc::mem_fun5 </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html" title="bound_volatile_mem_functor5 encapsulates a volatile method with 5 arguments and an object instance...">sigc::bound_volatile_mem_functor5</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5c2ca9cef8c857935a59133a73ef61f2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html">bound_volatile_mem_functor5</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt; sigc::mem_fun5 </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor5.html" title="bound_volatile_mem_functor5 encapsulates a volatile method with 5 arguments and an object instance...">sigc::bound_volatile_mem_functor5</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf060fe3a2be4ff7c0f50aef54b4dc8bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">bound_const_volatile_mem_functor5</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt; sigc::mem_fun5 </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html" title="bound_const_volatile_mem_functor5 encapsulates a const volatile method with 5 arguments and an object...">sigc::bound_const_volatile_mem_functor5</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5c2ca9cef8c857935a59133a73ef61f2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html">bound_const_volatile_mem_functor5</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5&gt; sigc::mem_fun5 </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5) const volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor5.html" title="bound_const_volatile_mem_functor5 encapsulates a const volatile method with 5 arguments and an object...">sigc::bound_const_volatile_mem_functor5</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga34ace98fbbd18cb635795639d0f22678"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1const__mem__functor6.html">const_mem_functor6</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt; sigc::mem_fun6 </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor6.html" title="const_mem_functor6 wraps const methods with 6 argument(s). ">sigc::const_mem_functor6</a> which wraps a const method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga34ace98fbbd18cb635795639d0f22678"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1volatile__mem__functor6.html">volatile_mem_functor6</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt; sigc::mem_fun6 </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) volatile&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor6.html" title="volatile_mem_functor6 wraps volatile methods with 6 argument(s). ">sigc::volatile_mem_functor6</a> which wraps a volatile method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga34ace98fbbd18cb635795639d0f22678"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1const__volatile__mem__functor6.html">const_volatile_mem_functor6</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt; sigc::mem_fun6 </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const volatile&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor6.html" title="const_volatile_mem_functor6 wraps const volatile methods with 6 argument(s). ">sigc::const_volatile_mem_functor6</a> which wraps a const volatile method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gac0a6242da9bf96642f25c1363dfef383"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__mem__functor6.html">bound_const_mem_functor6</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt; sigc::mem_fun6 </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor6.html" title="bound_const_mem_functor6 encapsulates a const method with 6 arguments and an object instance...">sigc::bound_const_mem_functor6</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga947f4410e62a2996023177e490c882b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__mem__functor6.html">bound_const_mem_functor6</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt; sigc::mem_fun6 </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor6.html" title="bound_const_mem_functor6 encapsulates a const method with 6 arguments and an object instance...">sigc::bound_const_mem_functor6</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gac0a6242da9bf96642f25c1363dfef383"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html">bound_volatile_mem_functor6</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt; sigc::mem_fun6 </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html" title="bound_volatile_mem_functor6 encapsulates a volatile method with 6 arguments and an object instance...">sigc::bound_volatile_mem_functor6</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga947f4410e62a2996023177e490c882b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html">bound_volatile_mem_functor6</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt; sigc::mem_fun6 </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor6.html" title="bound_volatile_mem_functor6 encapsulates a volatile method with 6 arguments and an object instance...">sigc::bound_volatile_mem_functor6</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="gac0a6242da9bf96642f25c1363dfef383"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">bound_const_volatile_mem_functor6</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt; sigc::mem_fun6 </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html" title="bound_const_volatile_mem_functor6 encapsulates a const volatile method with 6 arguments and an object...">sigc::bound_const_volatile_mem_functor6</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga947f4410e62a2996023177e490c882b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html">bound_const_volatile_mem_functor6</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6&gt; sigc::mem_fun6 </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6) const volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor6.html" title="bound_const_volatile_mem_functor6 encapsulates a const volatile method with 6 arguments and an object...">sigc::bound_const_volatile_mem_functor6</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3d174b01bf94dbda3aea58c25c2b3322"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1const__mem__functor7.html">const_mem_functor7</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt; sigc::mem_fun7 </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1const__mem__functor7.html" title="const_mem_functor7 wraps const methods with 7 argument(s). ">sigc::const_mem_functor7</a> which wraps a const method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3d174b01bf94dbda3aea58c25c2b3322"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1volatile__mem__functor7.html">volatile_mem_functor7</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt; sigc::mem_fun7 </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) volatile&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1volatile__mem__functor7.html" title="volatile_mem_functor7 wraps volatile methods with 7 argument(s). ">sigc::volatile_mem_functor7</a> which wraps a volatile method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3d174b01bf94dbda3aea58c25c2b3322"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1const__volatile__mem__functor7.html">const_volatile_mem_functor7</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt; sigc::mem_fun7 </td>
          <td>(</td>
          <td class="paramtype">T_return(T_obj::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const volatile&#160;</td>
          <td class="paramname"><em>_A_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1const__volatile__mem__functor7.html" title="const_volatile_mem_functor7 wraps const volatile methods with 7 argument(s). ">sigc::const_volatile_mem_functor7</a> which wraps a const volatile method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes _A_func on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9899534bc8eb78c227d895b396710091"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__mem__functor7.html">bound_const_mem_functor7</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt; sigc::mem_fun7 </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor7.html" title="bound_const_mem_functor7 encapsulates a const method with 7 arguments and an object instance...">sigc::bound_const_mem_functor7</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1f704e475da2aad1717e059c264c1436"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__mem__functor7.html">bound_const_mem_functor7</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt; sigc::mem_fun7 </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__mem__functor7.html" title="bound_const_mem_functor7 encapsulates a const method with 7 arguments and an object instance...">sigc::bound_const_mem_functor7</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9899534bc8eb78c227d895b396710091"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html">bound_volatile_mem_functor7</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt; sigc::mem_fun7 </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html" title="bound_volatile_mem_functor7 encapsulates a volatile method with 7 arguments and an object instance...">sigc::bound_volatile_mem_functor7</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1f704e475da2aad1717e059c264c1436"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html">bound_volatile_mem_functor7</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt; sigc::mem_fun7 </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__volatile__mem__functor7.html" title="bound_volatile_mem_functor7 encapsulates a volatile method with 7 arguments and an object instance...">sigc::bound_volatile_mem_functor7</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9899534bc8eb78c227d895b396710091"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">bound_const_volatile_mem_functor7</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt; sigc::mem_fun7 </td>
          <td>(</td>
          <td class="paramtype">T_obj *&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html" title="bound_const_volatile_mem_functor7 encapsulates a const volatile method with 7 arguments and an object...">sigc::bound_const_volatile_mem_functor7</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Pointer to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1f704e475da2aad1717e059c264c1436"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_arg1 , class T_arg2 , class T_arg3 , class T_arg4 , class T_arg5 , class T_arg6 , class T_arg7 , class T_return , class T_obj , class T_obj2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html">bound_const_volatile_mem_functor7</a>&lt;T_return, T_obj, T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7&gt; sigc::mem_fun7 </td>
          <td>(</td>
          <td class="paramtype">T_obj &amp;&#160;</td>
          <td class="paramname"><em>_A_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_return(T_obj2::*)(T_arg1, T_arg2, T_arg3, T_arg4, T_arg5, T_arg6, T_arg7) const volatile&#160;</td>
          <td class="paramname"><em>_A_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a functor of type <a class="el" href="classsigc_1_1bound__const__volatile__mem__functor7.html" title="bound_const_volatile_mem_functor7 encapsulates a const volatile method with 7 arguments and an object...">sigc::bound_const_volatile_mem_functor7</a> which encapsulates a method and an object instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_A_obj</td><td>Reference to object instance the functor should operate on. </td></tr>
    <tr><td class="paramname">_A_func</td><td>Pointer to method that should be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Functor that executes <em>_A_func</em> on invokation. </dd></dl>

</div>
</div>
<a class="anchor" id="a48e982c74c057b5630246ba436524041"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1reference__wrapper.html">reference_wrapper</a>&lt;T_type&gt; sigc::ref </td>
          <td>(</td>
          <td class="paramtype">T_type &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a reference wrapper. </p>
<p>Passing an object throught <a class="el" href="namespacesigc.html#a48e982c74c057b5630246ba436524041" title="Creates a reference wrapper. ">sigc::ref()</a> makes libsigc++ adaptors like, e.g., <a class="el" href="group__bind.html#ga2f099bc6056b32f2a58134ba8537c6f4" title="Creates an adaptor of type sigc::bind_functor which binds the passed argument to the passed functor...">sigc::bind</a> store references to the object instead of copies. If the object type inherits from <a class="el" href="structsigc_1_1trackable.html" title="Base class for objects with auto-disconnection. ">sigc::trackable</a> this will ensure automatic invalidation of the adaptors when the object is deleted or overwritten.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Reference to store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference wrapper. </dd></dl>

</div>
</div>
<a class="anchor" id="a670882bd3fa5890b464871ac515aaba9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsigc_1_1const__reference__wrapper.html">const_reference_wrapper</a>&lt;T_type&gt; sigc::ref </td>
          <td>(</td>
          <td class="paramtype">const T_type &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a const reference wrapper. </p>
<p>Passing an object throught <a class="el" href="namespacesigc.html#a48e982c74c057b5630246ba436524041" title="Creates a reference wrapper. ">sigc::ref()</a> makes libsigc++ adaptors like, e.g., <a class="el" href="group__bind.html#ga2f099bc6056b32f2a58134ba8537c6f4" title="Creates an adaptor of type sigc::bind_functor which binds the passed argument to the passed functor...">sigc::bind</a> store references to the object instead of copies. If the object type inherits from <a class="el" href="structsigc_1_1trackable.html" title="Base class for objects with auto-disconnection. ">sigc::trackable</a> this will ensure automatic invalidation of the adaptors when the object is deleted or overwritten.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Reference to store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference wrapper. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b5529822bdaf60f07456633e0f40282"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T_type&amp; sigc::unwrap </td>
          <td>(</td>
          <td class="paramtype">const reference_wrapper&lt; T_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2f758c77e8743093f938d0c5dbf06778"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class T_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T_type&amp; sigc::unwrap </td>
          <td>(</td>
          <td class="paramtype">const const_reference_wrapper&lt; T_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 31 2014 12:53:45 for libsigc++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
